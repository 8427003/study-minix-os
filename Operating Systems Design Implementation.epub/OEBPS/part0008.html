<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>part0008</title>
    <meta content="abbyy to epub tool, v0.2" name="generator"/>
    <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
    <meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
    <div class="body">
      <p> 4017 tp-&gt;tty_inhead = tp-&gt;tty_inqueue; /* discard all input */</p>
      <p> 4018 tp-&gt;tty_intail = tp-&gt;tty_inqueue;</p>
      <p> 4019 tp-&gt;tty_incount = 0;</p>
      <p> 4020 tp-&gt;tty_lfct = 0;</p>
      <p> 4021 tp-&gt;tty_inleft = 0;</p>
      <p> 4022 tp-&gt;tty_outleft = 0;</p>
      <p> 4023 tp-&gt;tty_waiting = N0T_WAITING; /* don't send reply */</p>
      <p> 4024 tp-&gt;tty_inhibited = RUNNING;</p>
      <p> 4025 tty_reply(TASK_REPLY, m_ptr-&gt;m_source, m_ptr-&gt;PR0C_NR, EINTR, 0L, 0L);</p>
      <p> 4026 }</p>
      <p> 4028 /«:== = = = = ::: === = :=:::::: = = = : = = ::::::::::= =  : :== = r :  = =  ::: =:r== =  :  = == :: =: : : = =  f</p>
      <p> 4029 * tty_reply *</p>
      <p> 4030 *============================================:===============================*/</p>
      <p> 4031 PRIVATE tty_reply(code, replyee, proc_nr, status, extra, other)</p>
      <p> 4032 int code; /* TASK_REPLY or REVIVE */</p>
      <p> 4033 int replyee; /# destination address for the reply */</p>
      <p> 4034 int proc_nr; /# to whom should the reply go? */</p>
      <p> 4035 int status; /* reply code */</p>
      <p> 4036 long extra; /# extra value */</p>
      <p> 4037 long other; /* used for I0CTL replies */</p>
      <p> 4038 {</p>
      <p> 4039 /* Send a reply to a process that wanted to read or write data. */ 4040</p>
      <p> 4041 message tty_mess; 4042</p>
      <p> 4043 tty_mess.m_type = code;</p>
      <p> 4044 tty_mess.REP_PR0C_NR = proc_nr;</p>
      <p> 4045 tty_mess.REP_5TATUS = status;</p>
      <p> 4046 tty_mess.TTY_FLAGS = extra;     /* used by I0CTL for flags (mode) #/</p>
      <p> 4047 tty_mess.TTY_SPEK = other;       /* used by I0CTL for erase and kill chars */</p>
      <p> 4048 send(replyee, &amp;tty_mess);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 515</p>
      <p> 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099</p>
      <p class="illus">
        <img src="images/picture85.jpg" alt="picture85"/>
      </p>
      <p> //ifdef i8088</p>
      <p> /* Now begins the code and data for the device-dependent tty drivers. */</p>
      <p> /* Definitions used //define C0L0R_BASE //define M0N0_BASE //define C_VID_MASK //define M_VID_MASK //define C_RETRACE //define M_RETRACE //define W0RD_MASK ^define 0FF_MASK //define BEEP_FREQ //define B_TIME //define BLANK ^define LINE_WIDTH //define 5CR_LINES ^define CTRL_S //define MONOCHROME //define CONSOLE //define G0_F0RWARD //define GO_BACKWARD //define TIMER2 ^define TIMER3 //define KEYBD //define P0RT_B //define KBIT</p>
      <p> by the console</p>
      <p> 0xB800 OxBOOO 0x3FFF OxOFFF 0x0300 0x7000 OxFFFF OxOOOF 0x0533 0x2000 0x0700 80 25 31 1 0 0 1</p>
      <p> 0x42 0x43 0x60 0x61 0x80</p>
      <p> /* /* /* /* /* /* /* /* I* I* /* /* /* /* /* /* /* I* /* /* /* /* I*</p>
      <p> */ */</p>
      <p> driver. */</p>
      <p> video ram paragraph for color display */ video ram address for mono display */ mask for 16K video RAM */ mask for   4K video RAM */ how many characters to display at once how many characters to display at once mask for 16 bits */ mask for   4 bits  */</p>
      <p> value to put into timer to set beep freq */ how long to sound the CTRL-G beep tone */ determines   cursor color on blank screen */ §  characters on a line */ // lines on the screen */ scan code for letter S (for CRTL-S)  */ value for tty_ioport tells color vs. mono */ line number for console */ scroll forward */ scroll backward */ 1/0 port for timer channel 2 ■*/ 1/0 port for timer channel 1/0 port for keyboard data I/O port for 8255 port B */ bit used to ack characters to keyboard */</p>
      <p> 3 */ */</p>
      <p> /# Constants relating to the video RAM and 6845.</p>
      <p> */</p>
      <p> (Cdefine M_6845 0x3B0</p>
      <p> //define C_6845 0x3D0</p>
      <p> //define INDEX 4</p>
      <p> ^define DATA 5</p>
      <p> //define CUR_SIZE 10</p>
      <p> //define VID_0RG 12</p>
      <p> ^define CURSOR 14</p>
      <p> /</p>
      <p> port for 6845 mono */ /* port for 6845 color */ /* 6845's index register #/ /* 6845's data register */ /♦ 6845's cursor size register */ I* I*</p>
      <p> 6845's origin register */ 6845's cursor register */</p>
      <p> /* Definitions used for determining if the keyboard is IBM or Olivetti type. */</p>
      <p> ^define KB_STATUS 0x64</p>
      <p> //define BYTE_AVAIL 0x01</p>
      <p> //define KB_BUSY 0x02</p>
      <p> //define DELUXE 0x01</p>
      <p> //define GET_TYPE 5</p>
      <p> //define 0LIVETTI_EQUAL 12</p>
      <p> /# Olivetti keyboard status port */</p>
      <p> /* there is something in KEYBD port */</p>
      <p> /* KEYBD port ready to accept a command */</p>
      <p> /* this bit is set up iff deluxe keyboard */</p>
      <p> /# command to get keyboard type */</p>
      <p> /* the '=' key is 12 on Olivetti, 13 on IBM */</p>
      <p> 516 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 4100</p>
      <p> 4101 /* Global variables used by</p>
      <p> 4102 PUBLIC int color;</p>
      <p> 4103 PUBLIC message keybcLmess;</p>
      <p> 4104 PRIVATE vid_retrace;</p>
      <p> 4105 PRIVATE unsigned vid_base;</p>
      <p> 4106 PRIVATE int vid_mask;</p>
      <p> 4107 PRIVATE int vid_port;</p>
      <p> 4108 4109</p>
      <p> 4110 /*: = = = ::= = : = ::: = :::: = = : = = = :=:::: = = = ::":: = = : = = ::::::== = =:== = = ::::: = = = = ==: = = ::»</p>
      <p> 4111 * keyboard *</p>
      <p> 4112 ♦ = = = = = = = = = = = = = = = = 3 = = = = =: = = = = = = = = : = = = = = = = : = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = ; = :: = = */</p>
      <p> 4113 PUBLIC keyboardO</p>
      <p> 4114 {</p>
      <p> 4115 /* A keyboard interrupt has occurred.   Process it. */</p>
      <p> 4116</p>
      <p> 4117 int val, code, k, raw_bit;</p>
      <p> 4118 char stopc; 4119</p>
      <p> 4120 /* Fetch the character from the keyboard hardware and acknowledge it. */</p>
      <p> 4121 port_in(KEYBD, &amp;code); /* get the scan code for the key struck  */</p>
      <p> 4122 port_in(P0RT_B, &amp;val); /* strobe the keyboard to ack the char */</p>
      <p> 4123 port_out(P0RT_B, val | KBIT); /* strobe the bit high */</p>
      <p> 4124 port_out(P0RT_B, val);  /*  now strobe it low */ 4125</p>
      <p> 4126 /* The IBM keyboard interrupts twice per key, once when depressed, once when</p>
      <p> 4127 * released.   Filter out the latter, ignoring all but the shift-type keys.</p>
      <p> 4128 * The shift-type keys, 29, 42, 54, 56, and 69 must be processed normally.</p>
      <p> 4129 */</p>
      <p> 4130 k = code - 0200; /* codes &gt; 0200 mean key release #/</p>
      <p> 4131 if (k &gt; 0) {</p>
      <p> 4132 /* A key has been released. #/</p>
      <p> 4133 if (k != 29 &amp;&amp; k != 42 &amp;&amp; k != 54 &amp;&amp; k != 56 &amp;&amp; k != 69) {</p>
      <p> 4134 port_out(INT_CTL, ENABLE); /* re-enable interrupts */</p>
      <p> 4135 return; /* don't call tty_task() */</p>
      <p> 4136 }</p>
      <p> 4137 } else {</p>
      <p> 4138 /* Check to see if character is CTRL-S, to stop output. Setting xoff</p>
      <p> 4139 * to anything other than CTRL-S will not be detected here, but will</p>
      <p> 4140 # be detected later, in the driver.    A general routine to detect any</p>
      <p> 4141 * xoff character here would be complicated since we only have the</p>
      <p> 4142 * scan code here, not the ASCII character.</p>
      <p> 4143 */</p>
      <p> 4144 raw_bit = tty_struct[CONS0LE].tty_mode &amp; RAW;</p>
      <p> 4145 stopc = tty_struct[C0NS0LE].tty_xoff;</p>
      <p> 4146 if (raw_bit == 0 &amp;&amp; control &amp;&amp; code == CTRL_S &amp;&amp; stopc == X0FF_CHAR) {</p>
      <p> 4147 tty_struct[C0NS0LE].tty_inhibited = STOPPED;</p>
      <p> 4148 port_out(INT_CTL, ENABLE);</p>
      <p> 4149 return;</p>
      <p> the console driver. */</p>
      <p> /* 1 if console is color, 0 if it is mono */</p>
      <p> /# message used for console input chars */</p>
      <p> /♦ how many characters to display per burst */</p>
      <p> /* base of video ram (OxBOOO or 0xB800) */</p>
      <p> /* 037777 for color (16K) or 07777 for mono */</p>
      <p> /* 1/0 port for accessing 6845  */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 517</p>
      <p> 4150 }</p>
      <p> 4151 } 4152</p>
      <p> 4153 /* Check for CTRL-ALT-DEL, and if found, reboot the computer. */</p>
      <p> 4154 if (control &amp;&amp; alt &amp;&amp; code == DEI CODE) rebootO;        /* CTRL-ALT-DEL */</p>
      <p> 4155</p>
      <p> 4156 /* Store the character in memory so the task can get at it later. */</p>
      <p> 4157 if ( (k = tty_driver_buf[0]) &lt; tty_driver_buf[l]) {</p>
      <p> 4158 /* There is room to store this character; do it. */</p>
      <p> 4159 k = k + k; /* each entry contains two bytes */</p>
      <p> 4160 tty_driver_buf[k+2] = code;        /* store the scan code */</p>
      <p> 4161 tty_driver_buf[k+3] = CONSOLE;    /* tell which line it came from */</p>
      <p> 4162 tty_driver_buf[0]++; /* increment counter */ 4163</p>
      <p> 4164 /* Build and send the interrupt message. */</p>
      <p> 4165 keybd_mess.m_type = TTY_CHAR_INT;</p>
      <p> 4166 keybd_mess.ADDRESS = tty_driver_buf;</p>
      <p> 4167 interrupt(TTY, 4keybd_mess);      /* send a message to the tty task #/</p>
      <p> 4168 } else {</p>
      <p> 4169 /* Too many characters have been buffered.   Discard excess. */</p>
      <p> 4170 port_out(INT_CTL, ENABLE); /* re-enable 8259A controller */</p>
      <p> 4171 }</p>
      <p> 4172 }</p>
      <p> 4175 /* = = = = r = = =: = = = = = = = = = = = = = = = = r = : = = = = = =: = = = = = = = = = = = = = = = : = = = = = = = r = = = = = = = = = = = = = = = :</p>
      <p> 4176 * console</p>
      <p> 4177 )(::: = :: = = ==::::::: = :::::::::: = = ::::::=:::::::: = :===::::=::=:"::::=::: = ==</p>
      <p> 4178 PRIVATE console(tp)</p>
      <p> 4179 register struct tty_struct *tp; /* tells which terminal is to be used */</p>
      <p> 4180 {</p>
      <p> 4181 /* Copy as much data as possible to the output queue, then start I/O. On</p>
      <p> 4182 * memory-mapped terminals, such as the IBM console, the I/O will also be</p>
      <p> 4183 * finished, and the counts updated.    Keep repeating until all I/O done.</p>
      <p> 4184 */ 4185</p>
      <p> 4186 int count;</p>
      <p> 4187 char c;</p>
      <p> 4188 unsigned segment, offset, offsetl; 4189</p>
      <p> 4190 /* Loop over the user bytes one at a time, outputting each one. */</p>
      <p> 4191 segment = (tp-&gt;tty_phys » 4) 4 W0RD_MASK;</p>
      <p> 4192 offset = tp-&gt;tty_phys &amp; 0FF_MASK;</p>
      <p> 4193 offsetl = offset;</p>
      <p> 4194 count = 0; 4195</p>
      <p> 4196 while (tp-&gt;tty_outleft &gt; 0 &amp;&amp; tp-&gt;tty_inhibited == RUNNING) {</p>
      <p> 4197 c = get_byte(segment, offset);    /* fetch 1 byte from user space #/</p>
      <p> 4198 out_char(tp, c); /* write 1 byte to terminal */</p>
      <p> 4199 offset++; /# advance one character in user buffer #/</p>
      <p> 518 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 4200 tp-&gt;tty_outleft—; /# decrement count */</p>
      <p> 4201 }</p>
      <p> 4202 flush(tp); /* clear out the pending characters */ 4203</p>
      <p> 4204 /* Update terminal data structure. */</p>
      <p> 4205 count = offset - offsetl; /*  §  characters printed */</p>
      <p> 4206 tp-&gt;tty_phys += count; /* advance physical data pointer */</p>
      <p> 4207 tp-&gt;tty_cum += count; /* number of characters printed */ 4208</p>
      <p> 4209 /* If all data has been copied to the terminal, send the reply. */</p>
      <p> 4210 if (tp-&gt;tty_outleft == 0) finish(tp, tp-&gt;tty_cum);</p>
      <p> 4211 }</p>
      <p> 4214 /*: = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = rr=:: = = = =: = = = = = r = = = = = = = = rr = = = = = = = = = =*</p>
      <p> 4215 * out_char *</p>
      <p> 4216 «:==:::=:::=::::::==:=:::::::::==::::::::::::::===::=:::=::=:::::=========:»/</p>
      <p> 4217 PRIVATE out_char(tp, c)</p>
      <p> 4218 register struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 4219 char c; /* character to be output */</p>
      <p> 4220 {</p>
      <p> 4221 /* Output a character on the console. Check for escape sequences, including</p>
      <p> 4222 *     ESC 32+x 32+y to move cursor to (x, y)</p>
      <p> 4223 *     ESC     0 to clear from cursor to end of screen</p>
      <p> 4224 *     ESC     1 to reverse scroll the screen 1 line</p>
      <p> 4225 *     ESC z x to set the attribute byte to x (z is a literal here)</p>
      <p> 4226 */ 4227</p>
      <p> 4228 /* Check to see if we are part way through an escape sequence. #/</p>
      <p> 4229 if (tp-&gt;tty_esc_state == 1) {</p>
      <p> 4230 tp-&gt;tty_echar = c;</p>
      <p> 4231 tp-&gt;tty_esc_state = 2;</p>
      <p> 4232 return;</p>
      <p> 4233 } 4234</p>
      <p> 4235 if (tp-&gt;tty_esc_sta*-- == 2) {</p>
      <p> 4236 escape(tp, tp-&gt;tty_echar, c);</p>
      <p> 4237 tp-&gt;tty_esc_state = 0;</p>
      <p> 4238 return;</p>
      <p> 4239 } 4240</p>
      <p> 4241 switch(c) {</p>
      <p> '4242 case 007: /* ring the bell */</p>
      <p> 4243 flush(tp); /* print any chars queued for output */</p>
      <p> 4244 beep(BEEP_FREQ);/* BEEP_FREQ gives bell tone */</p>
      <p> 4245 return; 4246</p>
      <p> 4247 case 013: /* CTRL-K */</p>
      <p> 4248 move_to(tp, tp-&gt;tty_column,  tp-&gt;tty_row + 1);</p>
      <p> 4249 return;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.e</p>
      <p> 519</p>
      <p> 4250</p>
      <p> 4251 case 014: /* CTRL-L */</p>
      <p> 4252 move_to(tp, tp-&gt;tty_column + 1, tp-&gt;tty_row);</p>
      <p> 4253 return; 4254</p>
      <p> 4255 case 016: /* CTRL-N */</p>
      <p> 4256 move_to(tp, tp-&gt;tty_column + 1, tp-&gt;tty_row);</p>
      <p> 4257 return; 4258</p>
      <p> 4259 case '\b': /# backspace */</p>
      <p> 4260 move_to(tp, tp-&gt;tty_column - 1, tp-&gt;tty_row) ;</p>
      <p> 4261 return; 4262</p>
      <p> 4263 case '\n': /* line feed */</p>
      <p> 4264 if (tp-&gt;tty_mode &amp; CRMOD) out_char(tp, '\r');</p>
      <p> 4265 if (tp-&gt;tty_row == 0)</p>
      <p> 4266 scroll_screen(tp, G0_F0RWARD);</p>
      <p> 4267 else</p>
      <p> 4268 tp-&gt;tty_row--;</p>
      <p> 4269 move_to(tp, tp-&gt;tty_column, tp-&gt;tty_row);</p>
      <p> 4270 return; 4271</p>
      <p> 4272 case '\r': /* carriage return */</p>
      <p> 4273 move_to(tp, 0, tp-&gt;tty_row);</p>
      <p> 4274 return; 4275</p>
      <p> 4276 case '\t': /* tab */</p>
      <p> 4277 if ( (tp-&gt;tty_mode &amp; XTABS) == XTABS) {</p>
      <p> 4278 do {</p>
      <p> 4279 out_char(tp,  ' ');</p>
      <p> 4280 } while (tp-&gt;tty_column &amp; TAEL.MASK) ;</p>
      <p> 4281 return;</p>
      <p> 4282 }</p>
      <p> 4283 /# Ignore tab if XTABS is off—video RAM has no hardware tab */</p>
      <p> 4284 return; 4285</p>
      <p> 4286 case 033: /* ESC - start of an escape sequence */</p>
      <p> 4287 flush(tp); /* print any chars queued for output */</p>
      <p> 4288 tp-&gt;tty_esc_state =1;    /* mark ESC as seen */</p>
      <p> 4289 return; 4290</p>
      <p> 4291 default: /# printable chars are stored in ramqueue  */</p>
      <p> 4292 if (tp-&gt;tty_column &gt;= LINE_WIDTH) return; /* long line */</p>
      <p> 4293 if (tp-&gt;tty_rwords == TTY_RAM_W0RD5) flush(tp);</p>
      <p> 4294 tp-&gt;tty_ramqueue[tp-&gt;tty_rwords++] = tp-&gt;tty_attribute | c;</p>
      <p> 4295 tp-&gt;tty_column++; /# next column */</p>
      <p> 4296 return;</p>
      <p> 4297 }</p>
      <p> 520 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 4301 /* = = = = = r = = = = =:z = = = = = = = =: = = = = = = z = : = = =:: = = = = = = = = = =: = r = = = = = = = = = = = = = = = = = = = z:: = = = = = r = =</p>
      <p> 4302 * scroll_screen</p>
      <p> 4303 # = = = = = = = r = = = = = = = =  ::  = = = = = = = = = = = = : = = = r = = = = = = = = =: = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 4304 PRIVATE scroll_screen(tp, dir)</p>
      <p> 4305 register struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 4306 int dir; /* G0_F0RWARD or GO_BACKWARD */</p>
      <p> 4307 {</p>
      <p> 4308 int amount, offset; 4309</p>
      <p> 4310 amount = (dir == G0_F0RWARD ? 2 * LINE_WIDTH : -2 * LINE_WIDTH);</p>
      <p> 4311 tp-&gt;tty_org = (tp-&gt;tty_org + amount) &amp; vid_.mask;</p>
      <p> 4312 if (dir == G0_E0RWARD)</p>
      <p> 4313 offset = (tp-&gt;tty_org + 2 * (SCRJ.INES - 1) * LINE_WIDTH) &amp; vid_mask;</p>
      <p> 4314 else</p>
      <p> 4315 offset = tp-&gt;tty_org; 4316</p>
      <p> 4317 /* Blank the new line at top or bottom. */</p>
      <p> 4318 vid_copy(NIL_PTR, vid_base, offset, LINE_WIDTH);</p>
      <p> 4319 set_6845(VID_0RG, tp-&gt;tty_org » 1);   /* 6845 thinks in words */</p>
      <p> 4320 }</p>
      <p> 4323 /* = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = r = = = = = = =</p>
      <p> 4324 * flush</p>
      <p> 4325 *:::: = ::::=::=:::==::=-::: = == = =:: = = := = ::::::==::=== = :=:=: = = = " = :=: = == =====:</p>
      <p> 4326 PRIVATE flush(tp)</p>
      <p> 4327 register struct tty_struct *tp; /# pointer to tty struct #/</p>
      <p> 4328 {</p>
      <p> 4329 /* Have the characters in 'ramqueue' transferred to the screen. */ 4330</p>
      <p> 4331 if (tp-&gt;tty_rwords == 0) return;</p>
      <p> 4332 vid_copy(tp-&gt;tty_ramqueue, vid_base, tp-&gt;tty_vid, tp-&gt;tty_rwords); 4333</p>
      <p> 4334 /* Update the video parameters and cursor. */</p>
      <p> 4335 tp-&gt;tty_vid += 2 # tp-&gt;tty_rwords;</p>
      <p> 4336 set_6845(CURSOR, tp-&gt;tty_vid » 1);     /* cursor counts in words */</p>
      <p> 4337 tp-&gt;tty_rwords = 0;</p>
      <p> 4338 }</p>
      <p> 4341 * move_to</p>
      <p> 4342 *=  =   =  = = === = = = = === = = = = = = = ==== = = = === = === === = = = = = r = = = = = = = = = === = = = = = = = = = = = === = = = =</p>
      <p> 4343 PRIVATE move_to(tp, x, y)</p>
      <p> 4344 struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 4345 int x; /* column (0 &lt;= x &lt;= 79) */</p>
      <p> 4346 int y, /* row (0 &lt;= y &lt;= 24, 0 at bottom) */</p>
      <p> 4347 {</p>
      <p> 4348 /* Move the cursor to (x, y). */ 4349</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 521</p>
      <p> 4350 flush(tp);</p>
      <p> 4351 if (x &lt; 0 || x &gt;= LINE_WIDTH</p>
      <p> 4352 tp-&gt;tty_column = x;</p>
      <p> 4353 tp-&gt;tty_row = y;</p>
      <p> 4354 tp-&gt;tty_vid = (tp-&gt;tty_org +</p>
      <p> 4355 set_6845(CURS0R, tp-&gt;tty_vid</p>
      <p> 4356 }</p>
      <p> /* flush any pending characters */ I I y &lt; 0 || y &gt;= SCR_LIN£S) return;</p>
      <p> /* set x co-ordinate */</p>
      <p> /* set y co-ordinate */ 2*(SCR_LINES-l-y)* LINE_WIDTH + 2*x); » 1);     /* cursor counts in words */</p>
      <p> 4359 /♦==========================================================================</p>
      <p> 4360 * escape</p>
      <p> 4361 *==========================================================================</p>
      <p> 4362 PRIVATE escape(tp, x, y)</p>
      <p> 4363 register struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 4364 char x; /* escape sequence is ESC x y; this is x */</p>
      <p> 4365 char y; /* escape sequence is ESC x y; this is y */</p>
      <p> 4366 {</p>
      <p> 4367 /* Handle an escape sequence. */ 4368</p>
      <p> 4369 int n, ct, vx;</p>
      <p> 4370</p>
      <p> 4371</p>
      <p> 4372 /* Check for ESC z attribute - used to change attribute byte. */</p>
      <p> 4373 if (x == 'z') {</p>
      <p> 4374 /* Set attribute byte */</p>
      <p> 4375 tp-&gt;tty_attribute = y « 8;</p>
      <p> 4376 return;</p>
      <p> 4377 }</p>
      <p> 4378 /* Check for ESC     n -   used for clear screen, reverse scroll. */</p>
      <p> 4379 if (x = =       ) {</p>
      <p> 4380 if (y == '0' ) {</p>
      <p> 4381 /* Clear from cursor to end of screen #/</p>
      <p> 4382 n = 2 * LINE_WIDTH * (tp-&gt;tty_row + 1) - 2 * tp-&gt;tty_column;</p>
      <p> 4383 vx = tp-&gt;tty_vid;</p>
      <p> 4384 while (n &gt; 0) {</p>
      <p> 4385 ct = MIN(n, vid_retrace);</p>
      <p> 4386 vid_copy(NIL_PTR, vid_base, vx, ct/2);</p>
      <p> 4387 vx += ct;</p>
      <p> 4388 n -= ct;</p>
      <p> 4389 }</p>
      <p> 4390 } else if (y == '1') {</p>
      <p> 4391 /* Reverse scroll. */</p>
      <p> 4392 scroll_screen(tp, GCLBACKWARD);</p>
      <p> 4393 }</p>
      <p> 4394 return;</p>
      <p> 4395 } 4396</p>
      <p> 4397 /* Must be cursor movement (or invalid). */</p>
      <p> 4398 move_to(tp, x - 32, y - 32);</p>
      <p> File: kernel/tty.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 4400 4401 4402 4403 4404 4405 4406 4407 4408 4409 4410 4411 4412 4413 4414 4415 4416 4417 4418 4419 4420 4421</p>
      <p> set_6845</p>
      <p> /* which register pair to set */ /* 16-bit value to set it to */</p>
      <p> PRIVATE set_6845(reg, val) int reg; int val; {</p>
      <p> /* Set a register pair inside the 6845.</p>
      <p> * Registers 10-11 control the format of the cursor (how high it is, etc).</p>
      <p> * Registers 12-13 tell the 6845 where in video ram to start (in WORDS)</p>
      <p> * Registers 14-15 tell the 6845 where to put the cursor (in WORDS) *</p>
      <p> *  Note that registers 12-15 work in words, i.e. 0x0000 is the top left</p>
      <p> * character, but 0x0001 (not 0x0002) is the next character.    This addressing</p>
      <p> * is different from the way the 8088 addresses the video ram, where 0x0002</p>
      <p> * is the address of the next character.</p>
      <p> */</p>
      <p> port_out(vid_port + INDEX, reg); /* set the index register */</p>
      <p> port_out(vid_port + DATA, (val»8) &amp; BYTE);     /# output high byte */</p>
      <p> port_out(vid_port + INDEX, reg +1);    /* again #/</p>
      <p> port_out(vid_port + DATA, val&amp;BYTE);    /* output low byte #/</p>
      <p> 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447</p>
      <p> beep</p>
      <p> /* this value determines beep frequency */</p>
      <p> PRIVATE beep(f) int f; {</p>
      <p> /* Making a beeping sound on the speaker (output for CRTL-G).    The beep is</p>
      <p> # kept short, because interrupts must be disabled during beeping, and it</p>
      <p> # is undesirable to keep them off too long.    This routine works by turning</p>
      <p> # on the bits in port B of the 8255 chip that drive the speaker.</p>
      <p> */</p>
      <p> int x, k; lock();</p>
      <p> port_out(TIMER3,0xB6); port_out(TIMER2, f&amp;BYTE); port_out(TIMER2, (f»8)&amp;BYTE); port_in(P0RT_B,&amp;x); port_out(P0RT_B, x|3); for (k = 0; k &lt; B_TIME; k++); port_out(P0RT_B, x); unlock();</p>
      <p> /* disable interrupts #/</p>
      <p> /» set up timer channel 2 mode */</p>
      <p> /# load low-order bits of frequency in timer *</p>
      <p> /* now high-order bits of frequency in timer *</p>
      <p> /# acquire status of port B */</p>
      <p> /# turn bits 0 and 1 on to beep */</p>
      <p> /* delay loop while beeper sounding */</p>
      <p> /* restore port B the way it was ♦/</p>
      <p> /* re-enable interrupts */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kemel/tty.c</p>
      <p> 523</p>
      <p> 4450 /*= = = = = = = = = = = = : = = = = = = = = = = = = = = = = = = r = r = = = : = :; = = = = = = =: = r = ; = : = = = = = = = = : = = = = = = = = = : = = +</p>
      <p> 4451 * tty_init +</p>
      <p> 4452 *r = = = = = = = = = = = = =: = = = = = = = = = = = = = === = = = = = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = */</p>
      <p> 4453 PRIVATE tty_init()</p>
      <p> 4454 {</p>
      <p> 4455 /* Initialize the tty tables. */ 4456</p>
      <p> 4457 register struct tty_struct *tp; 4458</p>
      <p> 4459 for (tp = &amp;tty_struct[0]; tp &lt; &amp;tty_struct[NR_TTYS]; tp++) {</p>
      <p> 4460 tp-&gt;tty._inhead = tp-&gt;tty_inqueue;</p>
      <p> 4461 tp-&gt;tty_intail = tp-&gt;tty_inqueue;</p>
      <p> 4462 tp-&gt;tty._mode = CRMOD | XTABS | ECHO;</p>
      <p> 4463 tp-&gt;tty._devstart = console;</p>
      <p> 4464 tp-&gt;tty._erase = ERASE_CHAR;</p>
      <p> 4465 tp-&gt;tty._kill   = KILI CHAR;</p>
      <p> 4466 tp-&gt;tty_intr   = INTR_CHAR;</p>
      <p> 4467 tp-&gt;tty,_quit   = QUIT_CHAR;</p>
      <p> 4468 tp-&gt;tty_xon     = X0N_CHAR;</p>
      <p> 4469 tp-&gt;tty_xoff   - X0FF_CHAR;</p>
      <p> 4470 tp-&gt;tty_eof     = E0T_CHAR;</p>
      <p> 4471 } 4472</p>
      <p> 4473 tty_struct[0].tty_makebreak - TW0_INTS; /* tty 0 is console */</p>
      <p> 4474 if (color) {</p>
      <p> 4475 vid_base = C0L0R_BASE;</p>
      <p> 4476 vid_mask = C_VID_MASK;</p>
      <p> 4477 vid_port = C_6845;</p>
      <p> 4478 vid_retrace = C_RETRACE;</p>
      <p> 4479 } else {</p>
      <p> 4480 vid_base = M0N0_BA5E;</p>
      <p> 4481 vid_mask = M_VID_MASK;</p>
      <p> 4482 vid_port = M_6845;</p>
      <p> 4483 vid_retrace = M_RETRACE;</p>
      <p> 4484 }</p>
      <p> 4485 tty_struct[0].tty_attribute = BLANK;</p>
      <p> 4486 tty_driver_buf[1] = MAX_OVERRUN; /* set up limit on keyboard buffering */</p>
      <p> 4487 set_6845(CUR_SIZE, 31); /* set cursor shape */</p>
      <p> 4488 set_6845(VID_.ORG, 0); /* use page 0 of video ram */</p>
      <p> 4489 move_to(&amp;tty_.struct[0], 0, 0); /* move cursor to lower left corner #/ 4490</p>
      <p> 4491 /* Determine which keyboard type is attached.   The bootstrap program asks</p>
      <p> 4492 * the user to type an '='.    The scan codes for '=' differ depending on the</p>
      <p> 4493 * keyboard in use.</p>
      <p> 4494 */</p>
      <p> 4495 if (scan_code — 0LIVETTI_EQUAL) Olivetti = TRUE;</p>
      <p> 524 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 4500 /* = = = = = =: = = = = = = = = = = = = = = = =: = = =: = = = =: = = = = = = = = = = = = = :: = = = = = = = = = = = = : = = = = = = = = = = = = = = = = = = =:*</p>
      <p> 4501 * putc *</p>
      <p> 4502  *= = === === = = === = = = = === = = = ^^ = = = = = = = ^ = = = = = = ^ = === = = = = = = ^ —= = = = = = = = = = = = = = = = =</p>
      <p> 4503 PUBLIC putc(c)</p>
      <p> 4504 char c; /* character to print */</p>
      <p> 4505 {</p>
      <p> 4506 /# This procedure is used by the version of printfO that is linked with</p>
      <p> 4507 * the kernel itself.    The one in the library sends a message to FS, which is</p>
      <p> 4508 * not what is needed for printing within the kernel.    This version just queue;</p>
      <p> 4509 * the character and starts the output.</p>
      <p> 4510 */ 4511</p>
      <p> 4512 out_char(&amp;tty_struct[0], c);</p>
      <p> 4513 }</p>
      <p> 4516 /*===========================================================================*</p>
      <p> 4517  *  func_key *</p>
      <p> 4518 ♦===========================================================================*,</p>
      <p> 4519 PRIVATE func_key(ch)</p>
      <p> 4520 char ch; /* scan code for a function key #/</p>
      <p> 4521 {</p>
      <p> 4522 /* This procedure traps function keys for debugging purposes.   When MINIX is</p>
      <p> 4523 # fully debugged, it should be removed.</p>
      <p> 4524 */ 4525</p>
      <p> 4526 if (ch = = Fl) p_dmp(); /# print process table */</p>
      <p> 4527 if (ch == F2) map_dmp(); /* print memory map */</p>
      <p> 4528 }</p>
      <p> 4529 #endif</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/system.c</p>
      <p> 525</p>
      <p> 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599</p>
      <p> /*</p>
      <p> This task handles the interface between file system and kernel as well as between memory manager and kernel.    System services are obtained by sending sys_task() a message specifying what is needed.   To make life easier for MM and FS, a library is provided with routines whose names are of the form sys_xxx, e.g. sys_xit sends the SYS_XIT message to sys_task. The message types and parameters are:</p>
      <p> SYS_F0RK informs kernel that a process has forked</p>
      <p> SYS_NEWMAP allows MM to set up a process memory map</p>
      <p> SYS_EXEC sets program counter and stack pointer after EXEC</p>
      <p> SYS_XIT informs kernel that a process has exited</p>
      <p> SY5_GETSP caller wants to read out some process' stack pointer</p>
      <p> SYS_TIMES caller wants to get accounting times for a process</p>
      <p> SYS_AB0RT MM or FS cannot go on; abort MINIX</p>
      <p> SYS_SIG send a signal to a process</p>
      <p> SYS_C0PY requests a block of data to be copied between processes</p>
      <p> Message type ml is used for all except SYS_SIG and SYS_C0PY, both of which need special parameter types.</p>
      <p> * In addition to the main sys_task() entry point, there are three other minor</p>
      <p> File: kernel/system.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 4600</p>
      <p> 4601</p>
      <p> 4602</p>
      <p> 4603</p>
      <p> 4604</p>
      <p> 4605</p>
      <p> 4606</p>
      <p> 4607</p>
      <p> 4608</p>
      <p> 4609</p>
      <p> 4610</p>
      <p> 4611</p>
      <p> 4612</p>
      <p> 4613</p>
      <p> 4614</p>
      <p> 4615</p>
      <p> 4616</p>
      <p> 4617</p>
      <p> 4618</p>
      <p> 4619</p>
      <p> 4620</p>
      <p> 4621</p>
      <p> 4622</p>
      <p> 4623</p>
      <p> 4624</p>
      <p> 4625</p>
      <p> 4626</p>
      <p> 4627</p>
      <p> 4628</p>
      <p> 4629</p>
      <p> 4630</p>
      <p> 4631</p>
      <p> 4632</p>
      <p> 4633</p>
      <p> 4634</p>
      <p> 4635</p>
      <p> 4636</p>
      <p> 4637</p>
      <p> 4638</p>
      <p> 4639</p>
      <p> 4640</p>
      <p> 4641</p>
      <p> 4642</p>
      <p> 4643</p>
      <p> 4644</p>
      <p> 4645</p>
      <p> 4646</p>
      <p> 4647</p>
      <p> 4648</p>
      <p> 4649</p>
      <p> * entry points:</p>
      <p> * cause_sig: take action to cause a signal to occur, sooner or later</p>
      <p> * inform:       tell MM about pending signals</p>
      <p> * umap: compute the physical address for a given virtual address */</p>
      <p> ^include ^include ^include ^include ^include ^include ^include ^include ^include ^include</p>
      <p> "../h/const.h" "../h/type.h" "../h/callnr.h" "../h/com.h" "../h/error.h" ". ./h/signal.h" "const.h" "type.h" "glo.h" "proc.h"</p>
      <p> #define C0PY_UNIT</p>
      <p> 65534L       /* max bytes to copy at once */</p>
      <p> extern phys_bytes umapO; PRIVATE message m;</p>
      <p> PRIVATE char sig_stuff[SIG_PUSH_BYTES]; /* used to send signals to processes *</p>
      <p> /*=</p>
      <p> sys_task</p>
      <p> PUBLIC sys_task() {</p>
      <p> /* Main entry point of sys_task.   Get the message and dispatch on type. #/</p>
      <p> register int r;</p>
      <p> while (TRUE) {</p>
      <p> receive(ANY, &amp;m);</p>
      <p> switch (m.m.</p>
      <p> case SYS.</p>
      <p> case SYS.</p>
      <p> case SYS.</p>
      <p> case SYS</p>
      <p> case SYS.</p>
      <p> case SYS.</p>
      <p> case SYS.</p>
      <p> case SYS.</p>
      <p> case SYS. default:</p>
      <p> }</p>
      <p> m,m_type = r</p>
      <p> type) { _F0RK:</p>
      <p> NEWMAP _EXEC: _XIT: .GETSP .TIMES ABORT .SIG: COPY:</p>
      <p> /* which system call */</p>
      <p> r = do_fork(&amp;m); break</p>
      <p> r = do_newmap(&amp;m); break</p>
      <p> r = do_exec(&amp;m); break</p>
      <p> r = do_xit(&amp;m); break</p>
      <p> r = do_getsp(&amp;m); break</p>
      <p> r = do_times(&amp;m); break</p>
      <p> r = do_abort(&amp;m); break</p>
      <p> r = do_sig(&amp;m); break</p>
      <p> r = do_copy(&amp;m); break r = E_BAD_FCN;</p>
      <p> /* 'r' reports status of call */</p>
      <p> MINIX SOURCE CODE             File: kernel/system.c 527</p>
      <p> 4650 send(m.m_source, 4m)j     /* send reply to caller */</p>
      <p> 4651 }</p>
      <p> 4652 }</p>
      <p> 4655 /*==========================================================================-*</p>
      <p> 4656 » do_fork *</p>
      <p> 4657 *===================r=======================================================*/</p>
      <p> 4658 PRIVATE int do_fork(m_ptr)</p>
      <p> 4659 message *m_ptr; /» pointer to request message */</p>
      <p> 4660 {</p>
      <p> 4661 /* Handle sys_fork().    'kl' has forked.   The child is 'k2'. */ 4662</p>
      <p> 4663 register struct proc *rpc;</p>
      <p> 4664 register char #sptr, #dptr;     /* pointers for copying proc struct ♦/</p>
      <p> 4665 int kl; /* number of parent process */</p>
      <p> 4666 int k2; /* number of child process */</p>
      <p> 4667 int pid; /* process id of child */</p>
      <p> 4668 int bytes; /* counter for copying proc struct */ 4669</p>
      <p> 4670 kl = m_ptr-&gt;PR0Cl; /* extract parent slot number from msg */</p>
      <p> 4671 k2 = m_ptr-&gt;PR0C2; /* extract child slot number */</p>
      <p> 4672 pid = m_ptr-&gt;PID; /* extract child process id */ 4673</p>
      <p> 4674 if (kl &lt; 0 || kl &gt;= NR_PR0CS || k2 &lt; 0 || k2 &gt;= NR_PR0CS)return(E_BAD_PR0C);</p>
      <p> 4675 rpc = proc_addr(k2); 4676</p>
      <p> 4677 /# Copy parent 'proc' struct to child. */</p>
      <p> 4678 sptr = (char *) proc_addr(kl); /* parent pointer */</p>
      <p> 4679 dptr = (char *) proc_addr(k2); /* child pointer ♦/</p>
      <p> 4680 bytes = sizeof(struct proc); /*  tt  bytes to copy */</p>
      <p> 4681 while (bytes--) *dptr++ = *sptr++;       /* copy parent struct to child */ 4682</p>
      <p> 4683 rpc-&gt;p_flags )= NCLMAP; /# inhibit the process from running ♦/</p>
      <p> 4684 rpc-&gt;p_pid = pid; /* install child's pid */</p>
      <p> 4685 rpc-&gt;p_reg[RET_REG] =0; /* child sees pid = 0 to know it is child */ 4686</p>
      <p> 4687 rpc-&gt;user_time = 0; /* set all the accounting times to 0 */</p>
      <p> 4688 rpc-&gt;sys_time = 0;</p>
      <p> 4689 rpc-&gt;child_utime = 0;</p>
      <p> 4690 rpc-&gt;child_stime = 0;</p>
      <p> 4691 return(OK);</p>
      <p> 4692 }</p>
      <p> 4695 /♦ = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = : = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = =*</p>
      <p> 4696 * do_newmap *</p>
      <p> 4698 PRIVATE int do_newmap(m_ptr)</p>
      <p> 4699 message *m_ptr; /* pointer to request message */</p>
      <p> 528 File: kernel/system.c MINIX SOURCE CODE</p>
      <p> 4700 {</p>
      <p> 4701 /# Handle sys_newmap().    Fetch the memory map from MM. */ 4702</p>
      <p> 4703 register struct proc *rp, #rsrc;</p>
      <p> 4704 phys_bytes src_phys, dst_phys, pn;</p>
      <p> 4705 vir_bytes vmm, vsys, vn;</p>
      <p> 4706 int caller; /* whose space has the new map (usually MM) */</p>
      <p> 4707 int k; /* process whose map is to be loaded */</p>
      <p> 4708 int old_flags; /# value of flags before modification #/</p>
      <p> 4709 struct mem_map *map_ptr; /* virtual address of map inside caller (MM) */ 4710</p>
      <p> 4711 /* Extract message parameters and copy new memory map from MM. #/</p>
      <p> 4712 caller = m_ptr-&gt;m_source;</p>
      <p> 4713 k r m_ptr-&gt;PR0Cl;</p>
      <p> 4714 map_ptr = (struct mem_map *) m_ptr-&gt;MEM_PTR;</p>
      <p> 4715 if (k &lt; -NR_TASKS | | k &gt;= NR_PR0CS) return(E:_BAD_PR0C);</p>
      <p> 4716 rp = proc_addr(k); /# ptr to entry of user getting new map */</p>
      <p> 4717 rsrc = proc_addr(caller); /* ptr to MM's proc entry */</p>
      <p> 4718 vn = NR_SEGS * sizeof(struct mem_map);</p>
      <p> 4719 pn = vn;</p>
      <p> 4720 vmm = (vir_bytes) map_ptr;       /* careful about sign extension */</p>
      <p> 4721 vsys = (vir_bytes) rp-&gt;p_map; /* again, careful about sign extension »/</p>
      <p> 4722 if ( (src_phys = umap(rsrc, D, vmm, vn)) == 0)</p>
      <p> 4723 panicC'bad call to sys_newmap (src)", N0_NUM);</p>
      <p> 4724 if ( (dst_phys  -  umap(proc_addr(SYSTASK), D, vsys, vn)) == 0)</p>
      <p> 4725 panicC'bad call to sys_newmap (dst)", N0_NUM);</p>
      <p> 4726 phys_copy(src_phys, dst_phys, pn); 4727</p>
      <p> 4728 tfifdef i8088</p>
      <p> 4729 /# On 8088, set segment registers. */</p>
      <p> 4730 rp-&gt;p_reg[CS_REG] = rp-&gt;p_map[T].mem_phys;       /* set cs */</p>
      <p> 4731 rp-&gt;p_reg[DS_REG] = rp-&gt;p_map[D].mem_phys;       /* set ds */</p>
      <p> 4732 rp-&gt;p_reg[S5_REG] = rp-&gt;p_map[D].mem_phys;       /* set ss #/</p>
      <p> 4733 rp-&gt;p_reg[ES_REG] = rp-&gt;p_map[0] .mem_phys;       /* set es */</p>
      <p> 4734 tfendif 4735</p>
      <p> 4736 old_flags = rp-&gt;p_flags; /# save the previous value of the flags */</p>
      <p> 4737 rp-&gt;p_flags &amp;= "N0_MAP;</p>
      <p> 4738 if (old_flags != 0 &amp;&amp; rp-&gt;p_flags == 0) ready(rp);</p>
      <p> 4739 return(OK);</p>
      <p> 4740 }</p>
      <p> 4743 /*===========================================================================*</p>
      <p> 4744 * do_exec *</p>
      <p> 4745 * = = = = = = = = = = = = = = = = = = = = = ; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = */</p>
      <p> 4746 PRIVATE int do_exec(m_ptr)</p>
      <p> 4747 message *m_ptr; /* pointer to request message */</p>
      <p> 4748 {</p>
      <p> 4749 /* Handle sys_exec().   A process has done a successful EXEC. Patch it up. */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/system.c</p>
      <p> 529</p>
      <p> 4750</p>
      <p> 4751 register struct proc *rp;</p>
      <p> 4752 int k; /* which process */</p>
      <p> 4753 int *sp; /* new sp */ 4754</p>
      <p> 4755 k = m_ptr-&gt;PR0Cl; /* 'k' tells which process did EXEC */</p>
      <p> 4756 sp = (int *) m_ptr-&gt;STACK_PTR;</p>
      <p> 4757 if (k &lt; 0 || k &gt;= NR_PR0CS) return(E_BAD_PR0C);</p>
      <p> 4758 rp = proc_addr(k);</p>
      <p> 4759 rp-&gt;p_sp = sp; /* set the stack pointer */</p>
      <p> 4760 rp-&gt;p_pcpsw.pc = (int (#)()) 0; /* reset pc  */</p>
      <p> 4761 rp-&gt;p_alarro = 0; /# reset alarm timer */</p>
      <p> 4762 rp-&gt;p_flags 4= "RECEIVING;       /* MM does not reply to EXEC call */</p>
      <p> 4763 if (rp-&gt;p_flags == 0) ready(rp);</p>
      <p> 4764 return(OK);</p>
      <p> 4765 }</p>
      <p> 4768 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = =:= = *</p>
      <p> 4769 * do_xit *</p>
      <p> 4770 *=================================================== s=== ======= = = s = s== ===== = */</p>
      <p> 4771 PRIVATE int do_xit(m_ptr)</p>
      <p> 4772 message *m_ptr; /# pointer to request message */</p>
      <p> 4773 {</p>
      <p> 4774 /* Handle sys_xit().   A process has exited. */ 4775</p>
      <p> 4776 register struct proc *rp, *rc;</p>
      <p> 4777 struct proc *np, *xp;</p>
      <p> 4778 int parent; /* number of exiting proc's parent */</p>
      <p> 4779 int proc_nr; /* number of process doing the exit */ 4780</p>
      <p> 4781 parent = m_ptr-&gt;PR0Cl; /* slot number of parent process */</p>
      <p> 4782 proc_nr = m_ptr-&gt;PR0C2; /* slot number of exiting process */</p>
      <p> 4783 if (parent &lt; 0 || parent &gt;= NR_PR0CS || proc_nr &lt; 0 || proc_nr &gt;= NR_PR0CS)</p>
      <p> 4784 return(E_BAD_PR0C);</p>
      <p> 4785 rp = proc_addr(parent);</p>
      <p> 4786 rc = proc_addr (proc_nr);</p>
      <p> 4787 rp-&gt;child_utime += rc-&gt;user_time + rc-&gt;child_utime;     /* accum child times */</p>
      <p> 4788 rp-&gt;child_stime += rc-&gt;sys_time + rc-&gt;child_stime;</p>
      <p> 4789 unready(rc);</p>
      <p> 4790 rc-&gt;p_alarm = 0; /* turn off alarm timer  */ 4791</p>
      <p> 4792 /* If the process being terminated happens to be queued trying to send a</p>
      <p> 4793 * message (i.e., the process was killed by a signal, rather than it doing an</p>
      <p> 4794 # EXIT), then it must be removed from the message queues.</p>
      <p> 4795 */</p>
      <p> 4796 if (rc-&gt;p_flags 4 SENDING) {</p>
      <p> 4797 /* Check all proc slots to see if the exiting process is queued. */</p>
      <p> 4798 for (rp = 4proc[0]; rp &lt; 4proc[NR_TA5KS + NR.PR0CS]; rp++) {</p>
      <p> 4799 if (rp-&gt;p_callerq == NIL_PR0C) continue;</p>
      <p> 530 File: kernel/system.c MINIX SOURCE CODE</p>
      <p> 4800 if (rp-&gt;p_callerq == rc) {</p>
      <p> 4801 /* Exiting process is on front of this queue. ♦/</p>
      <p> 4802 rp-&gt;p_callerq = rc-&gt;p..sendlink;</p>
      <p> 4803 break;</p>
      <p> 4804 } else {</p>
      <p> 4805 /* See if exiting process is in middle of queue. */</p>
      <p> 4806 np = rp-&gt;p_callerqj</p>
      <p> 4807 while ( ( xp = np-&gt;p_sendlink) != NIL_PR0C)</p>
      <p> 4808 if (xp == rc) {</p>
      <p> 4809 np-&gt;p..sendlink = xp-&gt;p_sendlink;</p>
      <p> 4810 break;</p>
      <p> 4811 } else {</p>
      <p> 4812 np = xp;</p>
      <p> 4813 }</p>
      <p> 4814 }</p>
      <p> 4815 }</p>
      <p> 4816 }</p>
      <p> 4817 rc-&gt;p_flags  =  P_S10T_FREE;</p>
      <p> 4818 return(OK);</p>
      <p> 4819 }</p>
      <p> 4822 /*============================================:===============================*</p>
      <p> 4823 * do_getsp *</p>
      <p> 4824 ♦ = = = = = = = =  =  = = = = = = = = = = = = = = = = = = = = =: = = = = = r = = = r = = = =: = = = = =: = = = = = = = = = = = = = = = = = = = = = = = = = = */</p>
      <p> 4825 PRIVATE int do_getsp(m_ptr)</p>
      <p> 4826 message *m_ptr; /# pointer to request message #/</p>
      <p> 4827 {</p>
      <p> 4828 /* Handle sys_getsp().   MM wants to know what sp is. */ 4829</p>
      <p> 4830 register struct proc *rp;</p>
      <p> 4831 int k; /* whose stack pointer is wanted? */ 4832</p>
      <p> 4833 k = m_ptr-&gt;PR0Cl;</p>
      <p> 4834 if (k &lt; 0 || k &gt;= NR_PR0CS) return(E_BAD_PR0C);</p>
      <p> 4835 rp = proc_addr(k);</p>
      <p> 4836 m.STACK_PTR = (char *) rp-&gt;p_sp; /» return sp here */</p>
      <p> 4837 return(OK);</p>
      <p> 4838 }</p>
      <p> 4841 /*============================z=====================r====:=====r==r===========*</p>
      <p> 4842 * do_times *</p>
      <p> 4843 *= === ==== = === ====== = ========= === = === ====== = = = = = = ===== === = === = === === = = =:== = = ==*/</p>
      <p> 4844 PRIVATE int do_times(m_ptr)</p>
      <p> 4845 message *m_ptr; /* pointer to request message */</p>
      <p> 4846 {</p>
      <p> 4847 /* Handle sys_times().   Retrieve the accounting information. */ 4848</p>
      <p> 4849 register struct proc *rp;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/system.c</p>
      <p> 531</p>
      <p> 4850 int k; 4851</p>
      <p> 4852 k = m_ptr-&gt;PR0Cl; /* k tells whose times are wanted */</p>
      <p> 4853 if (k &lt; 0 || k &gt;= NR_PR0CS) return(E_BAD_PROC);</p>
      <p> 4854 rp = proc_addr(k); 4855</p>
      <p> 4856 /* Insert the four</p>
      <p> 4857 m_ptr-&gt;USER_TIME</p>
      <p> 4858 m_ptr-&gt;SYSTEM_TIME</p>
      <p> 4859 m_ptr-&gt;CHILD_UTIME</p>
      <p> 4860 m_ptr-&gt;CHILD_STIME</p>
      <p> 4861 return(OK);</p>
      <p> 4862 }</p>
      <p> times needed by the TIMES system call in the message. */ = rp-&gt;user_time; = rp-&gt;sys_time; = rp-&gt;child_utime; = rp-&gt;child_stime;</p>
      <p> 4865 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = = = = = = = = = =  = : = = = =  = = = = = = = = = = = = = = = = = = *</p>
      <p> 4866 # do_abort *</p>
      <p> 4867 «::::::: = :::::::::::::=::::::::::=::: = = :::::":::::: = ::"::::":::="::::::»/</p>
      <p> 4868 PRIVATE int do_abort(m_ptr)</p>
      <p> 4869 message *m_ptr; /* pointer to request message */</p>
      <p> 4870 {</p>
      <p> 4871 /* Handle sys_abort. MINIX is unable to continue. Terminate operation. */ 4872</p>
      <p> 4873 panicC", N0_NUM);</p>
      <p> 4874 }</p>
      <p> 4877 /*===========================================================================*</p>
      <p> 4878 * do_sig *</p>
      <p> 4879 »==================r===============r========r::=============================»/</p>
      <p> 4880 PRIVATE int do_sig(m_ptr)</p>
      <p> 4881 message *m_ptr; /* pointer to request message */</p>
      <p> 4882 {</p>
      <p> 4883 /* Handle sys_sig(). Signal a process. The stack is known to be big enough. */ 4884</p>
      <p> 4885 register struct proc *rp;</p>
      <p> 4886 phys_bytes src_phys, dst_phys;</p>
      <p> 4887 vir_bytes vir_addr, sig_size, new_sp;</p>
      <p> 4888 int proc_nr; /# process number */</p>
      <p> 4889 int sig; /* signal number 1-16 #/</p>
      <p> 4890 int (*sig_handler)(); /* pointer to the signal handler #/ 4891</p>
      <p> 4892 /+ Extract parameters and prepare to build the words that get pushed. */</p>
      <p> 4893 proc_nr = m_ptr-&gt;PR; /* process being signalled */</p>
      <p> 4894 sig = m_ptr-&gt;SIGNUM; /* signal number, 1 to 16 */</p>
      <p> 4895 sig_handler = m_ptr-&gt;FUNC;       /* run time system addr for catching sigs */</p>
      <p> 4896 if (procnr &lt; L0W_USER || proc_nr &gt;= NR_PR0CS) return(E_BAD_PR0C);</p>
      <p> 4897 rp = proc_addr(proc_nr);</p>
      <p> 4898 vir_addr = (vir_bytes) sig_stuff;        /* info to be pushed is in 'sig_stuff</p>
      <p> 4899 new_sp = (vir_bytes) rp-&gt;p_sp;</p>
      <p> 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916</p>
      <p> 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 »</p>
      <p> File: kernel/system.c MINIX SOURCE CODE</p>
      <p> /* Actually build the block of words to push onto the stack. */ build_sig(sig_stuff, rp, sig); /* build up the info to be pushed */</p>
      <p> /* Prepare to do the push, and do it. */ sig_size = SIG_PUSH_BYTES; new_sp -= sig_size;</p>
      <p> src_phys = umap(proc_addr(5YSTASK), D, vir_addr, sig_size); dst_phys = umap(rp, S, new_sp, sig_size);</p>
      <p> if (dst_phys == 0) panic("do_sig can't signal; SP bad", N0_NUM); phys_copy(src_phys, dst_phys, (phys_bytes) sig_size); /* push pc, psw */</p>
      <p> /* Change process' sp and pc to reflect the interrupt. */ rp-&gt;p_sp = (int *) new_sp; rp-&gt;p_pcpsw.pc = sig_handler; return(OK);</p>
      <p> }</p>
      <p> /* = = = = = = = = = = = = = = = = = = = = = = =  =  = = = = = =  =   =  = = =  =   =   =   =   =   =   =   =  =  =   =   =   =   =   =   =   =   =   ::   =   =   =   =   =   =   =   = :  =   =   =   =   =   =   =   =   = :  =   =   =   =  *</p>
      <p> * do_copy *</p>
      <p> PRIVATE int do_copy(m_ptr)</p>
      <p> message *m_ptr; /* pointer to request message */</p>
      <p> {</p>
      <p> /* Handle sys_copy().    Copy data for MM or F5. */</p>
      <p> int src_proc, dst_proc, srcspace, dst_space; vir_bytes srcvir, dst_vir; phys_bytes src_phys, dst_phys, bytes;</p>
      <p> /* Dismember the command message. #/ src_proc = m_ptr-&gt;SRC_PR0C_NR; dst_proc = m_ptr-&gt;DST_PR0C_NR; src_space = m_ptr-&gt;SRC_SPACE; dst_space = m_ptr-&gt;DST_SPACE; src_vir = (vir_bytes) m_ptr-&gt;SRC_BUFFER; dst_vir = (vir_bytes) m_ptr-&gt;DST_BUFFER; bytes = (phys_bytes) m_ptr-&gt;C0PY_BYTES;</p>
      <p> /* Compute the source and destination addresses and do the copy. */ if (src_proc == ABS)</p>
      <p> src_phys = (phys_bytes) m_ptr-&gt;SRC_BUFFER;</p>
      <p> else</p>
      <p> src_phys = umap(proc_addr(src_proc),src_space,src_vir,(vir_bytes) bytes)</p>
      <p> if (dst_proc == ABS)</p>
      <p> dst_phys = (phys_bytes) m_ptr-&gt;DST_BUFFER;</p>
      <p> else</p>
      <p> dst_phys = umap(proc_addr(dst_proc),dst_space,dst_vir, (vir_bytes)bytes)</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/system.c</p>
      <p> 533</p>
      <p> 4950</p>
      <p> 4951 if (src_phys == 0 || dst_phys = = 0) return(EFAULT);</p>
      <p> 4952 phys_copy(src_phys, dst_phys, bytes);</p>
      <p> 4953 return(OK);</p>
      <p> 4954 }</p>
      <p> 4957 /«: ::: : = = = : : = :  = ==::r: : : ::: : :::  =  : = =  : = ::: = : :: :::::;   =   :::::::::r::   =   :::::=:::: :: :)(</p>
      <p> 4958 * cause_sig *</p>
      <p> 4959 *=====r======r======================================r===r===r=======-=======+/</p>
      <p> 4960 PUBLIC cause_sig(proc_nr, sig_nr)</p>
      <p> 4961 int proc_nr; /* process to be signalled #/</p>
      <p> 4962 int sig_nr; /* signal to be sent in range 1 - 16 */</p>
      <p> 4963 {</p>
      <p> 4964 /* A task wants to send a signal to a process.     Examples of such tasks are:</p>
      <p> 4965 »     TTY wanting to cause SIGINT upon getting a DEL</p>
      <p> 4966 »     CLOCK wanting to cause SIGALRM when timer expires</p>
      <p> 4967 * Signals are handled by sending a message to MM.    The tasks don't dare do</p>
      <p> 4968 * that directly, for fear of what would happen if MM were busy.    Instead they</p>
      <p> 4969 * call cause_sig, which sets bits in p_pending, and then carefully checks to</p>
      <p> 4970 * see if MM is free.   If so, a message is sent to it.   If not, when it becomes</p>
      <p> 4971 * free, a message is sent.    The calling task always gets control back from</p>
      <p> 4972 # cause_sig() immediately.</p>
      <p> 4973 */ 4974</p>
      <p> 4975 register struct proc *rp; 4976</p>
      <p> 4977 rp = proc_addr(proc_nr);</p>
      <p> 4978 if (rp-&gt;p_pending == 0) sig_procs++;    /* incr if a new proc is now pending */</p>
      <p> 4979 rp-&gt;p_pending |= 1 « (sig_nr - 1);</p>
      <p> 4980 inform(MM_PR0C_NR); /* see if MM is free */</p>
      <p> 4981 }</p>
      <p> 4984 /*========================================= = ========= ======================== »</p>
      <p> 4985 * inform *</p>
      <p> 4986 #========== =========================== ============================*/</p>
      <p> 4987 PUBLIC inform(proc_nr)</p>
      <p> 4988 int proc_nr; /* MM_PR0C_NR or FS_PR0C_NR */</p>
      <p> 4989 {</p>
      <p> 4990 /♦ When a signal is detected by the kernel (e.g., DEL), or generated by a task</p>
      <p> 4991 ♦ (e.g. clock task for SIGALRM), cause_sig() is called to set a bit in the</p>
      <p> 4992 * p_pending field of the process to signal.   Then informO is called to see</p>
      <p> 4993 * if MM is idle and can be told about it.   Whenever MM blocks, a check is</p>
      <p> 4994 # made to see if 'sig_procs' is nonzero; if so, informO is called.</p>
      <p> 4995 */ 4996</p>
      <p> 4997 register struct proc *rp, *mmp; 4998</p>
      <p> 4999 /* If MM is not waiting for new input, forget it. */</p>
      <p> 534 File: kernel/system.c MINIX SOURCE CODE</p>
      <p> 5000 mmp = proc_addr(proc_nr);</p>
      <p> 5001 if ( ((mmp-&gt;p_flags &amp; RECEIVING) ==0) || mmp-&gt;p_getfrom != ANY) return; 5002</p>
      <p> 5003 /* MM is waiting for new input.   Find a process with pending signals. */</p>
      <p> 5004 for (rp = proc_addr(0); rp &lt; proc_addr(NR_PR0CS); rp++)</p>
      <p> 5005 if (rp-&gt;p_pending != 0) {</p>
      <p> 5006 m.m_type = KSIG;</p>
      <p> 5007 m.PROCl = rp - proc - NR_TASKS;</p>
      <p> 5008 m.SIG_MAP = rp-&gt;p_pending;</p>
      <p> 5009 sig_procs—;</p>
      <p> 5010 if (mini_send(HARDWARE, procnr, &amp;m) != OK)</p>
      <p> 5011 panicC'can't inform MM", N0_NUM);</p>
      <p> 5012 rp-&gt;p_pending = 0; /* the ball is now in MM's court */</p>
      <p> 5013 return;</p>
      <p> 5014 }</p>
      <p> 5015 }</p>
      <p> 5019 * umap *</p>
      <p> 5020 *============================================================================*</p>
      <p> 5021 PUBLIC phys_bytes umap(rp, seg, vir_addr, bytes)</p>
      <p> 5022 register struct proc *rp; /* pointer to proc table entry for process */</p>
      <p> 5023 int seg; /* T, D, or S segment */</p>
      <p> 5024 vir_bytes vir_addr; /* virtual address in bytes within the seg */</p>
      <p> 5025 vir_bytes bytes; /*  #  of bytes to be copied */</p>
      <p> 5026 {</p>
      <p> 5027 /* Calculate the physical memory address for a given virtual address. */</p>
      <p> 5028 vir_clicks vc; /* the virtual address in clicks */</p>
      <p> 5029 phys_bytes seg_base, pa; /* intermediate variables as phys_bytes */ 5030</p>
      <p> 5031 /* If 'seg' is D it could really be S and vice versa.    T really means T.</p>
      <p> 5032 * If the virtual address falls in the gap,   it causes a problem. On the</p>
      <p> 5033 * 8088 it is probably a legal stack reference, since "stackfaults" are</p>
      <p> 5034 * not detected by the hardware.   On 8088s, the gap is called S and</p>
      <p> 5035 * accepted, but on other machines it is called D and rejected.</p>
      <p> 5036 */</p>
      <p> 5037 if (bytes &lt;r 0) return( (phys_bytes) 0);</p>
      <p> 5038 vc = (vir_addr + bytes - 1) » CLICK_SHIFT;     /* last click of data */ 5039</p>
      <p> 5040 tfifdef i8088</p>
      <p> 5041 if (seg != T)</p>
      <p> 5042 seg = (vc &lt; rp-&gt;p_map[D].mem_vir + rp-&gt;p_map[D].mem_len ? D : S);</p>
      <p> 5043 #else</p>
      <p> 5044 if (seg != T)</p>
      <p> 5045 seg = (vc &lt; rp-&gt;p_map[S],mem_vir ? D : S);</p>
      <p> 5046 tfendif 5047</p>
      <p> 5048 if((vir_addr&gt;&gt;CLICK_SHIFT) &gt;= rp-&gt;p_map[segJ.mem_vir + rp-&gt;p_map[segj.mem_l(</p>
      <p> 5049 return( (phys_bytes) 0 );</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/system.c</p>
      <p> 535</p>
      <p> 5050 seg_base = (phys_bytes) rp-&gt;p_map[seg].mem_phys;</p>
      <p> 5051 seg_base = seg_base &lt;&lt; CLICK_SHIFT;     /* segment origin in bytes */</p>
      <p> 5052 pa = (phys_bytes) vir_addr;</p>
      <p> 5053 pa -= rp-&gt;p_map[seg].mem_vir &lt;&lt; CLICK_SHIFT;</p>
      <p> 5054 return(seg_base + pa);</p>
      <p> 536 File: kernel/table.c MINIX SOURCE CODE</p>
      <p> 5100 /# The object file of "table.c" contains all the data.    In the *.h files,</p>
      <p> 5101 * declared variables appear with EXTERN in front of them, as in</p>
      <p> 5102 *</p>
      <p> 5103 *      EXTERN int x;</p>
      <p> 5104 *</p>
      <p> 5105 * Normally EXTERN is defined as extern, so when they are included in another</p>
      <p> 5106 * file, no storage is allocated.    If the EXTERN were not present, but just</p>
      <p> 5107 * say,</p>
      <p> 5108 *</p>
      <p> 5109 *       int x;</p>
      <p> 5110 *</p>
      <p> 5111 * then including this file in several source files would cause 'x' to be</p>
      <p> 5112 * declared several times.    While some linkers accept this, others do not,</p>
      <p> 5113 # so they are declared extern when included normally.    However, it must</p>
      <p> 5114 * be declared for real somewhere.    That is done here by redefining</p>
      <p> 5115 * EXTERN as the null string, so the inclusion of all the *.h files in</p>
      <p> 5116 * table.c actually generates storage for them.   All the initialized</p>
      <p> 5117 * variables are also declared here, since</p>
      <p> 5118 *</p>
      <p> 5119 * extern int x = 4;</p>
      <p> 5120 *</p>
      <p> 5121 * is not allowed.    If such variables are shared, they must also be declared</p>
      <p> 5122 * in one of the *.h files without the initialization.</p>
      <p> 5123 */ 5124</p>
      <p> 5125 ^include "../h/const.h"</p>
      <p> 5126 ^include "../h/type.h"</p>
      <p> 5127 ^include "const.h"</p>
      <p> 5128 ^include "type.h"</p>
      <p> 5129 #undef EXTERN</p>
      <p> 5130 ^define EXTERN</p>
      <p> 5131 ^include "glo.h"</p>
      <p> 5132 ^include "proc.h" 5133</p>
      <p> 5134 extern int sys_task(), clock_task(), mem_task(), floppy_task(),</p>
      <p> 5135 winchester_task(), tty_task(), printer_task(); 5136</p>
      <p> 5137 /* The startup routine of each task is given below, from -NR_TASKS upwards.</p>
      <p> 5138 * The order of the names here MUST agree with the numerical values assigned tc</p>
      <p> 5139 * the tasks in ../h/com.h.</p>
      <p> 5140 */</p>
      <p> 5141 int (*task[NR_TASKS+INIT_PROC_NR+l])() = {</p>
      <p> 5142 printer_task, tty_task, winchester_task, floppy_task, mem_task,</p>
      <p> 5143 clock_task, sys_task, 0, 0, 0, 0</p>
      <p> 5144 };</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/const.h</p>
      <p> 537</p>
      <p> 5150 /* Constants used by the Memory Manager. */ 5151</p>
      <p> 5152 //define ZEROBUF_SIZE      102a      /* buffer size for erasing memory */ 5153</p>
      <p> 5154 /* Size of MM's stack depends mostly on do_exec(). */</p>
      <p> 5155 //if ZER0BUF_SIZE &gt; MAX_PATH</p>
      <p> 5156 ^define MM_STACK_BYTES   MAX_ISTACK_BYTES + ZER0BUF_SIZE + 384</p>
      <p> 5157 //else</p>
      <p> 5158 //define MM_STACK_BYTES   MAX_ISTACK_BYTES + MAX_PATH + 384</p>
      <p> 5159 #endif 5160</p>
      <p> 5161 ^define N0_MEM (phys_clicks)0     /* returned by alloc _mem() with mem is up */ 5162</p>
      <p> 5163 //ifdef i8088</p>
      <p> 5164 ^define PAGE_SIZE 16      /* how many bytes in a page ♦/</p>
      <p> 5165 ^define MAX_PAGE5 4096      /* how many pages in the virtual addr space #/</p>
      <p> 5166 //define HDR_SIZE 32      /*  §  bytes in the exec file header */</p>
      <p> 5167 tfendif 5168</p>
      <p> 5169 ^define printf printk</p>
      <p> 538 File: mm/glo.h MINIX SOURCE CODE</p>
      <p> 5200 /# Global variables. */</p>
      <p> 5201 EXTERN struct mproc *mp; /# ptr to 'mproc' slot of current process #/</p>
      <p> 5202 EXTERN int dont_reply; /* normally 0; set to 1 to inhibit reply */</p>
      <p> 5203 EXTERN int procs_in_use; /* how many processes are marked as IN_USE */ 5204</p>
      <p> 5205  /*  The parameters of the call are kept here. */</p>
      <p> 5206 EXTERN message mm_in; /* the incoming message itself is kept here. */</p>
      <p> 5207 EXTERN message mm_out; /* the reply message is built up here. */</p>
      <p> 5208 EXTERN int who; /* caller's proc number */</p>
      <p> 5209 EXTERN int mm_call; /# system call number */ 5210</p>
      <p> 5211 /# The following variables are used for returning results to the caller. */</p>
      <p> 5212 EXTERN int err_code;  /*  temporary storage for error number */</p>
      <p> 5213 EXTERN int result2; /* secondary result */</p>
      <p> 5214 EXTERN char *res_ptr; /* result, if pointer */ 5215</p>
      <p> 5216 EXTERN char mm_stack[MM_STACK_BYTES];     /* MM's stack #/ 5217</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/mproc.h</p>
      <p> 539</p>
      <p> 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285</p>
      <p> /* This table has one slot per process.    It contains all the memory management</p>
      <p> * information for each process.   Among other things, it defines the text, data</p>
      <p> * and stack segments, uids and gids, and various flags.   The kernel and file</p>
      <p> * systems have tables that are also indexed by process, with the contents</p>
      <p> * of corresponding slots referring to the same process in all three. */</p>
      <p> EXTERN struct mproc {</p>
      <p> struct mem_map mp_seg[NR_SEGS]; /* points to text, data, stack */</p>
      <p> char mp_exitstatus; /* storage for status when process exits */</p>
      <p> char mp_sigstatus; /♦ storage for signal  §  for killed processes */</p>
      <p> int mp_pid; /* process id */</p>
      <p> int mp_parent; /# index of parent process */</p>
      <p> int mp_procgrp; /* process group (used for signals) */</p>
      <p> /* Real and effective uids and gids. */</p>
      <p> uid mp_realuid; uid mp_effuid; gid mp_realgid; gid mp_effgid;</p>
      <p> /* Bit maps for signals. */ unshort mp_ignore; unshort mp_catch; int (*mp_func)();</p>
      <p> unsigned mp_flags; } mproc[NR_PR0CS];</p>
      <p> /* Flag values */</p>
      <p> ^define IN_USE 001</p>
      <p> ^define WAITING 002</p>
      <p> ^define HANGING 004</p>
      <p> ^define PAUSED 010</p>
      <p> ^define ALARM.0N 020</p>
      <p> ^define SEPARATE 040</p>
      <p> /♦ process' real uid */</p>
      <p> /♦ process' effective uid */</p>
      <p> /* process' real gid */</p>
      <p> /* process' effective gid */</p>
      <p> /* 1 means ignore the signal, 0 means don't */ /* 1 means catch the signal, 0 means don't #/ /* all signals vectored to a single user fen #/</p>
      <p> /* flag bits */</p>
      <p> /* set when 'mproc' slot in use */ /* set by WAIT system call */ /* set by EXIT system call */ /* /*</p>
      <p> set by PAUSE system call */ set when SIGALRM timer started */</p>
      <p> /* set if file is separate I &amp; D space */</p>
      <p> 540 File: mm/param.h MINIX SOURCE CODE</p>
      <p> 5300 /* The following names are synonyms for the variables in the input message. */</p>
      <p> 5301 /(define addr mm_in.ml_pl</p>
      <p> 5302 //define exec_name mm_in.ml_pl</p>
      <p> 5303 //define execlen mm_in.ml_il</p>
      <p> 5304 //define func mm_in.nt6_fl</p>
      <p> 5305 //define grpid (gid) mm_in.ml_il</p>
      <p> 5306 ^define kill_sig mm_in.ml_i2</p>
      <p> 5307 //define namelen mm_in.ml_il</p>
      <p> 5308 //define pid mm_in.ml_il</p>
      <p> 5309 ^define seconds mm_in.ml_il</p>
      <p> 5310 //define sig mm_in.m6_il</p>
      <p> 5311 //define stack_bytes mm_in.ml_i2</p>
      <p> 5312 //define stack_ptr mm_in.ml_p2</p>
      <p> 5313 ^define status mm_in.ml_il</p>
      <p> 5314 //define usr_id (uid) mm_in.ml_il 5315</p>
      <p> 5316 /* The following names are synonyms for the variables in the output message. */</p>
      <p> 5317 //define reply_type mm_out .m_type</p>
      <p> 5318 ^define reply_il mm_out.m2_il</p>
      <p> 5319 ^define reply_pl mm_out.m2_pl</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/type.h</p>
      <p> 541</p>
      <p> 5350 /* If there were any type definitions local to the Memory Manager, they would</p>
      <p> 5351  *  be here.    This file is included only for symmetry with the kernel and File</p>
      <p> 5352 * System, which do have some local type definitions.</p>
      <p> 5353 */ 5354</p>
      <p> 5355 ^include ".,/h/type.h"</p>
      <p> 542 File: mm/main.c MINIX SOURCE CODE</p>
      <p> 5400 /* This file contains the main program of the memory manager and some related</p>
      <p> 5401 # procedures.   When MINIX starts up, the kernel runs for a little while,</p>
      <p> 5402 * initializing itself and its tasks, and then it runs MM.   MM at this point</p>
      <p> 5403 * does not know where FS is in memory and how big it is.   By convention, FS</p>
      <p> 5404 * must start at the click following MM, so MM can deduce where it starts at</p>
      <p> 5405 * least.   Later, when FS runs for the first time, FS makes a pseudo-call,</p>
      <p> 5406 * BRK2, to tell MM how big it is.   This allows MM to figure out where INIT</p>
      <p> 5407 * is.</p>
      <p> 5408 *</p>
      <p> 5409 * The entry points into this file are:</p>
      <p> 5410 #     main: starts MM running</p>
      <p> 5411 *     reply:        reply to a process making an MM system call</p>
      <p> 5412 *     do_brk2:     pseudo-call for FS to report its size</p>
      <p> 5413 #/ 5414</p>
      <p> 5415 ^include "../h/const.h"</p>
      <p> 5416 //include "../h/type. h"</p>
      <p> 5417 if/include ". ./h/callnr .h"</p>
      <p> 5418 /(include "../h/com.h"</p>
      <p> 5419 //include ". ./h/error.h"</p>
      <p> 5420 ^include "const.h"</p>
      <p> 5421 //include "glo.h"</p>
      <p> 5422 ^include "mproc.h"</p>
      <p> 5423 //include "param.h" 5424</p>
      <p> 5425 //define ENOUGH (phys_clicks) 4096 /* any  §  &gt; max(FS size, INIT size) */</p>
      <p> 5426 //define CLICK_T0_K (1024L/CLICK_SIZE)     /* convert clicks to K */ 5427</p>
      <p> 5428 PRIVATE phys_clicks tot_mem;</p>
      <p> 5429 extern (*mm_callvec[]) ();</p>
      <p> 5430 extern char *sp_limit; /* stack limit register; checked on calls */</p>
      <p> 5431</p>
      <p> 5432 /♦ = = = : = = = = :: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 5433 * main *</p>
      <p> 5434 * = = = = =:r = =  =  = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = = *</p>
      <p> 5435 PUBLIC mainO</p>
      <p> 5436 {</p>
      <p> 5437 /* Main routine of the memory manager. #/ 5438</p>
      <p> 5439 int error; 5440</p>
      <p> 5441 mm_init(); /* initialize memory manager tables */</p>
      <p> 5442</p>
      <p> 5443 /♦ This is MM's main loop-   get work and do it, forever and forever. */</p>
      <p> 5444 while (TRUE) {</p>
      <p> 5445 /* Wait for message. */</p>
      <p> 5446 get_work(); /* wait for an MM system call */</p>
      <p> 5447 mp = &amp;mproc[who]; 5448</p>
      <p> 5449 /* Set some flags. */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/main.c</p>
      <p> 543</p>
      <p> 5450 error = OK;</p>
      <p> 5451 dont_reply = FALSE;</p>
      <p> 5452 err_code = -999; 5453</p>
      <p> 5454 /* If the call number is valid, perform the call. #/</p>
      <p> 5455 if (nm_call &lt; 0 || mm_call &gt;= NCALLS)</p>
      <p> 5456 error = E_BAD_CALL;</p>
      <p> 5457 else</p>
      <p> 5458 error = (*mm_callvec[mm_call])(); 5459</p>
      <p> 5460 /* Send the results back to the user to indicate completion. */</p>
      <p> 5461 if (dont_reply) continue; /* no reply for EXIT and WAIT */</p>
      <p> 5462 if (mm_call      EXEC &amp;&amp; error — OK) continue;</p>
      <p> 5463 reply(who, error, result2, res_ptr);</p>
      <p> 5464 }</p>
      <p> 5465 }</p>
      <p> 5469 * get_work *</p>
      <p> 5470 *===========================================================================#/</p>
      <p> 5471 PRIVATE get_work()</p>
      <p> 5472 {</p>
      <p> 5473 /* Wait for the next message and extract useful information from it. */ 5474</p>
      <p> 5475 if (receive(ANY, &amp;mm_in) != OK) panicC'MM receive error", N0_NUM);</p>
      <p> 5476 who = mm_in.m_source; /* who sent the message */</p>
      <p> 5477 if (who &lt; HARDWARE || who &gt;= NR_PR0CS) panicC'MM called by", who);</p>
      <p> 5478 mm_call = mm_in.m_type; /* system call number */</p>
      <p> 5479 }</p>
      <p> 5482 /t: = = :== = ===" ===== = : : =::: :: : = :: :::::::: ::::::: :::::::: : ::::::::::::::::::::: ,</p>
      <p> 5483 * reply #</p>
      <p> 5484 *==================================r================r====r=z=:==r==:z=;=====:*/</p>
      <p> 5485 PUBLIC reply(procnr, result, res2, respt)</p>
      <p> 5486 int procnr; /* process to reply to #/</p>
      <p> 5487 int result; /♦ result of the call (usually OK or error #)*/</p>
      <p> 5488 int res2; /♦ secondary result */</p>
      <p> 5489 char *respt; /* result if pointer */</p>
      <p> 5490 {</p>
      <p> 5491 /* Send a reply to a user process. */ 5492</p>
      <p> 5493 register struct mproc #proc_ptr; 5494</p>
      <p> 5495 /* To make MM robust, check to see if destination is still alive. */</p>
      <p> 5496 proc_ptr  =  &amp;mproc[procnr];</p>
      <p> 5497 if ( (proc_ptr-&gt;mp_flags&amp;IN_USE) = = 0 ||  (proc_ptr-&gt;mp_flags&amp;HANGING)) return</p>
      <p> 5498 reply_type = result;</p>
      <p> 5499 reply_il = res2;</p>
      <p> 544 File: mm/main.c MINIX SOURCE CODE</p>
      <p> 5500 reply_pl = respt;</p>
      <p> 5501 if (send(proc_nr, &amp;mm_out) != OK) panicC'MM can't reply", N0_NUM);</p>
      <p> 5502 }</p>
      <p> 5505 At:::::::::::::::::::::::::::::::":::::::::":-::::::::-::::::::":::::::*</p>
      <p> 5506 * mm_init * 5507</p>
      <p> 5508 PRIVATE mm_init()</p>
      <p> 5509 {</p>
      <p> 5510 /* Initialize the memory manager. »/ 5511</p>
      <p> 5512 extern phys_clicks get_tot_mem(), alloc_mem(); 5513</p>
      <p> 5514 /* Find out how much memory the machine has and set up core map.    MM and FS</p>
      <p> 5515 # are part of the map.    Tell the kernel.</p>
      <p> 5516 */</p>
      <p> 5517 tot_mem = get_tot_mem(); /# # clicks in mem starting at absolute 0 */</p>
      <p> 5518 mem_init(tot_mem); /* initialize tables to all physical mem */ 5519</p>
      <p> 5520 /* Initialize MM's tables. */</p>
      <p> 5521 mproc[MM_PROC_NR].mp_flags   = IN_USE;</p>
      <p> 5522 mproc[FS_PR0C_NR].mp_flags   = INJJSE;</p>
      <p> 5523 mproc[INIT_PROC_NR].mp_flags |= IN_USE;</p>
      <p> 5524 procs_in_use = 3; 5525</p>
      <p> 5526 /» Set stack limit, which is checked on every procedure call. */</p>
      <p> 5527 sp_limit = mm_stack - 32;</p>
      <p> 5528 }</p>
      <p> 5531 /#:=== : =: :: = : ======r============: :: :::====:= : ===========:=======::=:=========t</p>
      <p> 5532 * do_brk2 *</p>
      <p> 5533 *r======r=====r===============================r=============================*/</p>
      <p> 5534 PUBLIC do_brk2()</p>
      <p> 5535 {</p>
      <p> 5536 /* This "call" is made once by F5 during system initialization and then never</p>
      <p> 5537 * again by anyone.    It contains the origin and size of IN IT, and the combined</p>
      <p> 5538 * size of the 1536 bytes of unused mem, MINIX and RAM disk.</p>
      <p> 5539 *     ml_il = size of INIT text in clicks</p>
      <p> 5540 *     ml_i2 = size of INIT data in clicks</p>
      <p> 5541 *    ml_i3 = number of bytes for MINIX + RAM DISK</p>
      <p> 5542 *     ml_pl = origin of INIT in clicks</p>
      <p> 5543 */ 5544</p>
      <p> 5545 int meml, mem2, mem3;</p>
      <p> 5546 register struct mproc *rmp;</p>
      <p> 5547 phys_clicks init_org, init_clicks, ram_base, ram_clicks, tot_clicks;</p>
      <p> 5548 phys_clicks init_text_clicks, init_data_clicl&lt;s; 5549</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/main.c</p>
      <p> 545</p>
      <p> 5550 if (who != FS_PR0C_NR) return(EPERM); /» only FS make do BRK2 */</p>
      <p> 5551</p>
      <p> 5552 /* Remove the memory used by MINIX and RAM disk from the memory map. */</p>
      <p> 5553 init_text_clicks = mm_in.ml_il; /* size of INIT in clicks */</p>
      <p> 5554 init_data_clicks = mm_in.ml_i2; /* size of INIT in clicks */</p>
      <p> 5555 tot_clicks = mm_in.ml_i3; /* total size of MINIX + RAM disk */</p>
      <p> 5556 init_org = (phys_clicks) mm_in.ml_pl; /* addr where INIT begins in memory */</p>
      <p> 5557 init_cllcks = init_text_clicks + init_data_clicks;</p>
      <p> 5558 ram_base = init_org + init_clicks;       /# start of RAM disk #/</p>
      <p> 5559 ram_clicks = tot_clicks - ram_base;     /* size of RAM disk */</p>
      <p> 5560 alloc_mem(tot_clicks); /* remove RAM disk from map */ 5561</p>
      <p> 5562 /* Print memory information. */</p>
      <p> 5563 meml = tot_mem/CLICK_TO_K;</p>
      <p> 5564 mem2 = (ram_base + 512/CLICK_SIZE)/CLICK_TO_K; /* MINIX, rounded */</p>
      <p> 5565 mem3 = ram_clicks/CLICK_TO_K;</p>
      <p> 5566 printf(""c 8?oC~0",033, 033);    /* go to top of screen and clear screen */</p>
      <p> 5567 printf("Memory size = SdK        ", meml);</p>
      <p> 5568 printf("MINIX =  XdK        ",  mem2);</p>
      <p> 5569 printf("RAM disk r SdK         ",  mem3);</p>
      <p> 5570 printf("Available = XdK\n\n", meml - mem2 - mem3);</p>
      <p> 5571 if (meml - mem2 - mem3 &lt; 32) {</p>
      <p> 5572 printf("\nNot enough memory to run MINIX\n\n", N0_NUM);</p>
      <p> 5573 sys_abort()j</p>
      <p> 5574 } 5575</p>
      <p> 5576 /* Initialize INIT's table entry. */</p>
      <p> 5577 rmp = &amp;mproc[INIT_PR0C_NR];</p>
      <p> 5578 rmp-&gt;mp_seg[T],mem_phys = init_org;</p>
      <p> 5579 rmp-&gt;mp_seg[T].mem_len   = init_text_clicks;</p>
      <p> 5580 rmp-&gt;mp_seg[D].mem_phys = init_org + init_text_clicks;</p>
      <p> 5581 rmp-&gt;mp_seg[D].mem_len   = init_data_clicks;</p>
      <p> 5582 rmp-&gt;mp_seg[S].mem_vir   = init_clicks;</p>
      <p> 5583 rmp-&gt;mp_seg[S].mem_phys = init_org + init_clicks;</p>
      <p> 5584 if (init_text_clicks != 0) rmp-&gt;mp_flags |= SEPARATE; 5585</p>
      <p> 5586 return(OK);</p>
      <p> 5587 }</p>
      <p> 5590 /*================================================:==========================*</p>
      <p> 5591 * set_map *</p>
      <p> 5592 * = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =:=♦/</p>
      <p> 5593 PRIVATE set_map(proc_nr, base, clicks)</p>
      <p> 5594 int proc_nr; /* whose map to set? */</p>
      <p> 5595 phys_clicks base; /* where in memory does the process start? */</p>
      <p> 5596 phys_clicks clicks; /* total size in clicks (sep I &amp; D not used) */</p>
      <p> 5597 {</p>
      <p> 5598 /* Set up the memory map as part of the system initialization. */ 5599</p>
      <p> 546 File: mm/main.c</p>
      <p> 5600 register struct mproc *rmp;</p>
      <p> 5601 vir_clicks vclicks; 5602</p>
      <p> 5603 rmp - &amp;mproc[proc_nr];</p>
      <p> 5604 vclicks = (vir_clicks) clicks;</p>
      <p> 5605 rmp-&gt;mp_seg[T].mem_vir = 0;</p>
      <p> 5606 rmp-&gt;mp_seg[T].mem_len = 0;</p>
      <p> 5607 rmp-&gt;mp_seg[T] .mem_phys = base;</p>
      <p> 5608 rmp-&gt;mp_seg[D].mem_vir = 0;</p>
      <p> 5609 rmp-&gt;mp_seg[D].nem_len = vclicks;</p>
      <p> 5610 rmp-&gt;mp_seg[D].mem_phys = base;</p>
      <p> 5611 rmp-&gt;mp_seg[S].mem_vir = vclicks;</p>
      <p> 5612 rmp-&gt;mp_seg[S].men_len = 0;</p>
      <p> 5613 rmp-&gt;mp_seg[S].mem_phys = base + vclicks;</p>
      <p> 5614 sys_newmap(proc_nr, rmp-&gt;mp_seg);</p>
      <p> 5615 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> MINIX SOURCE CODE File: mm/forkexit.c 547</p>
      <p> 5650 /* This file deals with creating processes (via FORK) and deleting them (via</p>
      <p> 5651 * EXIT/WAIT).    When a process forks, a new slot in the 'mproc' table is</p>
      <p> 5652 * allocated for it, and a copy of the parent's core image is made for the</p>
      <p> 5653 # child.    Then the kernel and file system are informed.    A process is removed</p>
      <p> 5654 * from the 'mproc' table when two events have occurred: (1) it has exited or</p>
      <p> 5655 * been killed by a signal, and (2) the parent has done a WAIT.    If the process</p>
      <p> 5656 * exits first, it continues to occupy a slot until the parent does a WAIT.</p>
      <p> 5657 *</p>
      <p> 5658 * The entry points into this file are:</p>
      <p> 5659 *     do_fork:     perform the FORK system call</p>
      <p> 5660 *    do_mm_exit: perform the EXIT system call (by calling mm_exit())</p>
      <p> 5661 *     mm_exit:     actually do the exiting</p>
      <p> 5662 *    do_wait:     perform the WAIT system call</p>
      <p> 5663 */ 5664</p>
      <p> 5665 ^include "../h/const.h"</p>
      <p> 5666 //include ". ./h/type.h"</p>
      <p> 5667 //include "../h/callnr.h"</p>
      <p> 5668 //include ". ./h/error.h"</p>
      <p> 5669 //include "const.h"</p>
      <p> 5670 //include "glo.h"</p>
      <p> 5671 ^include "mproc.h"</p>
      <p> 5672 //include "param.h" 5673</p>
      <p> 5674 ^define LAST_FEW 2     /# last few slots reserved for superuser */</p>
      <p> 5675</p>
      <p> 5676 PRIVATE next_pid = INIT_PR0C_NR+1; /* next pid to be assigned */</p>
      <p> 5677</p>
      <p> 5678 /* Some C compilers require static declarations to precede their first use. */</p>
      <p> 5679</p>
      <p> 5680 /»:: : : ::: ::::: : ": : = :: : : ::"":==i ::: : :: : : : ::::::::::: : ::: : ::::::::::: : :: : ::: ,</p>
      <p> 5681 * do_fork *</p>
      <p> 5682 *=======================:====================================:==============#/</p>
      <p> 5683 PUBLIC int do_fork()</p>
      <p> 5684 {</p>
      <p> 5685 /* The process pointed to by 'mp' has forked.   Create a child process. */ 5686</p>
      <p> 5687 register struct mproc *rmp;     /# pointer to parent */</p>
      <p> 5688 register struct mproc *rmc;      /*  pointer to child */</p>
      <p> 5689 int i, child_nr, t;</p>
      <p> 5690 char *sptr, *dptr;</p>
      <p> 5691 long prog_bytes;</p>
      <p> 5692 phys_clicks prog_clicks, child_base;</p>
      <p> 5693 long parent_abs, child_abs;</p>
      <p> 5694 extern phys_clicks alloc_mem(); 5695</p>
      <p> 5696 /* If tables might fill up during FORK, don't even start since recovery half</p>
      <p> 5697 * way through is such a nuisance.</p>
      <p> 5698 */ 5699</p>
      <p> File: mm/forkexit.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 5700 rrap = mp;</p>
      <p> 5701 if (procs_in_use == NR_PR0CS) return(EAGAIN);</p>
      <p> 5702 if (procs_in_use &gt;= NR_PR0CS - LAST_FEW &amp;&amp; rmp-&gt;mp_effuid != O)return(EAGAIN); 5703</p>
      <p> 5704 /* Determine how much memory to allocate. */</p>
      <p> 5705 prog_clicks = (phys_clicks) rmp-&gt;mp_seg[T].mem_len + rmp-&gt;mp_seg[D].mem_len +</p>
      <p> 5706 rmp-&gt;mp_seg[S].mem_len;</p>
      <p> 5707 iififdef i8088</p>
      <p> 5708 prog_clicks += rmp-&gt;mp_seg[S].mem_vir - rmp-&gt;mp_seg[D].mem_len; /* gap too ♦/</p>
      <p> 5709 #endif</p>
      <p> 5710 prog_bytes = (long) prog.clicks « CLICK_SHIFT;</p>
      <p> 5711 if ( (child_base = alloc_mem(prog_clicks)) == N0_MEM) return(EAGAIN) j 5712</p>
      <p> 5713 /* Create a copy of the parent's core image for the child. */</p>
      <p> 5714 child_abs = (long) child_base « CIICK_SHIFT;</p>
      <p> 5715 parent_abs = (long) rmp-&gt;mp_seg[T],mem_phys &lt;&lt; CLICK_SHIFT;</p>
      <p> 5716 i = mem_copy(ABS, 0, parent_abs, ABS, 0, child_abs, prog_bytes);</p>
      <p> 5717 if ( i &lt; 0) panic("do_fork can't copy", i); 5718</p>
      <p> 5719 /* Find a slot in 'mproc' for the child process.   A slot must exist. */</p>
      <p> 5720 for (rmc = &amp;mproc[0]; rmc &lt; &amp;mproc[NR_PR0CS]; rmc++)</p>
      <p> 5721 if ( (rmc-&gt;mp_flags &amp; INJJSE) == 0) break; 5722</p>
      <p> 5723 /* Set up the child and its memory map; copy its 'mproc' slot from parent. */</p>
      <p> 5724 child_nr = rmc - mproc; /* slot number of the child */</p>
      <p> 5725 procs_in_use++;</p>
      <p> 5726 sptr = (char *) rmp; /* pointer to parent's 'mproc' slot  */ bill  dptr = (char *) rmc;                /* pointer to child's 'mproc' slot */</p>
      <p> 5728 i = sizeof(struct mproc); /* number of bytes in a proc slot. */</p>
      <p> 5729 while (i--) *dptr++ = *sptr++;/* copy from parent slot to child's */ 5730</p>
      <p> 5731 rmc-&gt;mp_parent = who; /* record child's parent »/</p>
      <p> 5732 rmc-&gt;mp_seg[T].mem_phys = child_base;</p>
      <p> 5733 rmc-&gt;mp_seg[D].mem_phys = child_base + rmc-&gt;mp_seg[T],mem_len;</p>
      <p> 5734 rmc-&gt;mp_seg[S] .mem_phys = rmc-&gt;mp_seg[D] .mem._phys +</p>
      <p> 5735 (rmp-&gt;mp_seg[S],mem_phys - rmp-&gt;mp_seg[D].mem_phys);</p>
      <p> 5736 rmc-&gt;mp_exitstatus = 0;</p>
      <p> 5737 rmc-&gt;mp_sigstatus = 0; 5738</p>
      <p> 5739 /# Find a free pid for the child and put it in the table. */</p>
      <p> 5740 do {</p>
      <p> 5741 t = 0; /* 't' = 0 means pid still free */</p>
      <p> 5742 next_pid = (next_pid &lt; 30000 ? next_pid + 1 : INIT_PR0C_NR + 1);</p>
      <p> 5743 for (rmp = &amp;mproc[0]; rmp &lt; &amp;mproc[NR_PR0CS]; rmp++)</p>
      <p> 5744 if (rmp-&gt;mp_pid == next_pid) {</p>
      <p> 5745 t = 1;</p>
      <p> 5746 break;</p>
      <p> 5747 }</p>
      <p> 5748 rmc-&gt;mp_pid = next_pid; /* assign pid to child */</p>
      <p> 5749 } while (t);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/forkexit.c</p>
      <p> 549</p>
      <p> 5750</p>
      <p> 5751 /# Tell kernel and file system about the (now successful) FORK. #/</p>
      <p> 5752 sys_forked(who, child_nr, rmc-&gt;mp_pid);</p>
      <p> 5753 tell_fs(FORK, who, child_nr, 0); 5754</p>
      <p> 5755 /* Report child's memory map to kernel. */</p>
      <p> 5756 sys_newmap(child_nr, rmc-&gt;mp_seg); 5757</p>
      <p> 5758 /* Reply to child to wake it up. */</p>
      <p> 5759 reply(child_nr, 0, 0, Nil PTR);</p>
      <p> 5760 return(next_pid); /+ child's pid */</p>
      <p> 5761 }</p>
      <p> 5765 * do_mm_exit *</p>
      <p> 5766 » = = = = === = = :  = = = = =  :  = == = = :::: = "= : ::== =  ::::::::: : :::::::   =  = ;:: : :I:  =  :;  =  :  = = := :: :: ;»/</p>
      <p> 5767 PUBLIC int do_mm_exit()</p>
      <p> 5768 {</p>
      <p> 5769 /* Perform the exit(status) system call. The real work is done by mm_exit(),</p>
      <p> 5770 * which is also called when a process is killed by a signal.</p>
      <p> 5771 */ 5772</p>
      <p> 5773 mm_exit(mp, status);</p>
      <p> 5774 dont_reply = TRUE; /♦ don't reply to newly terminated process */</p>
      <p> 5775 return(OK); /* pro forma return code */</p>
      <p> 5776 }</p>
      <p> 5779 /*==::====================rrr=r==r======================= = r = ======r=rr=:======*</p>
      <p> 5780 * mm_exit *</p>
      <p> 5781 »========= : == : ====:=: : = : ::===: ::: == : = :: : :::::::: : ::::= ;:: :::::::;=:===::::: :»/</p>
      <p> 5782 PUBLIC mm_exit(rmp, exit_status)</p>
      <p> 5783 register struct mproc #rmp; /* pointer to the process to be terminated */</p>
      <p> 5784 int exit_status; /♦ the process' exit status (for parent) */</p>
      <p> 5785 {</p>
      <p> 5786 /* A process is done. If parent is waiting for it, clean it up, else hang. */ 5787</p>
      <p> 5788 /♦ How to terminate a process is determined by whether or not the</p>
      <p> 5789 * parent process has already done a WAIT.    Test to see if it has.</p>
      <p> 5790 */</p>
      <p> 5791 rmp-&gt;mp_exitstatus = (char) exit_status; /* store status in 'mproc' */ 5792</p>
      <p> 5793 if (mproc[rmp-&gt;mp_parent].mp_flags &amp; WAITING)</p>
      <p> 5794 cleanup(rmp); /* release parent and tell everybody #/</p>
      <p> 5795 else</p>
      <p> 5796 rmp-&gt;mp_flags |= HANGING; /* Parent not waiting. Suspend proc ♦/ 5797</p>
      <p> 5798 /* If the exited process has a timer pending, kill it. */</p>
      <p> 5799 if (rmp-&gt;mp_flags &amp; ALARM_0N) set_alarm(rmp - mproc, (unsigned) 0);</p>
      <p> 550 File: mm/forkexit.c MINIX SOURCE CODE</p>
      <p> 5800</p>
      <p> 5801 /* Tell the kernel that the process is no longer runnable. */</p>
      <p> 5802 sys_xit(rmp-&gt;mp_parent, rmp - mproc);</p>
      <p> 5803 }</p>
      <p> 5807 #                                                do_wait *</p>
      <p> 5809 PUBLIC int do_wait()</p>
      <p> 5810 {</p>
      <p> 5811 /* A process wants to wait for a child to terminate. If one is already waiting,</p>
      <p> 5812 * go clean it up and let this WAIT call terminate.    Otherwise, really wait.</p>
      <p> 5813 */ 5814</p>
      <p> 5815 register struct mproc *rp;</p>
      <p> 5816 register int children; 5817</p>
      <p> 5818 /* A process calling WAIT never gets a reply in the usual way via the</p>
      <p> 5819 * replyO in the main loop.   If a child has already exited, the routine</p>
      <p> 5820 * cleanupO sends the reply to awaken the caller.</p>
      <p> 5821 */ 5822</p>
      <p> 5823 /* Is there a child waiting to be collected? */</p>
      <p> 5824 children = 0;</p>
      <p> 5825 for (rp = &amp;mproc[0]; rp &lt; &amp;mproc[NR_PR0CS]; rp++) {</p>
      <p> 5826 if ( (rp-&gt;mp_flags &amp; IN_USE) 4&amp; rp-&gt;mp_parent == who) {</p>
      <p> 5827 children++j</p>
      <p> 5828 if (rp-&gt;mp_flags &amp; HANGING) {</p>
      <p> 5829 cleanup(rp);       /* a child has already exited */</p>
      <p> 5830 dont_reply = TRUE;</p>
      <p> 5831 return(OK);</p>
      <p> 5832 }</p>
      <p> 5833 }</p>
      <p> 5834 } 5835</p>
      <p> 5836 /* No child has exited.   Wait for one, unless none exists. */</p>
      <p> 5837 if (children &gt; 0) { /# does this process have any children? */</p>
      <p> 5838 mp-&gt;mp_flags |= WAITING;</p>
      <p> 5839 dont_reply = TRUE;</p>
      <p> 5840 return(OK); /* yes - wait for one to exit */</p>
      <p> 5841 } else</p>
      <p> 5842 return(ECHILD); /* no - parent has no children */</p>
      <p> 5843 }</p>
      <p> 5846 /*===========================================================================*</p>
      <p> 5847 * cleanup *</p>
      <p> 5848 »  =  = = = = = = = = = = = = = = = = = r = = = = : = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = */</p>
      <p> 5849 PRIVATE cleanup(child)</p>
      <p> ] MINIX SOURCE CODE</p>
      <p> File: mm/forkexil.c</p>
      <p> 551</p>
      <p> 5850 register struct mproc *child;     /* tells which process is exiting */</p>
      <p> 5851 {</p>
      <p> 5852 /* Clean up the remains of a process.    This routine is only called if two</p>
      <p> 5853 * conditions are satisfied:</p>
      <p> 5854 * 1. The process has done an EXIT or has been killed by a signal.</p>
      <p> 5855 # 2. The process' parent has done a WAIT.</p>
      <p> 5856 *</p>
      <p> 5857 * It tells everyone about the process' demise and also releases the memory, if</p>
      <p> 5858 * that has not yet been done.    (Whether it has or has not been done depends on</p>
      <p> 5859 * the order the EXIT and WAIT were done in.)</p>
      <p> 5860 */</p>
      <p> 5861 register struct mproc *parent, #rp;</p>
      <p> 5862 int init_waiting, child_nr;</p>
      <p> 5863 unsigned int r;</p>
      <p> 5864 phys_clicks s; 5865</p>
      <p> 5866 child_nr = child - mproc;</p>
      <p> 5867 parent = 4mproc[child-&gt;mp_parent]; 5868</p>
      <p> 5869 /* Wakeup the parent and tell the file system that the process is dead, */</p>
      <p> 5870 r = child-&gt;mp_sigstatus 4 0377;</p>
      <p> 5871 r = r |  (child-&gt;mp_exitstatus « 8);</p>
      <p> 5872 reply(child-&gt;mp_parent, child-&gt;mp_pid, r, Nil PTR);</p>
      <p> 5873 tell_fs(EXIT, child_nr, 0, 0);    /* file system can free the proc slot */ 5874</p>
      <p> 5875 /* Release the memory occupied by the child. */</p>
      <p> 5876 s = (phys_clicks) child-&gt;mp_seg[S],mem_vir + child-&gt;mp_seg[S].mem_len;</p>
      <p> 5877 if (child-&gt;mp_flags &amp; SEPARATE) s += child-&gt;mp_seg[T].mem_len;</p>
      <p> 5878 free_mem(child-&gt;mp_seg[T].mem_phys, s); /* free the memory */ 5879</p>
      <p> 5880 /* Update flags. */</p>
      <p> 5881 child-&gt;mp_flags 4= "HANGING;   /* turn off HANGING bit */</p>
      <p> 5882 parent-&gt;mp_flags 4= "WAITING; /* turn off WAITING bit */</p>
      <p> 5883 child-&gt;mp_flags 4= "IN_USE;      I*  release the table slot */</p>
      <p> 5884 procs_in_use—; 5885</p>
      <p> 5886 /* If exiting process has children, disinherit them.    INIT is new parent. */</p>
      <p> 5887 init_waiting = (mproc[INIT_PR0C_NR].mp_flags 4 WAITING ? 1 : 0);</p>
      <p> 5888 for (rp = 4mproc[0]; rp &lt; 4mproc[NR_PR0CS]; rp++) {</p>
      <p> 5889 if (rp-&gt;mp_parent == child_nr) {</p>
      <p> 5890 /* 'rp' points to a child to be disinherited. */</p>
      <p> 5891 rp-&gt;mp_parent = INIT_PR0C_NR;     /* init takes over */</p>
      <p> 5892 if (init_waiting 44 (rp-&gt;mp_flags 4 HANGING) ) {</p>
      <p> 5893 /* Init was waiting. */</p>
      <p> 5894 cleanup(rp);       /* recursive call */</p>
      <p> 5895 init_waiting = 0;</p>
      <p> 5896 }</p>
      <p> 5897 }</p>
      <p> 5898 }</p>
      <p> File: mm/exec.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 5936 5937 5938 5939 5940 5941 5942 5943 5944 5945 5946 5947 5948 5949</p>
      <p> This file handles the EXEC system call.    It performs the work as follows:</p>
      <p> - see if the permissions allow the file to be executed</p>
      <p> - read the header and extract the sizes</p>
      <p> - fetch the initial args and environment from the user space</p>
      <p> - allocate the memory for the new process</p>
      <p> - copy the initial stack from MM to the process</p>
      <p> - read in the text and data segments and copy to the process</p>
      <p> - take care of setuid and setgid bits</p>
      <p> - fix up 'mproc' table</p>
      <p> - tell kernel about EXEC</p>
      <p> *</p>
      <p> */</p>
      <p> The only entry point is do_exec.</p>
      <p> ^include ^include //include //include ^include //include //include ^include ^include</p>
      <p> "../h/const.h" "../h/type.h" "../h/callnr.h" "../h/error.h" "../h/stat.h" "const.h" "glo.h" "mproc.h" "param.h"</p>
      <p> //define MAGIC //define SEP ^define TEXTB ^define DATAB //define BSSB //define T0TB</p>
      <p> 0x04000301L Ox00200000L 2 3 4 6</p>
      <p> /* magic number with 2 bits masked off /* value for separate I &amp; D */ /* location of text size in header */ /* location of data size in header #/ /* location of bss size in header */ /*  location of total size in header */</p>
      <p> /*======r========r=====================r=========i===========================#</p>
      <p> # do_exec *</p>
      <p> *====================================================r====================r=*/</p>
      <p> PUBLIC int do_exec() {</p>
      <p> /* Perform the execve(name, argv, envp) call.    The user library builds a</p>
      <p> # complete stack image, including pointers, args, environ, etc.    The stack</p>
      <p> # is copied to a buffer inside MM, and then to the new core image. ♦/</p>
      <p> register struct mproc #rmp; int m, r, fd, ft;</p>
      <p> char mbuf[MAX_ISTACK_BYTES];    /* buffer for stack and zeroes */ union u {</p>
      <p> char name_buf[MAX_PATH]; /* the name of the file to exec */</p>
      <p> char zb[ZER0BUf_SIZE];   /* used to zero bss */</p>
      <p> } u;</p>
      <p> char *new_sp;</p>
      <p> vir_bytes src, dst, text_bytes, data_bytes, bss^bytes, stk_bytes, vsp;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/exec.c</p>
      <p> 553</p>
      <p> 5950 phys_bytes tot_bytes; /* total space for program, including gap */</p>
      <p> 5951 vir_clicks sc;</p>
      <p> 5952 struct stat s_buf; 5953</p>
      <p> 5954 /* Do some validity checks. */</p>
      <p> 5955 rmp  -  mp;</p>
      <p> 5956 stk_bytes = (vir_bytes) stack_bytes;</p>
      <p> 5957 if (stk_bytes &gt; MAX_ISTACK_BYTES) return(ENOMEM);        /* stack too big */</p>
      <p> 5958 if (exec_len &lt;= 0 || exec_len &gt; MAX_PATH) return(EINVAL); 5959</p>
      <p> 5960 /# Get the exec file name and see if the file is executable. */</p>
      <p> 5961 src = (vir_bytes) execname;</p>
      <p> 5962 dst = (vir_bytes) u.name_buf;</p>
      <p> 5963 r = mem_copy(who, D, (long) src, MM_PR0C_NR, D, (long) dst, (long) exec_len);</p>
      <p> 5964 if (r != OK) return(r); /* file name not in user data segment */</p>
      <p> 5965 tell_fs(CHDIR, who, 0, 0);       /* temporarily switch to user's directory */</p>
      <p> 5966 fd = allowed(u.name_buf, &amp;s_buf, X_BIT); /* is file executable? */</p>
      <p> 5967 tell_fs(CHDIR, 0, 1, 0); /* switch back to MM's own directory */</p>
      <p> 5968 if (fd &lt; 0) return(EACCES);     /* file was not executable */ 5969</p>
      <p> 5970 /* Read the file header and extract the segment sizes. */</p>
      <p> 5971 sc = (stk_bytes + CLICK_SIZE - 1) » CLICK_SHIFT;</p>
      <p> 5972 m = read_header(fd, &amp;ft, &amp;text_bytes, &amp;data_bytes, &amp;bss_bytes, 4tot_bytes,sc)</p>
      <p> 5973 if (m &lt; 0) {</p>
      <p> 5974 close(fd); /# something wrong with header */</p>
      <p> 5975 return(ENOEXEC);</p>
      <p> 5976 } 5977</p>
      <p> 5978 /* Fetch the stack from the user before destroying the old core image. */</p>
      <p> 5979 src = (vir_bytes) stack_ptr;</p>
      <p> 5980 dst = (vir_bytes) mbuf;</p>
      <p> 5981 r = mem_copy(who, D, (long) src, MM_PR0C_NR, 0, (long) dst, (long) stk_bytes)</p>
      <p> 5982 if (r != OK) {</p>
      <p> 5983 close(fd); /* can't fetch stack (e.g. bad virtual addr) +/</p>
      <p> 5984 return(EACCES);</p>
      <p> 5985 } 5986</p>
      <p> 5987 /* Allocate new memory and release old memory.    Fix map and tell kernel. */</p>
      <p> 5988 r = new_mem(text_bytes, data_bytes, bss_bytes, stk_bytes, tot_bytes,</p>
      <p> 5989 u.zb, ZER0BUF_SIZE);</p>
      <p> 5990 if (r != OK) {</p>
      <p> 5991 close(fd); /* insufficient core or program too big */</p>
      <p> 5992 return(r);</p>
      <p> 5993 } 5994</p>
      <p> 5995 /* Patch up stack and copy it from MM to new core image. */</p>
      <p> 5996 vsp = (vir_bytes) rmp-&gt;mp_seg[S].mem_vir « CLICK_5HIFT;</p>
      <p> 5997 patch_ptr(mbuf, vsp);</p>
      <p> 5998 src = (vir_bytes) mbufj</p>
      <p> 5999 r = mem_copy(MM_PR0C_NR, D, (long) src, who, D, (long) vsp, (long) stk_bytes)</p>
      <p> 554 File: mm/exec.c MINIX SOURCE CODE</p>
      <p> 6000 if (r != OK) panic("do_exec stack copy err", N0_NUM); 6001</p>
      <p> 6002 /* Read in text and data segments. */</p>
      <p> 6003 load_seg(fd, T, text_bytes);</p>
      <p> 6004 load_seg(fd, D, data_bytes);</p>
      <p> 6005 close(fd); /* don't need exec file any more */ 6006</p>
      <p> 6007 /* Take care of setuid/setgid bits. */</p>
      <p> 6008 if (s_buf.st_mode &amp; I_SET_UID_BIT) {</p>
      <p> 6009 rmp-&gt;mp_effuid = s_buf.st_uid;</p>
      <p> 6010 tell_fs(SETUID, who, (int) rmp-&gt;mp_realuid, (int) rmp-&gt;mp_effuid);</p>
      <p> 6011 }</p>
      <p> 6012 if (s_buf.st_mode &amp; I_SET_GID_BIT) {</p>
      <p> 6013 rmp-&gt;mp_effgid = s_buf.st_gidj</p>
      <p> 6014 tell_fs(SETGID, who, (int) rmp-&gt;mp_realgid, (int) rmp-&gt;mp_effgid);</p>
      <p> 6015 } 6016</p>
      <p> 6017 /* Fix up some 'mproc' fields and tell kernel that exec is done. */</p>
      <p> 6018 rmp-&gt;mp_catch = 0; /* reset all caught signals */</p>
      <p> 6019 rmp-&gt;rap_flags &amp;= "SEPARATE;     /* turn off SEPARATE bit */</p>
      <p> 6020 rmp-&gt;mp_flags |= ft; /* turn it on for separate I &amp; D files */</p>
      <p> 6021 new_sp = (char *) vsp;</p>
      <p> 6022 sys_exec(who, new_sp);</p>
      <p> 6023 return(OK);</p>
      <p> 6024 }</p>
      <p> 6028 *                                                read_header *</p>
      <p> 6030 PRIVATE int read_header(fd, ft, text_bytes, data_bytes, bss_bytes, tot_bytes,sc)</p>
      <p> 6031 int fd; /* file descriptor for reading exec file */</p>
      <p> 6032 int *ft; /# place to return ft number */</p>
      <p> 6033 vir_bytes +text_bytes; /» place to return text size */</p>
      <p> 6034 vir_bytes *data_bytes; /* place to return initialized data size */</p>
      <p> 6035 vir_bytes *bss_bytes; /# place to return bss size */</p>
      <p> 6036 phys_bytes *tot_bytes; /* place to return total size ♦/</p>
      <p> 6037 vir_clicks sc; /# stack size in clicks */</p>
      <p> 6038 {</p>
      <p> 6039 /* Read the header and extract the text, data, bss and total sizes from it. */ 6040</p>
      <p> 6041 int m, ct;</p>
      <p> 6042 vir_clicks tc, dc, s_vir, dvir;</p>
      <p> 6043 phys_clicks tote;</p>
      <p> 6044 long buf[HDR_SIZE/sizeof(long)]; 6045</p>
      <p> 6046 /* Read the header and check the magic number.    The standard MINIX header</p>
      <p> 6047 * consists of 8 longs, as follows:</p>
      <p> 6048 *       0: 0x04100301L (combined I 4 D space) or 0x04200301L (separate I &amp; D)</p>
      <p> 6049 *      1: 0x00000020L</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/exec.c</p>
      <p> 555</p>
      <p> 6050 *      2: size of text segments in bytes</p>
      <p> 6051 *      3: size of initialized data segment in bytes</p>
      <p> 6052 *      4: size of bss in bytes</p>
      <p> 6053 *      5: 0x000000001</p>
      <p> 6054 *      6: total memory allocated to program (text, data and stack, combined)</p>
      <p> 6055 *       7: OxOOOOOOOOL</p>
      <p> 6056 * The longs are represented low-order byte first and high-order byte last.</p>
      <p> 6057 * The first byte of the header is always 0x01, followed by 0x03.</p>
      <p> 6058 * The header is followed directly by the text and data segments, whose sizes</p>
      <p> 6059 * are given in the header.</p>
      <p> 6060 */ 6061</p>
      <p> 6062 if (read(fd, buf, HDR_SIZE) != H0R_SIZE) return(ENOEXEC);</p>
      <p> 6063 if ( (buf[0] &amp; OxFFOFFFFFL) != MAGIC) return(ENOEXEC);</p>
      <p> 6064 *ft = (buf[0] &amp; SEP ? SEPARATE : 0);   /* separate I 4 D or not */ 6065</p>
      <p> 6066 /* Get text and data sizes. */</p>
      <p> 6067 *text_bytes = (vir_bytes) buf[TEXTB]; /* text size in bytes */</p>
      <p> 6068 *data_bytes = (vir_bytes) buf[DATAB]; /* data size in bytes */</p>
      <p> 6069 if (*ft .'= SEPARATE) {</p>
      <p> 6070 /* If I 4 D space is not separated, it is all considered data. Text=0 */</p>
      <p> 6071 *data_bytes += *text_bytes;</p>
      <p> 6072 *text_bytes = 0;</p>
      <p> 6073 } 6074</p>
      <p> 6075 /* Get bss and total sizes. */</p>
      <p> 6076 #bss_bytes = (vir_bytes) buf[BSSB];     /* bss size in bytes */</p>
      <p> 6077 *tot_bytes = buf[T0TB]; /* total bytes to allocate for program  */</p>
      <p> 6078 if (*tot_bytes == 0) return(ENOEXEC); 6079</p>
      <p> 6080 /* Check to see if segment sizes are feasible. */</p>
      <p> 6081 tc = (»text_bytes + CLICK_SHIFT - 1) » CLICK_SHIFT;</p>
      <p> 6082 dc = (»data_bytes + *bss_bytes + CLICK_SHIFT - 1) » CI_ICK_SHIFT;</p>
      <p> 6083 tote = (*tot_bytes + CLICK_SIZE - 1) » CLICK_SHIFT;</p>
      <p> 6084 if (dc &gt;= tote) return(ENOEXEC); /* stack must be at least 1 click */</p>
      <p> 6085 dvir = (*ft == SEPARATE ? 0 : tc);</p>
      <p> 6086 s_vir = dvir + (tote - sc);</p>
      <p> 6087 m = size_ok(#ft, tc, dc, sc, dvir, s_vir);</p>
      <p> 6088 ct = buf[l] &amp; BYTE; /* header length */</p>
      <p> 6089 if (ct &gt; HDR_SIZE) read(fd, buf, ct - HDR_SIZE); /* skip unused hdr */</p>
      <p> 6090 return(m);</p>
      <p> 6091 }</p>
      <p> 6095        * new_mem *</p>
      <p> 6097 PRIVATE int new_mem(text_bytes, data_bytes, bss_bytes,stk_bytes,tot_bytes,bf,zs)</p>
      <p> 6098 vir_bytes text_bytes; /* text segment size in bytes */</p>
      <p> 6099 vir_bytes data_bytes; /* size of initialized data in bytes ♦/</p>
      <p> 556 File: mm/exec.c MINIX SOURCE CODE</p>
      <p> 6100 vir_bytes bss_bytes; /* size of bss in bytes */</p>
      <p> 6101 vir_bytes stk_bytes; /* size of initial stack segment in bytes */</p>
      <p> 6102 phys_bytes tot_bytes; /# total memory to allocate, including gap */</p>
      <p> 6103 char bf[ZER0BUF_SIZE]; /* buffer to use for zeroing data segment */</p>
      <p> 6104 int zs; /* true size of 'bf */</p>
      <p> 6105 {</p>
      <p> 6106 /* Allocate new memory and release the old memory.   Change the map and report</p>
      <p> 6107 * the new map to the kernel.    Zero the new core image's bss, gap and stack.</p>
      <p> 6108 */ 6109</p>
      <p> 6110 register struct mproc #rmp;</p>
      <p> 6111 char #rzp;</p>
      <p> 6112 vir_bytes vzb;</p>
      <p> 6113 vir_clicks text_clicks, data_clicks, gap_clicks, stack_clicks, tot_clicks;</p>
      <p> 6114 phys_clicks new_base, old_clicks;</p>
      <p> 6115 phys_bytes bytes, base, count, bss_offset;</p>
      <p> 6116 extern phys_clicks alloc_mem();</p>
      <p> 6117 extern phys_clicks max_hole(); 6118</p>
      <p> 6119 /* Acquire the new memory.   Each of the 4 parts: text, (data+bss), gap,</p>
      <p> 6120 * and stack occupies an integral number of clicks, starting at click</p>
      <p> 6121 * boundary.   The data and bss parts are run together with no space.</p>
      <p> 6122 #/ 6123</p>
      <p> 6124 text_clicks = (text_bytes + CLICK_SIZE - 1) » CLICK.SHIFT;</p>
      <p> 6125 data-clicks = (data_bytes + bss_bytes + CLICK_SIZE - 1) » CLICK_SHIFT;</p>
      <p> 6126 stack_clicks = (stk_bytes + CLICK_SIZE - 1) » CLICK_SHIFT;</p>
      <p> 6127 tot_clicks = (tot_bytes + CLICK_SIZE - 1) » CLICK_SHIFT;</p>
      <p> 6128 gap_clicks = tot_clicks - data_clicks - stack_clicks;</p>
      <p> 6129 if ( (int) gap_clicks &lt; 0) return(ENOMEM); 6130</p>
      <p> 6131 /* Check to see if there is a hole big enough.    If so, we can risk first</p>
      <p> 6132 * releasing the old core image before allocating the new one, since we</p>
      <p> 6133 * know it will succeed.   If there is not enough, return failure.</p>
      <p> 6134 */</p>
      <p> 6135 if (text_clicks + tot_clicks &gt; max_hole()) return(EAGAIN); 6136</p>
      <p> 6137 /* There is enough memory for the new core image.   Release the old one. */</p>
      <p> 6138 rmp = mp;</p>
      <p> 6139 old_clicks = (phys_clicks) rmp-&gt;mp_seg[S].mem_vir + rmp-&gt;mp_seg[S].mem_len;</p>
      <p> 6140 if (rmp-&gt;mp_flags &amp; SEPARATE) old_clicks += ;rmp-&gt;mp_seg[T] .mem_len;</p>
      <p> 6141 free_ntem(rmp-&gt;mp_seg[T] .men_phys, old_clicks); /* free the memory */ 6142</p>
      <p> 6143 /* We have now passed the point of no return.    The old core image has been</p>
      <p> 6144 * forever lost.    The call must go through now.    Set up and report new map.</p>
      <p> 6145 */</p>
      <p> 6146 new_base = alloc_mem(text_clicks + tot_clicks); /» new core image */</p>
      <p> 6147 if (new_base == N0_MEM) panicC'MM hole list is inconsistent", NCLNUM);</p>
      <p> 6148 rmp-&gt;mp_seg[T].mem_vir = 0;</p>
      <p> 6149 rmp-&gt;mp_seg[T].mem_len = text_clicks;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/exec.c</p>
      <p> 557</p>
      <p> 6150 rmp-&gt;mp_seg[T].mem_phys</p>
      <p> 6151 rmp-&gt;mp_seg[D].mem_vir</p>
      <p> 6152 rmp-&gt;mp_seg[D].mem_len</p>
      <p> 6153 rmp-&gt;mp_seg[D].mem_phys</p>
      <p> 6154 rmp-&gt;mp_seg[S],mem_vir</p>
      <p> 6155 rmp-&gt;mp_seg[S],mem_len</p>
      <p> 6156 rmp-&gt;mp_seg[S],mem_phys</p>
      <p> 6157 sys_newmap(wha, rmp-&gt;mp 6158</p>
      <p> 6159 /* Zero the bss, gap, and stack segment. Start just above text. */</p>
      <p> 6160 for (rzp = &amp;bf[0]; rzp &lt; &amp;bf[zs]; rzp++) *rzp  -  0;      /* clear buffer */</p>
      <p> 6161 bytes = (phys_bytes) (data_clicks + gap_clicks + stack_clicks) &lt;&lt; CLICK_SHIFT;</p>
      <p> 6162 vzb = (vir_bytes) bf;</p>
      <p> 6163 base  -  (long) rmp-&gt;mp_seg[T].mem_phys + rmp-&gt;mp_seg[T].mem_len;</p>
      <p> 6164 base = base « CLICK_SHIFT;</p>
      <p> 6165 bss_offset = (data_bytes » CLICK_SHIFT) « CLICK_SHIFT;</p>
      <p> 6166 base += bss_offset;</p>
      <p> 6167 bytes -= bss_offset; 6168</p>
      <p> 6169 while (bytes &gt; 0) {</p>
      <p> 6170 count = (long) MIN(bytes, (phys_bytes) zs)j</p>
      <p> 6171 if (mem_copy(MM_PR0C_NR, D, (long) vzb, ABS, 0, base, count) != OK)</p>
      <p> 6172 panic("new_mem can't zero", N0_NUM);</p>
      <p> 6173 base += count;</p>
      <p> 6174 bytes -= count;</p>
      <p> 6175 }</p>
      <p> 6176 return(OK);</p>
      <p> 6177 }</p>
      <p> = new_base; = 0;</p>
      <p> = data_clicks;</p>
      <p> = new_base + text_clicks; = rmp-&gt;mp_seg[D].mem_vir + data_clicks + gap_clicks; = stack_clicks;</p>
      <p> = rmp-&gt;mp_seg[D].mem_phys + data_clicks + gap_clicks; _seg); /♦ report new map to the kernel */</p>
      <p> 6180 /*===============:======================== = r:==:===^================== = ======*</p>
      <p> 6181 * patch_ptr *</p>
      <p> 6182 » = = : =  : :==: =  :: :":==:= ::::: : ::::: : :: : :::: ~: =  : : = : ::::::::r::::::: ; r::::::: ; :: ,/</p>
      <p> 6183 PRIVATE patch_ptr(stack, base)</p>
      <p> 6184 char stack[MAX_ISTACK_BYTES];     /* pointer to stack image within MM */</p>
      <p> 6185 vir_bytes base; /* virtual address of stack base inside user */</p>
      <p> 6186 {</p>
      <p> 6187 /* When doing an exec(name, argv, envp) call, the user builds up a stack</p>
      <p> 6188 # image with arg and env pointers relative to the start of the stack. Now</p>
      <p> 6189 * these pointers must be relocated, since the stack is not positioned at</p>
      <p> 6190 * address 0 in the user's address space.</p>
      <p> 6191 */ 6192</p>
      <p> 6193 char ##ap, flag;</p>
      <p> 6194 vir_bytes v; 6195</p>
      <p> 6196 flag = 0;</p>
      <p> 6197 ap = (char **) stack;</p>
      <p> 6198 ap++;</p>
      <p> 6199 while (flag &lt; 2) {</p>
      <p> /# counts number of 0-pointers seen */ /* points initially to 'nargs' */ /# now points to argv[0] #/</p>
      <p> 558 File: mm/exec.c MINIX SOURCE CODE</p>
      <p> 6200 if (ap &gt;= (char **) &amp;stack[MAX_ISTACK_BYTES]) return;     /* too bad */</p>
      <p> 6201 if (#ap != Nil PTR) {</p>
      <p> 6202 v = (vir_bytes) *ap;      /# v is relative pointer */</p>
      <p> 6203 v += base; /* relocate it */</p>
      <p> 6204 *ap = (char *) v; /* put it back */</p>
      <p> 6205 } else {</p>
      <p> 6206 flag++;</p>
      <p> 6207 }</p>
      <p> 6208 ap++;</p>
      <p> 6209 }</p>
      <p> 6210 }</p>
      <p> 6213 /»===========================================================================*</p>
      <p> 6214 * load_seg *</p>
      <p> 6215 #===========================================================================#/</p>
      <p> 6216 PRIVATE load_seg(fd, seg, seg_bytes)</p>
      <p> 6217 int fd; /* file descriptor to read from */</p>
      <p> 6218 int seg; /# T or D */</p>
      <p> 6219 vir_bytes seg_bytes; /♦ how big is the segment */</p>
      <p> 6220 {</p>
      <p> 6221 /* Read in text or data from the exec file and copy to the new core image.</p>
      <p> 6222 * This procedure is a little bit tricky.   The logical way to load a segment</p>
      <p> 6223 * would be to read it block by block and copy each block to the user space</p>
      <p> 6224 * one at a time.    This is too slow, so we do something dirty here, namely</p>
      <p> 6225 * send the user space and virtual address to the file system in the upper</p>
      <p> 6226 * 10 bits of the file descriptor, and pass it the user virtual address</p>
      <p> 6227 * instead of a MM address.   The file system copies the whole segment</p>
      <p> 6228 * directly to user space, bypassing MM completely.</p>
      <p> 6229 */ 6230</p>
      <p> 6231 int new_fd, bytes;</p>
      <p> 6232 char *ubuf_ptr; 6233</p>
      <p> 6234 if (seg_bytes == 0) return;     /♦ text size for combined I 4 D is 0 */</p>
      <p> 6235 new_fd = (who « 8) |  (seg « 6) | fd;</p>
      <p> 6236 ubuf_ptr = (char *) (mp-&gt;mp_seg[seg].mem_vir « CLICK_SHIFT);</p>
      <p> 6237 bytes = (int) seg_bytes;</p>
      <p> 6238 read(new_fd, ubuf_ptr, bytes);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/break.c</p>
      <p> 559</p>
      <p> 6250 /# The MINIX model of memory allocation reserves a fixed amount of memory for</p>
      <p> 6251 * the combined text, data, and stack segments.   The amount used for a child</p>
      <p> 6252 * process created by FORK is the same as the parent had.    If the child does</p>
      <p> 6253 * an EXEC later, the new size is taken from the header of the file EXEC'ed.</p>
      <p> 6254 *</p>
      <p> 6255 * The layout in memory consists of the text segment, followed by the data</p>
      <p> 6256 * segment, followed by a gap (unused memory), followed by the stack segment.</p>
      <p> 6257 * The data segment grows upward and the stack grows downward, so each can</p>
      <p> 6258 * take memory from the gap.    If they meet, the process must be killed. The</p>
      <p> 6259 * procedures in this file deal with the growth of the data and stack segments.</p>
      <p> 6260 *</p>
      <p> 6261 * The entry points into this file are:</p>
      <p> 6262 *     do_brk: BRK/SBRK system calls to grow or shrink the data segment</p>
      <p> 6263 *     adjust: see if a proposed segment adjustment is allowed</p>
      <p> 6264 *     size_ok:        see if the segment sizes are feasible</p>
      <p> 6265 *     stack_fault: grow the stack segment</p>
      <p> 6266 */ 6267</p>
      <p> 6268 ^include "../h/const.h"</p>
      <p> 6269 ^include "../h/type.h"</p>
      <p> 6270 ^include "../h/error.h"</p>
      <p> 6271 ^include "../h/signal.h"</p>
      <p> 6272 ^include "const.h"</p>
      <p> 6273 ^include "glo.h"</p>
      <p> 6274 ^include "mproc.h"</p>
      <p> 6275 ^/include "param.h" 6276</p>
      <p> 6277 ^define DATA_CHANGED 1      /* flag value when data segment size changed */</p>
      <p> 6278 #define STACK_CHANGED 2      /* flag value when stack size changed */ 6279</p>
      <p> 6280 /»:= : ======:========= ; ==:===:== : : : ==== : r;:=: : : ::;::: :;; :: :; :=: ; ::: :: ::::::::: .</p>
      <p> 6281 * do_brk *</p>
      <p> 6282 *= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = === = = =: = === = ==♦/</p>
      <p> 6283 PUBLIC int do_brk()</p>
      <p> 6284 {</p>
      <p> 6285 /* Perform the brk(addr) system call.</p>
      <p> 6286 *</p>
      <p> 6287 * The call is complicated by the fact that on some machines (e.g., 8088),</p>
      <p> 6288 * the stack pointer can grow beyond the base of the stack segment without</p>
      <p> 6289 * anybody noticing it.       For a file not using separate I &amp; D space,</p>
      <p> 6290 * the parameter, 'addr' is the total size, text + data.    For a file using</p>
      <p> 6291 * separate text and data spaces, it is just the data size. Files using</p>
      <p> 6292 * separate I &amp; D space have the SEPARATE bit in mp_flags set.</p>
      <p> 6293 */ 6294</p>
      <p> 6295 register struct mproc *rmp;</p>
      <p> 6296 int r;</p>
      <p> 6297 vir_bytes v, new_sp;</p>
      <p> 6298 vir_clicks new_clicks; 6299</p>
      <p> 560 File: mm/break.c MINIX SOURCE CODE</p>
      <p> 6300 rmp = mp;</p>
      <p> 6301 v = (vir_bytes) addr; /* 'addr' is the new data segment size */</p>
      <p> 6302 new_clicks = (vir_clicks) ( ((long) v + CLICK_SIZE - 1) » CLICK_SHIFT);</p>
      <p> 6303 sys_getsp(who, 4new_sp); /* ask kernel for current sp value */</p>
      <p> 6304 r = adjust(rmp, new_clicks, new_sp);</p>
      <p> 6305 res_ptr = (r == OK ? addr : (char *) -1);</p>
      <p> 6306 return(r); /# return new size or -1 */</p>
      <p> 6307 }</p>
      <p> 6310 /♦ = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = : = = = =: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 6311 * adjust *</p>
      <p> 6313 PUBLIC int adjust(rmp, data_clicks, sp)</p>
      <p> 6314 register struct mproc #rmp; /* whose memory is being adjusted? #/</p>
      <p> 6315 vir_clicks data_clicks; /* how big is data segment to become? */</p>
      <p> 6316 vir_bytes sp; /* new value of sp */</p>
      <p> 6317 {</p>
      <p> 6318 /* 5ee if data and stack segments can coexist, adjusting them if need be.</p>
      <p> 6319 # Memory is never allocated or freed.   Instead it is added or removed from the</p>
      <p> 6320 * gap between data segment and stack segment.    If the gap size becomes</p>
      <p> 6321 * negative, the adjustment of data or stack fails and EN0MEM is returned.</p>
      <p> 6322 */ 6323</p>
      <p> 6324 register struct mem_map *mem_sp, #mem_dp;</p>
      <p> 6325 vir_clicks sp_click, gap_base, lower, old_clicks;</p>
      <p> 6326 int changed, r, ft;</p>
      <p> 6327 long base_of_stack, delta;       /* longs avoid certain problems */ 6328</p>
      <p> 6329 mem_dp = &amp;rmp-&gt;mp_seg[D]; /# pointer to data segment map #/</p>
      <p> 6330 mem_sp = 4rmp-&gt;mp_seg[S]; /* pointer to stack segment map */</p>
      <p> 6331 changed = 0; /# set when either segment changed */ 6332</p>
      <p> 6333 /* See if stack size has gone negative (i.e., sp too close to OxFFFF...) */</p>
      <p> 6334 base_of_stack = (long) mem_sp-&gt;mem_vir + (long) mem_sp-&gt;mem_len;</p>
      <p> 6335 sp_click = sp &gt;&gt; CLICK_SHIFT; /# click containing sp */</p>
      <p> 6336 if (sp_click &gt;= base_of_stack) return(ENOMEM); /* sp too high */ 6337</p>
      <p> 6338 /* Compute size of gap between stack and data segments. */</p>
      <p> 6339 delta = (long) mem_sp-&gt;mem_vir - (long) sp_click;</p>
      <p> 6340 lower = (delta &gt; 0 ? sp_click : mem_sp-&gt;mem_vir);</p>
      <p> 6341 gap_base = mem_dp-&gt;mem_vir + data_clicks;</p>
      <p> 6342 if (lower &lt; gap_base) return(EN0MEM); /* data and stack collided #/ 6343</p>
      <p> 6344 /» Update data length (but not data orgin) on behalf of brk() system call. */</p>
      <p> 6345 old_clicks = mem_dp-&gt;mem_len;</p>
      <p> 6346 if (data_clicks != mem_dp-&gt;mem_len) {</p>
      <p> 6347 mem_dp-&gt;mem_len = data_clicks;</p>
      <p> 6348 changed |= DATA_CHANGED;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/break.c</p>
      <p> 561</p>
      <p> 6350</p>
      <p> 6351 /* Update stack length and origin due to change in stack pointer. */</p>
      <p> 6352 if (delta &gt; 0) {</p>
      <p> 6353 mem_sp-&gt;mem_vir -= delta;</p>
      <p> 6354 mem_sp-&gt;mem_phys -= delta;</p>
      <p> 6355 mem_sp-&gt;mem_len += delta;</p>
      <p> 6356 changed |= STACK_CHANGED;</p>
      <p> 6357 } 6358</p>
      <p> 6359 /* Do the new data and stack segment sizes fit in the address space? */</p>
      <p> 6360 ft = (rmp-&gt;mp_flags &amp; SEPARATE);</p>
      <p> 6361 r = size_ok(ft, rmp-&gt;mp_seg[T].mero_len, rmp-&gt;mp_seg[D].menulen,</p>
      <p> 6362 rmp-&gt;mp_seg[S].mem_len, rmp-&gt;mp_seg[D].mem_vir, rmp-&gt;mp_seg[S].mem_vir);</p>
      <p> 6363 if (r == OK) {</p>
      <p> 6364 if (changed) sys_newmap(rmp - mproc, rmp-&gt;mp_seg);</p>
      <p> 6365 return(OK);</p>
      <p> 6366 } 6367</p>
      <p> 6368 /* New sizes don't fit or require too many page/segment registers. Restore.*/</p>
      <p> 6369 if (changed &amp; DATA_CHANGED) mem_dp-&gt;mem_len = old_clicks;</p>
      <p> 6370 if (changed 4 STACK_CHANGED) {</p>
      <p> 6371 mem_sp-&gt;mem_vir += delta;</p>
      <p> 6372 mem_sp-&gt;mem_phys += delta;</p>
      <p> 6373 mem_sp-&gt;mem_len -= delta;</p>
      <p> 6374 }</p>
      <p> 6375 return(ENOMEM);</p>
      <p> 6376 }</p>
      <p> 6379 /*= = = = = = = = = =: = = =: = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = *</p>
      <p> 6380 ♦ size_ok *</p>
      <p> 6381 t:: = = :: = r= = =  : ::i":r:" = " : ==:: = = ::=: : ==r = =:::: = :: = = = = : : := = ==: = = = = = := = =::: = =»/</p>
      <p> 6382 PUBLIC int size_ok(file_type, tc, dc, sc, dvir, s_vir)</p>
      <p> 6383 int file_type; /* SEPARATE or 0 */</p>
      <p> 6384 vir_clicks tc; /* text size in clicks */</p>
      <p> 6385 vir_clicks dc; /* data size in clicks */</p>
      <p> 6386 vir_clicks sc; /* stack size in clicks */</p>
      <p> 6387 vir_clicks dvir; /* virtual address for start of data seg #/</p>
      <p> 6388 vir_clicks s_vir; /* virtual address for start of stack seg */</p>
      <p> 6389 {</p>
      <p> 6390 /# Check to see if the sizes are feasible and enough segmentation registers</p>
      <p> 6391 * exist.    On a machine with eight 8K pages, text, data, stack sizes of</p>
      <p> 6392 * (32K, 16K, 16K) will fit, but (33K, 17K, 13K) will not, even though the</p>
      <p> 6393 * former is bigger (64K) than the latter (63K).    Even on the 8088 this test</p>
      <p> 6394 # is needed, since the data and stack may not exceed 4096 clicks.</p>
      <p> 6395 */ 6396</p>
      <p> 6397 int pt, pd, ps;                         /* segment sizes in pages */ 6398</p>
      <p> 6399 pt = ( (tc « CLICK_SHIFT) + PAGE_SIZE - 1)/PAGE_SIZE;</p>
      <p> 562 File: mm/break.c MINIX SOURCE CODE</p>
      <p> 6400 pd = ( (dc « CLICK_SHIFT) + PAGE_SIZE - 1)/PAGE_SIZE;</p>
      <p> 6401 ps = ( (sc « CLICK_SHIFT) + PAGE_SIZE - 1)/PAGE_SIZE; 6402</p>
      <p> 6403 if (file_type == SEPARATE) {</p>
      <p> 6404 if (pt &gt; MAX_PAGES || pd + ps &gt; MAX_PAGES) return(ENOMEM);</p>
      <p> 6405 } else {</p>
      <p> 6406 if (pt + pd + ps &gt; MAX.PAGES) return(ENOMEM);</p>
      <p> 6407 } 6408</p>
      <p> 6409 if (dvir + dc &gt; s_vir) return(ENOMEM);</p>
      <p> 6410</p>
      <p> 6411 return(OK);</p>
      <p> 6412 }</p>
      <p> 6416 * stack_fault *</p>
      <p> 6417 »:::::::::::::::::::::::::: = "::::::::=:::::::::::::::::::;=:::::=:::::::==:,/</p>
      <p> 6418 PUBLIC stack_fault (procnr)</p>
      <p> 6419 int procnr; /♦ tells who got the stack fault */</p>
      <p> 6420 {</p>
      <p> 6421 /* Handle a stack fault by growing the stack segment until sp is inside of it.</p>
      <p> 6422 * If this is impossible because data segment is in the way, kill the process.</p>
      <p> 6423 */ 6424</p>
      <p> 6425 register struct mproc *rmp;</p>
      <p> 6426 int r;</p>
      <p> 6427 vir_bytes new_sp; 6428</p>
      <p> 6429 rmp = &amp;mproc[procnr] j</p>
      <p> 6430 sys_getsp(rmp - mproc, &amp;new_sp);</p>
      <p> 6431 r = adjust(rmp, rmp-&gt;mp_seg[D].mem_len, new_sp);</p>
      <p> 6432 if (r == OK) return; 6433</p>
      <p> 6434 /* Stack has bumped into data segment.    Kill the process.  */</p>
      <p> 6435 rmp-&gt;mp_catch = 0; /* don't catch this signal */</p>
      <p> 6436 sig_proc(rmp, SIGSEGV); /# terminate process */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/signal.c</p>
      <p> 563</p>
      <p> 6450 6451 6452 6453 6454 6455 6456 6457 6458 6459 6460 6461 6462 6463 6464 6465 6466 6467 6468 6469 6470 6471 6472 6473 6474 6475 6476 6477 6478 6479 6480 6481 6482 6483 6484 6485 6486 6487 6488 6489 6490 6491 6492 6493 6494 6495 6496 6497 6498 6499</p>
      <p> /* This file handles signals, which are asynchronous events and are generally</p>
      <p> * a messy and unpleasant business.    Signals can be generated by the KILL</p>
      <p> * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).</p>
      <p> * In all cases control eventually passes to check_sig() to see which processes</p>
      <p> * can be signalled.    The actual signalling is done by sig_proc(). #</p>
      <p> * The entry points into this file are:</p>
      <p> * do_signal: perform the SIGNAL system call</p>
      <p> * do_kill:     perform the KILL system call</p>
      <p> * do_ksig:     accept a signal originating in the kernel (e.g., SIGINT)</p>
      <p> * sig_proc:   interrupt or terminate a signalled process</p>
      <p> * do_alarm:   perform the ALARM system call by calling set_alarm()</p>
      <p> * set_alarm: tell the clock task to start or stop a timer</p>
      <p> * do_pause:   perform the PAUSE system call unpause:     check to see if process is suspended on anything</p>
      <p> */</p>
      <p> ^include //include //include if/include ^include /(include //include ^include //include //include //include</p>
      <p> "../h/const.h" "../h/type.h" "../h/callnr.h" "../h/com.h" "../h/error.h" "../h/signal.h" "../h/stat.h" "const.h" "glo.h" "mproc.h" "param.h"</p>
      <p> //define DUMP_SIZE //define C0RE_M0DE //define DUMPED</p>
      <p> PRIVATE message m_sig;</p>
      <p> 256      /* buffer size for core dumps */ 0777      /* mode to use on core image files */ 0200      /* bit set in status when core dumped */</p>
      <p> do_signal</p>
      <p> =»/</p>
      <p> PUBLIC int do_signal() {</p>
      <p> /* Perform the signaKsig, func) call by setting bits to indicate that a signal * is to be caught or ignored. */</p>
      <p> int mask;</p>
      <p> if (sig &lt; 1 || sig &gt; NR_SIGS) return(EINVAL);</p>
      <p> if (sig == SIGKILL) return(OK); /* SIGKILL may not ignored/caught */</p>
      <p> mask = 1 &lt;&lt; (sig - 1); /* singleton set with 'sig' bit on */</p>
      <p> 564 File: mm/signal.c MINIX SOURCE CODE</p>
      <p> 6500 /* All this func does is set the bit maps for subsequent sig processing. */</p>
      <p> 6501 if (func == SIG_IGN) {</p>
      <p> 6502 mp-&gt;mp_ignore |= mask;</p>
      <p> 6503 mp-&gt;mp_catch "mask;</p>
      <p> 6504 } else if (func == SIG_DFL) {</p>
      <p> 6505 mp-&gt;mp_ignore &amp;= "mask;</p>
      <p> 6506 mp-&gt;mp_catch &amp;= "mask;</p>
      <p> 6507 } else {</p>
      <p> 6508 mp-&gt;mp_ignore &amp;= "mask;</p>
      <p> 6509 mp-&gt;mp_catch |= mask;</p>
      <p> 6510 mp-&gt;mp_func = func;</p>
      <p> 6511 }</p>
      <p> 6512 return(OK);</p>
      <p> 6513 }</p>
      <p> 6516 /* = = = = 3 = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = - = = == = =  =   =   =  = = z = r  =   =   =   =   ::  =  =  = = = =  =   =   =  = = rr  =  3  =  *</p>
      <p> 6517 * do_kill *</p>
      <p> 6518 *===========================================================================*/</p>
      <p> 6519 PUBLIC int do_kill()</p>
      <p> 6520 {</p>
      <p> 6521 /* Perform the kilKpid, kill_sig) system call. */ 6522</p>
      <p> 6523 return check_sig(pid, kill_sig, mp-&gt;mp_effuid);</p>
      <p> 6524 }</p>
      <p> 6527 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = =: = = = = = = = = = = *</p>
      <p> 6528 * do_ksig *</p>
      <p> 6529 = - = = = = " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 6530 PUBLIC int do_ksig()</p>
      <p> 6531 {</p>
      <p> 6532 /* Certain signals, such as segmentation violations and DEL, originate in the</p>
      <p> 6533 * kernel.   When the kernel detects such signals, it sets bits in a bit map.</p>
      <p> 6534 * As soon as MM is awaiting new work, the kernel sends MM a message containinc</p>
      <p> 6535 * the process slot and bit map.    That message comes here.    The File System</p>
      <p> 6536 * also uses this mechanism to signal writing on broken pipes (SIGPIPE).</p>
      <p> 6537 */ 6538</p>
      <p> 6539 register struct mproc #rmp;</p>
      <p> 6540 int i, proc_id, proc_nr, id;</p>
      <p> 6541 unshort sig_map; /* bits 0-15 for sigs 1 - 16 */ 6542</p>
      <p> 6543 /* Only kernel and F5 may make this call. */</p>
      <p> 6544 if (who != HARDWARE &amp;&amp; who != FS_PR0C_NR) return(EPERM); 6545</p>
      <p> 6546 proc_nr = mm_in.PR0C1;</p>
      <p> 6547 rmp = &amp;mproc[proc_nr];</p>
      <p> 6548 if (  (rmp-&gt;mp_flags &amp; IN_USE) == 0 ||   (rmp-&gt;mp_flags &amp; HANGING)  ) return(OK)</p>
      <p> 6549 proc_id = rmp-&gt;mp_pid;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/signal.c</p>
      <p> 565</p>
      <p> 6550 sig_map = (unshort) mm_in.SIG_MAP;</p>
      <p> 6551 mp = &amp;mproc[0]; /# pretend kernel signals are from MM */ 6552</p>
      <p> 6553 /* Stack faults are passed from kernel to MM as pseudo-signal 16. */</p>
      <p> 6554 if (sigjnap == 1 « (STACK_FAULT - 1)) {</p>
      <p> 6555 stack_fault(proc_nr);</p>
      <p> 6556 return(OK);</p>
      <p> 6557 } 6558</p>
      <p> 6559 /# Check each bit in turn to see if a signal is to be sent. Unlike</p>
      <p> 6560 * kill(), the kernel may collect several unrelated signals for a process</p>
      <p> 6561 * and pass them to MM in one blow.    Thus loop on the bit map. For SIGINT</p>
      <p> 6562 * and SIGQUIT, use proc_id 0, since multiple processes may have to signaled.</p>
      <p> 6563 */</p>
      <p> 6564 for (i = 0; i &lt; NR_SIGS; i++) {</p>
      <p> 6565 id = (i+1 == SIGINT  ||  i+1 == SIGQUIT ? 0 : proc_id);</p>
      <p> 6566 if ( (sig_map » i) &amp; 1) check_sig(id, i + 1, SUPERJJSER);</p>
      <p> 6567 } 6568</p>
      <p> 6569 dont_reply = TRUE; /* don't reply to the kernel */</p>
      <p> 6570 return(OK);</p>
      <p> 6571 }</p>
      <p> 6574 /*==============================================-============================♦</p>
      <p> 6575 * check_sig *</p>
      <p> 6576 *===========================================================================*/</p>
      <p> 6577 PRIVATE int check_sig(proc_id, sig_nr, send_uid)</p>
      <p> 6578 int proc_id; /# pid of process to signal, or 0 or -1 */</p>
      <p> 6579 int sig_nr; /* which signal to send (1-16) */</p>
      <p> 6580 uid send_uid; /* identity of process sending the signal */</p>
      <p> 6581 {</p>
      <p> 6582  /*  Check to see if it is possible to send a signal.    The signal may have to be</p>
      <p> 6583 * sent to a group of processes.    This routine is invoked by the KILL system</p>
      <p> 6584 * call, and also when the kernel catches a DEL or other signal. SIGALRM too.</p>
      <p> 6585 */ 6586</p>
      <p> 6587 register struct mproc *rmp;</p>
      <p> 6588 int count, send_sig;</p>
      <p> 6589 unshort mask;</p>
      <p> 6590 extern unshort core_bits; 6591</p>
      <p> 6592 if (sig_nr &lt; 1 || sig_nr &gt; NR_SIGS) return(EINVAL);</p>
      <p> 6593 count = 0; /* count  ft  of signals sent */</p>
      <p> 6594 mask = 1 « (sig_nr - 1); 6595</p>
      <p> 6596 /* Search the proc table for processes to signal.    Several tests are made:</p>
      <p> 6597 #      - if proc's uid != sender's, and sender is not superuser, don't signal</p>
      <p> 6598 *      - if specific process requested (i.e., 'procpid' &gt; 0), check for match</p>
      <p> 6599 *      - if a process has already exited, it can't receive signals</p>
      <p> 566 File: mm/signal.c MINIX SOURCE CODE</p>
      <p> 6600 #      - if 'proc_id' is 0 signal everyone in same process group except caller</p>
      <p> 6601 */</p>
      <p> 6602 for (rmp = &amp;mproc[INIT_PR0C_NR + 1]; rmp &lt; &amp;mproc[NR_PR0CS]; rmp++ ) {</p>
      <p> 6603 if ( (rmp-&gt;mp_flags &amp; INJJSE) == 0) continue;</p>
      <p> 6604 send_sig = TRUE; /* if it's FALSE at end of loop, don't signal *</p>
      <p> 6605 if (send_uid != rmp-&gt;mp_effuid &amp;&amp; send_uid != SUPER_USER)send_sig=FALSE</p>
      <p> 6606 if (proc_id &gt; 0 &amp;&amp; proc_id != rmp-&gt;mp_pid) send_sig = FALSE;</p>
      <p> 6607 if (rmp-&gt;mp_flags &amp; HANGING) send_sig = FALSE;     /*don't wake the dead*</p>
      <p> 6608 if (proc_id == 0 &amp;&amp; mp-&gt;mp_procgrp != rmp-&gt;mp_procgrp) send_sig = FALSE</p>
      <p> 6609 if (send_uid = = SUPERJJSER &amp;&amp; proc_icl == -1) send_sig = TRUE; 6610</p>
      <p> 6611 /* SIGALARM is a little special.   When a process exits, a clock signal</p>
      <p> 6612 * can arrive just as the timer is being turned off.   Also, turn off</p>
      <p> 6613 * ALARM_0N bit when timer goes off to keep it accurate.</p>
      <p> 6614 */</p>
      <p> 6615 if (sig_nr == SIGALRM) {</p>
      <p> 6616 if ( (rmp-&gt;mp_flags &amp; ALARM_0N)      0) continue;</p>
      <p> 6617 rmp-&gt;mp_flags &amp;= ~ALARM_0N;</p>
      <p> 6618 } 6619</p>
      <p> 6620 if (send_sig == FALSE || rmp-&gt;mp_ignore &amp; mask) continue; 6621</p>
      <p> 6622 /* If process is hanging on PAUSE, WAIT, tty, pipe, etc. release it. */</p>
      <p> 6623 unpause(rmp - mproc);     /* check to see if process is paused */</p>
      <p> 6624 count++; 6625</p>
      <p> 6626 /* Send the signal or kill the process, possibly with core dump. */</p>
      <p> 6627 sig_proc(rmp, sig_nr);</p>
      <p> 6628 if (proc_id &gt; 0) break; /* only one process being signalled */</p>
      <p> 6629 } 6630</p>
      <p> 6631 /* If the calling process has killed itself, don't reply. */</p>
      <p> 6632 if ((mp-&gt;mp_flags &amp; INJJSE) == 0 ||  (mp-&gt;mp_flags &amp; HANGING))dont_reply =TRUE</p>
      <p> 6633 return(count &gt; 0 ? OK : ESRCH);</p>
      <p> 6634 }</p>
      <p> 6637 /*===========================================================================*</p>
      <p> 6638 # sig_proc *</p>
      <p> 6639 = = = = = = = = = = = = = = =     = = = = =</p>
      <p> 6640 PUBLIC sig_proc(rmp, sig_nr)</p>
      <p> 6641 register struct mproc *rmp; /* pointer to the process to be signalled ♦/</p>
      <p> 6642 int sig_nr; /* signal to send to process (1-16) */</p>
      <p> 6643 {</p>
      <p> 6644 /* Send a signal to a process.    Check to see if the signal is to be caught.</p>
      <p> 6645 * If so, the pc, psw, and signal number are to be pushed onto the process'</p>
      <p> 6646 * stack.    If the stack cannot grow or the signal is not to be caught, kill</p>
      <p> 6647 * the process.</p>
      <p> 6648 */ 6649</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/signal.c</p>
      <p> 567</p>
      <p> 6650 unshort mask;</p>
      <p> 6651 int core_file;</p>
      <p> 6652 vir_bytes new_sp;</p>
      <p> 6653 extern unshort core_bits; 6654</p>
      <p> 6655 if ( (rmp-&gt;mp_flags &amp; INLUSE) == 0) return;     /* if already dead forget it */</p>
      <p> 6656 mask = 1 &lt;&lt; (sig_nr - 1);</p>
      <p> 6657 if (rmp-&gt;mp_catch &amp; mask) {</p>
      <p> 6658 /# Signal should be caught. */</p>
      <p> 6659 rmp-&gt;mp_catch &amp;= "mask; /* disable further signals */</p>
      <p> 6660 sys_getsp(rmp - mproc, &amp;new_sp);</p>
      <p> 6661 new_sp - = SIG_PUSH_BYTES;</p>
      <p> 6662 if (adjust(rmp, rmp-&gt;mp_seg[D].mem_len, new_sp) == OK) {</p>
      <p> 6663 sys_sig(rmp - mproc, sig_nr, rmp-&gt;mp_func);</p>
      <p> 6664 return; /* successful signal */</p>
      <p> 6665 }</p>
      <p> 6666 } 6667</p>
      <p> 6668 /* Signal should not or cannot be caught.    Take default action. */</p>
      <p> 6669 core_file = ( core_bits &gt;&gt; (sig_nr - 1 )) &amp; 1;</p>
      <p> 6670 rmp-&gt;mp_sigstatus = (char) sig_nr;</p>
      <p> 6671 mm_exit(rmp, 0); /# terminate process */</p>
      <p> 6672 if (core_file) dump_core(rmp); /# dump core */</p>
      <p> 6673 }</p>
      <p> 6676 6677 6678 6679 6680 6681 6682 6683 6684 6685 6686 6687 6688 6689</p>
      <p> /# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = =  =  = = = = = = = = = = = = = = = = = = = = = = = = = = = :: = #</p>
      <p> * do_alarm *</p>
      <p> »============================================= == : == ==== ====== == ==== r == = ====== #/</p>
      <p> PUBLIC int do_alarm() {</p>
      <p> /# Perform the alarm(seconds) system call. */</p>
      <p> register int r; unsigned sec;</p>
      <p> sec = (unsigned) seconds; r = set_alarm(who, sec); return(r);</p>
      <p> }</p>
      <p> 6692</p>
      <p> 6693 * set_alarm *</p>
      <p> 6694 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = r = = = =  =  ^ = =  =  = = = = ; = ==: = = = = - = = = = = #/</p>
      <p> 6695 PUBLIC int set_alarm(proc_nr, sec)</p>
      <p> 6696 int proc_nr; /* process that wants the alarm */</p>
      <p> 6697 unsigned sec; /* how many seconds delay before the signal */</p>
      <p> 6698 {</p>
      <p> 6699 /* This routine is used by do_alarm() to set the alarm timer.    It is also used</p>
      <p> 568 File: mm/signal.c MINIX SOURCE CODE</p>
      <p> 6700 * to turn the timer off when a process exits with the timer still on.</p>
      <p> 6701 #/ 6702</p>
      <p> 6703 int remaining; 6704</p>
      <p> 6705 m_sig.m_type = SET_ALARM;</p>
      <p> 6706 m_sig.PR0C_NR = proc_nr;</p>
      <p> 6707 m_sig.DELTA_TICKS = HZ * sec;</p>
      <p> 6708 if (sec != 0)</p>
      <p> 6709 mproc[proc_nr].mp_flags |= ALARM_0N;       /* turn ALARM_0N bit on */</p>
      <p> 6710 else</p>
      <p> 6711 mproc[proc_nr].mp_flags &amp;= ~ALARM_0N;     /* turn ALARM_0N bit off */ 6712</p>
      <p> 6713 /* Tell the clock task to provide a signal message when the time comes. */</p>
      <p> 6714 if (sendrec(CL0CK, &amp;m_sig)  != OK) panicC'alarm er", N0_NUM);</p>
      <p> 6715 remaining = (int) m_sig.SEC0NDS_LEFT;</p>
      <p> 6716 return(remaining);</p>
      <p> 6717 }</p>
      <p> 6720 /*============================================= ============================== *</p>
      <p> 6721 * do_pause *</p>
      <p> 6722 =====;==== === ===== ============= */</p>
      <p> 6723 PUBLIC int do_pause()</p>
      <p> 6724 {</p>
      <p> 6725  /*  Perform the pause() system call.  */ 6726</p>
      <p> 6727 mp-&gt;mp_flags |= PAUSED; /* turn on PAUSE bit */</p>
      <p> 6728 dont_reply = TRUE;</p>
      <p> 6729 return(OK);</p>
      <p> 6730 }</p>
      <p> 6733 /* = = = = = = = = = = = = = = - = = = = = = = = = = = = = = = =  =  = = = = = = = = = = = = ::  =   =   =  = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   = :  =   =  -*</p>
      <p> 6734 * unpause *</p>
      <p> 6735 *= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =:  =  = = = = = = =  =  = = = = = :   =   =   =   ::  =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =  */</p>
      <p> 6736 PUBLIC unpause(pro)</p>
      <p> 6737 int pro; /* which process number */</p>
      <p> 6738 {</p>
      <p> 6739 /* A signal is to be sent to a process.    If that process is hanging on a</p>
      <p> 6740 * system call, the system call must be terminated with EINTR. Possible</p>
      <p> 6741 * calls are PAUSE, WAIT, READ and WRITE, the latter two for pipes and ttys.</p>
      <p> 6742 ♦ First check if the process is hanging on PAUSE or WAIT.    If not, tell FS,</p>
      <p> 6743 * so it can check for READs and WRITES from pipes, ttys and the like.</p>
      <p> 6744 */ 6745</p>
      <p> 6746 register struct mproc *rmp; 6747</p>
      <p> 6748 rmp = &amp;mproc[pro]; 6749</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/signal.c</p>
      <p> 569</p>
      <p> 6750 /* Check to see if process is hanging on a PAUSE call. ♦/</p>
      <p> 6751 if (rmp-&gt;mp_flags &amp; PAUSED) {</p>
      <p> 6752 rmp-&gt;mp_flags &amp; = "PAUSED; /* turn off PAUSED bit #/</p>
      <p> 6753 reply(pro, EINTR, 0, Nil PTR);</p>
      <p> 6754 return;</p>
      <p> 6755 } 6756</p>
      <p> 6757 /* Check to see if process is hanging on a WAIT call. */</p>
      <p> 6758 if (rmp-&gt;mp_flags &amp; WAITING) {</p>
      <p> 6759 rmp-&gt;mp_flags &amp;= ~ WAITING; /* turn off WAITING bit */</p>
      <p> 6760 reply(pro, EINTR, 0, Nil PTR);</p>
      <p> 6761 return;</p>
      <p> 6762 } 6763</p>
      <p> 6764 /* Process is not hanging on an MM call.    Ask FS to take a look. #/</p>
      <p> 6765 tell_fs(UNPAUSE, pro, 0, 0); 6766</p>
      <p> 6767 return;</p>
      <p> 6768 }</p>
      <p> 6771 /* = r = = = =: =  =   =  = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =  -  =   =   =   =  --  =  ---  =   =   =   ::   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =</p>
      <p> 6772 * dump_core</p>
      <p> 6773 *============================================r============================</p>
      <p> 6774 PRIVATE dump_core(rmp)</p>
      <p> 6775 register struct mproc *rmp; /* whose core is to be dumped #/</p>
      <p> 6776 {</p>
      <p> 6777 /* Make a core dump on the file "core", if possible. */ 6778</p>
      <p> 6779 struct stat s_buf, d_buf;</p>
      <p> 6780 char buf[DUMP_SIZE];</p>
      <p> 6781 int i, r, s, erl, er2, slot;</p>
      <p> 6782 vir_bytes v_buf;</p>
      <p> 6783 long len, a, c, ct, dest;</p>
      <p> 6784 struct mproc *xmp;</p>
      <p> 6785 extern char core_name[]; 6786</p>
      <p> 6787</p>
      <p> 6788 /# Change to working directory of dumpee. */</p>
      <p> 6789 slot = rmp - mproc;</p>
      <p> 6790 tell_fs(CHDIR, slot, 0, 0); 6791</p>
      <p> 6792 /* Can core file be written? */</p>
      <p> 6793 if (rmp-&gt;mp_realuid != rmp-&gt;mp_effuid) {tellfs(CHDIR,0,1,0); return;}</p>
      <p> 6794 xmp = mp; /* allowedO looks at 'mp' */</p>
      <p> 6795 mp = rmp;</p>
      <p> 6796 r = allowed(core_name, &amp;s_buf, W_BIT); /* is core_file writable */</p>
      <p> 6797 s = allowedC'.", &amp;d_buf, W_BIT); /* is directory writable? */</p>
      <p> 6798 mp = xmp;</p>
      <p> 6799 if (r &gt;= 0) close(r);</p>
      <p> 570 File: mm/signal.c MINIX SOURCE CODE</p>
      <p> 6800 if (s &gt;= 0) close(s);</p>
      <p> 6801 if (rmp-&gt;mp_effuid == SUPERJJSER) r = 0; /* su can always dump core */ 6802</p>
      <p> 6803 if (r &gt;= 0 ||  (r == ENOENT &amp;&amp; s &gt;= 0)) {</p>
      <p> 6804 /* Either file is writable or it doesn't exist &amp; dir is writable */</p>
      <p> 6805 r = creat(core_name, C0RE_M0DE);</p>
      <p> 6806 tell_fs(CHDIR, 0, 1, 0); /# go back to MM's own dir */</p>
      <p> 6807 if (r &lt; 0) return;</p>
      <p> 6808 rmp-&gt;mp_sigstatus |= DUMPED; 6809</p>
      <p> 6810 /# First loop through segments and write each length on core file. #/</p>
      <p> 6811 for (i = 0; i &lt; NR_5EGS; i++) {</p>
      <p> 6812 len = rmp-&gt;mp_seg[i].mem_len « CLICK_5HIFT;</p>
      <p> 6813 if (write(r, (char *) &amp;len, sizeof len) &lt; 0) {</p>
      <p> 6814 close(r);</p>
      <p> 6815 return;</p>
      <p> 6816 }</p>
      <p> 6817 } 6818</p>
      <p> 6819 /* Now loop through segments and write the segments themselves out. */</p>
      <p> 6820 v_buf = (vir_bytes) buf;</p>
      <p> 6821 dest = (long) v_buf;</p>
      <p> 6822 for (i = 0; i &lt; NR_SEGS; i++) {</p>
      <p> 6823 a = (phys_bytes) rmp-&gt;mp_seg[i].mem_vir &lt;&lt; CLICK_SHIFT;</p>
      <p> 6824 c = (phys_bytes) rmp-&gt;mp_seg[i].mem_len &lt;&lt; CLICK_SHIFT; 6825</p>
      <p> 6826 /# Loop through a segment, dumping it. #/</p>
      <p> 6827 while (c &gt; 0) {</p>
      <p> 6828 ct = MIN(c, DUMP_SIZE);</p>
      <p> 6829 erl = mem_copy(slot, i, a, MM_PR0C_NR, D, dest, ct);</p>
      <p> 6830 er2 = write(r, buf, (int) ct);</p>
      <p> 6831 if (erl &lt; 0 |j er2 &lt; 0) {</p>
      <p> 6832 close(r);</p>
      <p> 6833 return;</p>
      <p> 6834 }</p>
      <p> 6835 a += ct;</p>
      <p> 6836 c -= ct;</p>
      <p> 6837 }</p>
      <p> 6838 }</p>
      <p> 6839 } else {</p>
      <p> 6840 tell_fs(CHDIR, 0, 1, 0); /* go back to MM's own dir */</p>
      <p> 6841 close(r);</p>
      <p> 6842 return;</p>
      <p> 6843 } 6844</p>
      <p> 6845 close(r);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/getset.c</p>
      <p> 571</p>
      <p> 6850 /* This file handles the 4 system calls that get and set uids and gids.</p>
      <p> 6851 * It also handles getpidO.    The code for each one is so tiny that it hardly</p>
      <p> 6852 * seemed worthwhile to make each a separate function.</p>
      <p> 6853 */ 6854</p>
      <p> 6855 ^include "../h/const.h"</p>
      <p> 6856 ^include "../h/type.h"</p>
      <p> 6857 ^include "../h/callnr.h"</p>
      <p> 6858 ^include "../h/error.h"</p>
      <p> 6859 ^include "const.h"</p>
      <p> 6860 ^include "glo.h"</p>
      <p> 6861 ^include "mproc.h"</p>
      <p> 6862 ^include "param.h" 6863</p>
      <p> 6865 * do_getset *</p>
      <p> 6866 * = = = = = = = = === = = = = = = = = = = = = = === = = = = = === = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = ==*/</p>
      <p> 6867 PUBLIC int do_getset()</p>
      <p> 6868 {</p>
      <p> 6869 /* Handle GETUID, GETGID, GETPID, 5ETUID, SETGID.    The three GETs return</p>
      <p> 6870 * their primary results in 'r*.    GETUID and GETGID also return secondary</p>
      <p> 6871 » results (the effective IDs) in 'result2', which is returned to the user.</p>
      <p> 6872 */ 6873</p>
      <p> 6874 register struct mproc *rmp = mp;</p>
      <p> 6875 register int r; 6876</p>
      <p> 6877 switch(mm_call) {</p>
      <p> 6878 case GETUID:</p>
      <p> 6879 r = rmp-&gt;mp_realuid;</p>
      <p> 6880 result2 = rmp-&gt;mp_effuid;</p>
      <p> 6881 break; 6882</p>
      <p> 6883 case GETGID:</p>
      <p> 6884 r = rmp-&gt;mp_realgid;</p>
      <p> 6885 result2 = rmp-&gt;mp_effgid;</p>
      <p> 6886 break; 6887</p>
      <p> 6888 case GETPID:</p>
      <p> 6889 r = mproc[who].mp_pid;</p>
      <p> 6890 result2 = mproc[rmp-&gt;mp_parent],mp_pid;</p>
      <p> 6891 break; 6892</p>
      <p> 6893 case SETUID:</p>
      <p> 6894 if (rmp-&gt;mp_realuid != usr_id &amp;&amp; rmp-&gt;mp_effuid != SUPER_USER)</p>
      <p> 6895 return(EPERM);</p>
      <p> 6896 rmp-&gt;mp_realuid = usr_id;</p>
      <p> 6897 rmp-&gt;mp_effuid = usr_id;</p>
      <p> 6898 tell_fs(SETUID, who, usr_id, usr_id);</p>
      <p> 6899 r = OK;</p>
      <p> 572 File: mm/getset.c MINIX SOURCE CODE</p>
      <p> 6900 break; 6901</p>
      <p> 6902 case SETGID:</p>
      <p> 6903 if (rmp-&gt;mp_realgid != grpid &amp;&amp; rmp-&gt;mp_effuid != SUPERJJSER)</p>
      <p> 6904 return(EPERM);</p>
      <p> 6905 rmp-&gt;mp_realgid = grpid;</p>
      <p> 6906 rmp-&gt;mp_effgid = grpid;</p>
      <p> 6907 tell_fs(SETGID, who, grpid, grpid);</p>
      <p> 6908 r = OK;</p>
      <p> 6909 break;</p>
      <p> 6910 } 6911</p>
      <p> 6912 return(r);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/alloc.c</p>
      <p> 573</p>
      <p> 6950 /* This file is concerned with allocating and freeing arbitrary-size blocks of</p>
      <p> 6951 * physical memory on behalf of the FORK and EXEC system calls.    The key data</p>
      <p> 6952 * structure used is the hole table, which maintains a list of holes in memory.</p>
      <p> 6953 * It is kept sorted in order of increasing memory address. The addresses</p>
      <p> 6954 * it contains refer to physical memory, starting at absolute address 0</p>
      <p> 6955 * (i.e., they are not relative to the start of MM).    During system</p>
      <p> 6956 * initialization, that part of memory containing the interrupt vectors,</p>
      <p> 6957 * kernel, and MM are "allocated" to mark them as not available and to</p>
      <p> 6958 * remove them from the hole list.</p>
      <p> 6959 *</p>
      <p> 6960 * The entry points into this file are:</p>
      <p> 6961 *     alloc_mem: allocate a given sized chunk of memory</p>
      <p> 6962 *     free_mem:    release a previously allocated chunk of memory</p>
      <p> 6963 *     mem_init:    initialize the tables when MM starts up</p>
      <p> 6964 *     max_hole:    returns the largest hole currently available</p>
      <p> 6965 */ 6966</p>
      <p> 6967 ^include "../h/const.h"</p>
      <p> 6968 ^include "../h/type.h"</p>
      <p> 6969 ^include "const.h" 6970</p>
      <p> 6971 ^define NR_H0LES 128       /* max  §  entries in hole table */</p>
      <p> 6972 ^define Nil HOLE (struct hole #) 0</p>
      <p> 6973</p>
      <p> 6974 PRIVATE struct hole {</p>
      <p> 6975 phys_clicks h_base; /* where does the hole begin? ♦/</p>
      <p> 6976 phys_clicks h_len; /* how big is the hole? */</p>
      <p> 6977 struct hole *h_next; /* pointer to next entry on the list */</p>
      <p> 6978 } hole[NR_H0LES]; 6979</p>
      <p> 6980</p>
      <p> 6981 PRIVATE struct hole *hole_head; /* pointer to first hole */</p>
      <p> 6982 PRIVATE struct hole #free_slots; /# ptr to list of unused table slots */ 6983</p>
      <p> 6984 /*= = = = = = = = = = = = === = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = - = = = = = = ==*</p>
      <p> 6985 * alloc_mem #</p>
      <p> 6986 * = = = = = = = = = = = = = == = = = = r = = = = = = = = = = = = = = = = = :=: = = = = = =  =   =   =   : :-  =   =   =   =   =   =   =  = = = = = =  =   =   =   =   =   =   =   =   =   =   =   =  */</p>
      <p> 6987 PUBLIC phys_clicks alloc_mem(clicks)</p>
      <p> 6988 phys_clicks clicks; /* amount of memory requested */</p>
      <p> 6989 {</p>
      <p> 6990 /* Allocate a block of memory from the free list using first fit. The block</p>
      <p> 6991 ♦ consists of a sequence of contiguous bytes, whose length in clicks is</p>
      <p> 6992 * given by 'clicks'.    A pointer to the block is returned.    The block is</p>
      <p> 6993 * always on a click boundary.    This procedure is called when memory is</p>
      <p> 6994 # needed for FORK or EXEC.</p>
      <p> 6995 */ 6996</p>
      <p> 6997 register struct hole *hp, *prev_ptr;</p>
      <p> 6998 phys_clicks old_base; 6999</p>
      <p> 574 File: mm/alloc.c MINIX SOURCE CODE</p>
      <p> 7000 hp = hole_head;</p>
      <p> 7001 while (hp != Nil HOLE) {</p>
      <p> 7002 if (hp-&gt;h_len &gt;r clicks) {</p>
      <p> 7003 /* We found a hole that is big enough.   Use it. */</p>
      <p> 7004 old_base = hp-&gt;h_base;   /* remember where it started */</p>
      <p> 7005 hp-&gt;h_base += clicks;     /* bite a piece off */</p>
      <p> 7006 hp-&gt;h_len -= clicks;      /* ditto #/ 7007</p>
      <p> 7008 /* If hole is only partly used, reduce size and return. */</p>
      <p> 7009 if (hp-&gt;h_len != 0) return(old._base); 7010</p>
      <p> 7011 /* The entire hole has been used up.    Manipulate free list. ♦/</p>
      <p> 7012 del_slot(prev_ptr, hp);</p>
      <p> 7013 return(old_base);</p>
      <p> 7014 } 7015</p>
      <p> 7016 prev_ptr = hp;</p>
      <p> 7017 hp = hp-&gt;h_next;</p>
      <p> 7018 }</p>
      <p> 7019 return(N0_MEM);</p>
      <p> 7020 }</p>
      <p> 7024 * freejnem *</p>
      <p> 7025 »::::=:::: = :::::::":::: = ::::"::: = ====== = = = : = = = == = = = = = = = = ==""" = ""= = = = =«/</p>
      <p> 7026 PUBLIC free_mem(base, clicks)</p>
      <p> 7027 phys_clicks base; /* base address of block to free */</p>
      <p> 7028 phys_clicks clicks; /* number of clicks to free */</p>
      <p> 7029 {</p>
      <p> 7030 /* Return a block of free memory to the hole list.   The parameters tell where</p>
      <p> 7031 * the block starts in physical memory and how big it is.   The block is added</p>
      <p> 7032 * to the hole list.    If it is contiguous with an existing hole on either end,</p>
      <p> 7033 * it is merged with the hole or holes.</p>
      <p> 7034 */ 7035</p>
      <p> 7036 register struct hole *hp, *new_ptr, *prev_ptr; 7037</p>
      <p> 7038 if ( (new_ptr  -  free_slots) == Nil HOLE) panicC'Hole table full", N0_NUM);</p>
      <p> 7039 new_ptr-&gt;h_base = base;</p>
      <p> 7040 new_ptr-&gt;h_len = clicks;</p>
      <p> 7041 free_slots = new_ptr-&gt;h_next;</p>
      <p> 7042 hp = hole_head; 7043</p>
      <p> 7044 /* If this block's address is numerically less than the lowest hole currently</p>
      <p> 7045 * available, or if no holes are currently available, put this hole on the</p>
      <p> 7046 # front of the hole list.</p>
      <p> 7047 */</p>
      <p> 7048 if (hp == Nil HOLE || base &lt;= hp-&gt;h_base) {</p>
      <p> 7049 /* Block to be freed goes on front of hole list. */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/alloc.c</p>
      <p> 575</p>
      <p> 7050 new_ptr-&gt;h_next = hp;</p>
      <p> 7051 hole_head = new_ptr;</p>
      <p> 7052 merge(new_ptr);</p>
      <p> 7053 return;</p>
      <p> 7054 } 7055</p>
      <p> 7056 /* Block to be returned does not go on front of the hole list. */</p>
      <p> 7057 while (hp != Nil HOLE &amp;&amp; base &gt; hp-&gt;h_base) {</p>
      <p> 7058 prev_ptr = hp;</p>
      <p> 7059 hp = hp-&gt;h_next;</p>
      <p> 7060 } 7061</p>
      <p> 7062 /* We found where it goes.    Insert block after 'prev_ptr'. */</p>
      <p> 7063 new_ptr-&gt;h_next = prev_ptr-&gt;h_next;</p>
      <p> 7064 prev_ptr-&gt;h_next = new_ptr;</p>
      <p> 7065 merge(prev_ptr); /* sequence is 'prev_ptr', 'new_ptr', 'hp'  */</p>
      <p> 7066 }</p>
      <p> 7069 /*============================= = ================ =I=========================== *</p>
      <p> 7070 * del_slot *</p>
      <p> 7071  ================================= * /</p>
      <p> 7072 PRIVATE del_slot(prev_ptr, hp)</p>
      <p> 7073 register struct hole *prev_ptr; /* pointer to hole entry just ahead of 'hp' */</p>
      <p> 7074 register struct hole *hp; /* pointer to hole entry to be removed #/</p>
      <p> 7075 {</p>
      <p> 7076 /* Remove an entry from the hole list.    This procedure is called when a</p>
      <p> 7077 * request to allocate memory removes a hole in its entirety, thus reducing</p>
      <p> 7078 * the numbers of holes in memory, and requiring the elimination of one</p>
      <p> 7079 * entry in the hole list.</p>
      <p> 7080 */ 7081</p>
      <p> 7082 if (hp == hole_head)</p>
      <p> 7083 hole_head = hp-&gt;h_next;</p>
      <p> 7084 else</p>
      <p> 7085 prev_ptr-&gt;h_next = hp-&gt;h_next; 7086</p>
      <p> 7087 hp-&gt;h_next = free_slots;</p>
      <p> 7088 free_slots = hp;</p>
      <p> 7089 }</p>
      <p> 7092 /*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  =  = = = = = = =  =   =   =   =   ::   =  = =  =   =   =   =   =   =   =   =:= :  =   =   =   =   =   =   =   =   =   =   =   =   =  *</p>
      <p> 7093 * merge *</p>
      <p> 7094 *===================================== = ======= ====== == ========== =========== #/</p>
      <p> 7095 PRIVATE merge(hp)</p>
      <p> 7096 register struct hole *hp; /* ptr to hole to merge with its successors */</p>
      <p> 7097 {</p>
      <p> 7098 /* Check for contiguous holes and merge any found.    Contiguous holes can occur</p>
      <p> 7099 * when a block of memory is freed, and it happens to abut another hole on</p>
      <p> File: mm/alloc.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 7100 7101 7102 7103 7104 7105 7106 7107 7108 7109 7110 7111 7112 7113 7114 7115 7116 7117 7118 7119 7120 7121 7122 7123 7124 7125</p>
      <p> * either or both ends.    The pointer 'hp' points to the first of a series of</p>
      <p> * three holes that can potentially all be merged together. */</p>
      <p> register struct hole #next_ptr;</p>
      <p> /* If 'hp' points to the last hole, no merging is possible.    If it does not,</p>
      <p> * try to absorb its successor into it and free the successor's table entry. */</p>
      <p> if (  (next_ptr = hp-&gt;h_next) == Nil HOLE) return;</p>
      <p> if (hp-&gt;h_base + hp-&gt;h_len == next_ptr-&gt;h_base) {</p>
      <p> hp-&gt;h_len += next_ptr-&gt;h_len;      /* first one gets second one's mem */</p>
      <p> del_slot(hp, next_ptr); } else {</p>
      <p> hp = next_ptr;</p>
      <p> }</p>
      <p> /* If 'hp' now points to the last hole, return; otherwise, try to absorb its</p>
      <p> * successor into it. */</p>
      <p> if (  (next_ptr = hp-&gt;h_next) == Nil HOLE) return;</p>
      <p> if (hp-&gt;h_base + hp-&gt;h_len == next_ptr-&gt;h_base) {</p>
      <p> hp-&gt;h_len += next_ptr-&gt;h_len;</p>
      <p> del_slot(hp, next_ptr);</p>
      <p> }</p>
      <p> 7128 7129 7130 7131 7132 7133 7134 7135 7136 7137 7138 7139 7140 7141 7142 7143 7144 7145</p>
      <p> max_hole</p>
      <p> PUBLIC phys_clicks max_hole() {</p>
      <p> /* Scan the hole list and return the largest hole. */</p>
      <p> register struct hole *hp; register phys_clicks max;</p>
      <p> hp = hole_head; max = 0;</p>
      <p> while (hp != Nil HOLE) {</p>
      <p> if (hp-&gt;h_len &gt; max) max = hp-&gt;h_len; hp = hp-&gt;h_next;</p>
      <p> }</p>
      <p> return(max);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/alloc.c</p>
      <p> 577</p>
      <p> 7150 /*============================================================:=:=============*</p>
      <p> 7151 * mem_init *</p>
      <p> 7152 *=:::= = =====r=-===z==========z= = ==:====r=======:===============:=============*/</p>
      <p> 7153 PUBLIC mem_init(clicks)</p>
      <p> 7154 phys_clicks clicks; /* amount of memory available #/</p>
      <p> 7155 {</p>
      <p> 7156 /* Initialize hole lists.    There are two lists: 'hole_head' points to a linked</p>
      <p> 7157 * list of all the holes (unused memory) in the system; 'free_slots' points to</p>
      <p> 7158 * a linked list of table entries that are not in use.    Initially, the former</p>
      <p> 7159 * list has one entry, a single hole encompassing all of memory, and the second</p>
      <p> 7160 * list links together all the remaining table slots.   As memory becomes more</p>
      <p> 7161 * fragmented in the course of time (i.e., the initial big hole breaks up into</p>
      <p> 7162 * many small holes), new table slots are needed to represent them. These</p>
      <p> 7163 * slots are taken from the list headed by 'free_slots'.</p>
      <p> 7164 */ 7165</p>
      <p> 7166 register struct hole *hp;</p>
      <p> 7167</p>
      <p> 7168 for (hp = 4hole[0]; hp &lt; &amp;hole[NR_H0LES]; hp++) hp-&gt;h_next = hp + 1;</p>
      <p> 7169 hole[0].h_next = Nil HOLE;       /* only 1 big hole initially */</p>
      <p> 7170 hole[NR_H0LES-l].h_next = Nil HOLE;</p>
      <p> 7171 hole_head = &amp;hole[0];</p>
      <p> 7172 free_slots = &amp;hole[l];</p>
      <p> 7173 holetO].h_base = 0;</p>
      <p> 7174 holefO].h_len = clicks;</p>
      <p> 578 File: mm/utility.c MINIX SOURCE CODE</p>
      <p> 7200 /* This file contains some useful utility routines used by MM.</p>
      <p> 7201 *</p>
      <p> 7202 # The entries into the file are:</p>
      <p> 7203 *    allowed:     see if an access is permitted</p>
      <p> 7204 *     mem_copy:   copy data from somewhere in memory to somewhere else</p>
      <p> 7205 #    no_sys:      this routine is called for invalid system call numbers</p>
      <p> 7206 *    panic: MM has run aground of a fatal error and cannot continue</p>
      <p> 7207 */ 7208</p>
      <p> 7209 ^include "../h/const.h"</p>
      <p> 7210 ^include "../h/type.h"</p>
      <p> 7211 ^include "../h/callnr.h"</p>
      <p> 7212 //include ". ./h/com.h"</p>
      <p> 7213 //include ". ./h/error.h"</p>
      <p> 7214 //include "../h/stat.h"</p>
      <p> 7215 ^include "const.h"</p>
      <p> 7216 //include "glo.h"</p>
      <p> 7217 //include "mproc.h" 7218</p>
      <p> 7219 PRIVATE message copy_mess; 7220</p>
      <p> 7222 *                                                allowed * 7223</p>
      <p> 7224 PUBLIC int allowed(name_buf, s_buf, mask)</p>
      <p> 7225 char *name_buf; /* pointer to file name to be EXECed */</p>
      <p> 7226 struct stat *s_buf; /* buffer for doing and returning stat struct */</p>
      <p> 7227 int mask; /* R_BIT, W_BIT, or X_BIT */</p>
      <p> 7228 {</p>
      <p> 7229 /* Check to see if file can be accessed.   Return EACCES or EN0ENT if the access</p>
      <p> 7230 * is prohibited.    If it is legal open the file and return a file descriptor.</p>
      <p> 7231 */ 7232</p>
      <p> 7233 register int fd, shift;</p>
      <p> 7234 int mode;</p>
      <p> 7235 extern errno; 7236</p>
      <p> 7237 /* Open the file and stat it. */</p>
      <p> 7238 if ( (fd = open(name_buf, 0)) &lt; 0) return(-errno);</p>
      <p> 7239 if (fstat(fd, s_buf) &lt; 0) panicC'allowed: fstat failed", N0_NUM); 7240</p>
      <p> 7241 /* Only regular files can be executed. */</p>
      <p> 7242 mode = s_buf-&gt;st_mode &amp; I_TYPE;</p>
      <p> 7243 if (mask == X_BIT &amp;&amp; mode != I_REGULAR) {</p>
      <p> 7244 close(fd);</p>
      <p> 7245 return(EACCES);</p>
      <p> 7246 }</p>
      <p> 7247 /# Even for superuser, at least 1 X bit must be on. #/</p>
      <p> 7248 if (mp-&gt;mp_effuid == 0 44 mask == X_BIT 44</p>
      <p> 7249 (s_buf-&gt;st_mode 4 (X_BIT « 6 | X_BIT « 3 | X_BIT))) return(fd);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/utility.c</p>
      <p> 579</p>
      <p> 7250</p>
      <p> 7251 /* Right adjust the relevant set of permission bits. #/</p>
      <p> 7252 if (mp-&gt;mp_effuid == s_buf-&gt;st_uid) shift = 6;</p>
      <p> 7253 else if (mp-&gt;mp_effgid == s_buf-&gt;st_gid) shift = 3;</p>
      <p> 7254 else shift = 0; 7255</p>
      <p> 7256 if (s_buf-&gt;st_mode &gt;&gt; shift  &amp;  mask)     /* test the relevant bits */</p>
      <p> 7257 return(fd); /* permission granted */</p>
      <p> 7258 else {</p>
      <p> 7259 close(fd); /* permission denied */</p>
      <p> 7260 return(EACCES);</p>
      <p> 7261 }</p>
      <p> 7262 }</p>
      <p> 7265 /*=====:================r=:==:=========================;=========^============*</p>
      <p> 7266 * mem_copy *</p>
      <p> 7267 *:::==::::===::::=::::==:::::==:=::==:=:=:=:======::::=======:==========:===*/</p>
      <p> 7268 PUBLIC int mem_copy(src_proc,src_seg, src_vir, dst_proc,dst_seg, dst_vir, bytes)</p>
      <p> 7269 int src_proc; /* source process */</p>
      <p> 7270 int src_seg; /# source segment: T, D, or S */</p>
      <p> 7271 long src_vir; /* source virtual address (clicks for ABS) */</p>
      <p> 7272 int dst_proc; /* dest process */</p>
      <p> 7273 int dst_seg; /* dest segment: T, D, or S */</p>
      <p> 7274 long dst_vir;  /*  dest virtual address (clicks for ABS) #/</p>
      <p> 7275 long bytes; /* how many bytes (clicks for ABS) */</p>
      <p> 7276 {</p>
      <p> 7277 /* Transfer a block of data.    The source and destination can each either be a</p>
      <p> 7278 * process (including MM) or absolute memory, indicated by setting 'src_proc'</p>
      <p> 7279 * or 'dst_proc' to ABS.</p>
      <p> 7280 */ 7281</p>
      <p> 7282 if (bytes == 0L) return(OK);</p>
      <p> 7283 copy_mess.SRC_SPACE = (char) src_seg;</p>
      <p> 7284 copy_mess.SRC_PR0C_NR = src_proc;</p>
      <p> 7285 copy_mess.SRC_BUFFER = src_vir; 7286</p>
      <p> 7287 copy_mess.DST_SPACE = (char) dst_seg;</p>
      <p> 7288 copy_mess.DST_PR0C_NR = dst_proc;</p>
      <p> 7289 copy_mess.DST_BUFFER = dst_vir; 7290</p>
      <p> 7291 copy_mess.C0PY_BYTES = bytes;</p>
      <p> 7292 sys_copy(&amp;copy_mess);</p>
      <p> 7293 return(copy_mess.m_type);</p>
      <p> 7294 }</p>
      <p> 7295 = = = = = = = =   = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 7296 * no_sys #</p>
      <p> 7297 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = :: = = = = =: = = = = = = = = = = */</p>
      <p> 7298 PUBLIC int no_sys()</p>
      <p> 580 File: mm/utility.c MINIX SOURCE CODE</p>
      <p> 7300  /*  A system call number not implemented by MM has been requested. */ 7301</p>
      <p> 7302 return(EINVAL);</p>
      <p> 7303 }</p>
      <p> 7307 * panic *</p>
      <p> 7308 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =     = = = = =</p>
      <p> 7309 PUBLIC panic(format, num)</p>
      <p> 7310 char *format; /# format string */</p>
      <p> 7311 int num; /* number to go with format string */</p>
      <p> 7312 {</p>
      <p> 7313 /* Something awful has happened.    Panics are caused when an internal</p>
      <p> 7314 * inconsistency is detected, e.g., a programming error or illegal value of a</p>
      <p> 7315 * defined constant.</p>
      <p> 7316 */ 7317</p>
      <p> 7318 printf("Memory manager panic:  %s ",  format);</p>
      <p> 7319 if (num != N0_NUM) printf {"%6", num);</p>
      <p> 7320 printf("\n");</p>
      <p> 7321 tell_fs(SYNC, 0, 0, 0); /* flush the cache to the disk */</p>
      <p> 7322 sys_abort();</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/putc.c</p>
      <p> 581</p>
      <p> 7350 /* MM must occasionally print some message.    It uses the standard library</p>
      <p> 7351 * routine prinkO.    (The name "printf" is really a macro defined as "printk").</p>
      <p> 7352  *  Printing is done by calling the TTY task directly, not going through FS.</p>
      <p> 7353 */ 7354</p>
      <p> 7355 ^include ".,/h/const.h"</p>
      <p> 7356 ^include "../h/type.h"</p>
      <p> 7357 ^include "../h/com.h" 7358</p>
      <p> 7359 ^define STDJDUTPUT 1     /* file descriptor for standard output */</p>
      <p> 7360 ^define BUF_SIZE 100     /* print buffer size */ 7361</p>
      <p> 7362 PRIVATE int buf_count; /♦  H  characters in the buffer */</p>
      <p> 7363 PRIVATE char print.buf[BUF_SIZE]; /* output is buffered here */</p>
      <p> 7364 PRIVATE message putch_msg; /* used for message to TTY task */</p>
      <p> 7365</p>
      <p> 7366 /* = r = r = = = = = = r = = = : = = = = = =: = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 7367 * putc *</p>
      <p> 7368 *===========================================================================♦/</p>
      <p> 7369 PUBLIC putc(c)</p>
      <p> 7370 char c;</p>
      <p> 7371 { 7372</p>
      <p> 7373 /* Accumulate another character.   If '\n' or buffer full, print it. */</p>
      <p> 7374 print_buf[buf_count++] = c;</p>
      <p> 7375 if (buf_count == BUF_SIZE) F_l_u_s_h();</p>
      <p> 7376 if (c == '\n') F_l_u_s_h();</p>
      <p> 7377 }</p>
      <p> 7380 /*===========================================================================*</p>
      <p> 7381 * F_l_u_s_h *</p>
      <p> 7382 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = =: = */</p>
      <p> 7383 PRIVATE F_l_u_s_h()</p>
      <p> 7384 {</p>
      <p> 7385  /*  Flush the print buffer by calling TTY task. #/ 7386</p>
      <p> 7387 if (buf_count == 0) return;</p>
      <p> 7388 putch_msg.m_type = TTY_WRITE;</p>
      <p> 7389 putch_msg.PR0C_NR   = 0;</p>
      <p> 7390 putch_msg.TTY_LINE = 0;</p>
      <p> 7391 putch_msg.ADDRESS   = print_buf;</p>
      <p> 7392 putch_msg.COUNT = buf_count;</p>
      <p> 7393 sendrec(TTY, &amp;putch_msg);</p>
      <p> 7394 buf_count = 0;</p>
      <p> File: mm/table.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 7400 /* This file contains the table used to map system call numbers onto the</p>
      <p> 7401 * routines that perform them.</p>
      <p> 7402 */ 7403</p>
      <p> 7404 ^include "../h/const.h"</p>
      <p> 7405 ^include "../h/type.h"</p>
      <p> 7406 ^include "const.h" 7407</p>
      <p> 7408 tfundef EXTERN</p>
      <p> 7409 #define EXTERN 7410</p>
      <p> 7411 ^include "../h/callnr.h"</p>
      <p> 7412 (((include "glo.h"</p>
      <p> 7413 ^include "mproc.h"</p>
      <p> 7414 ^include "param.h" 7415</p>
      <p> 7416 /* Miscellaneous */</p>
      <p> 7417 char core_name[] = {"core"};      /* file name where core images are produced */</p>
      <p> 7418 unshort core_bits = OxOEFC;        /» which signals cause core images #/ 7419</p>
      <p> 7420 extern char mm_stack[];</p>
      <p> 7421 char *stackpt = &amp;mm_stack[MM_STACK_BYTES]; /* initial stack pointer */ 7422</p>
      <p> 7423 extern do_mm_exit(), do_fork(), do_wait(), do_brk(), do_getset(), do_exec();</p>
      <p> 7424 extern do_signal(), do_kill(), do_pause(), do_alarm();</p>
      <p> 7425 extern no_sys(), unpauseO, do_ksig(), do_brk2(); 7426</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: mm/table.c</p>
      <p> 583</p>
      <p> File: fs/const.h</p>
      <p> MINIX SOURCE CODE</p>
      <p> 7500 7501 7502 7503 7504 7505 7506 7507 7508 7509 7510 7511 7512 7513 7514 7515 7516 7517 7518 7519 7520 7521 7522 7523 7524 7525 7526 7527 7528 7529 7530 7531 7532 7533 7534 7535 7536 7537 7538 7539 7540 7541 7542 7543 7544 7545 7546 7547 7548 7549</p>
      <p> /* Tables sizes */</p>
      <p> ^define NR_Z0NE_NUMS 9</p>
      <p> ^define NR_8UFS 30</p>
      <p> //define NR_BUF_HASH 32</p>
      <p> //define NR_FDS 20</p>
      <p> //define NR_FILPS 64</p>
      <p> if/define I_MAP_SL0TS 4</p>
      <p> //define ZMAP_SL0TS 6</p>
      <p> ^define NR_IN0DES 32</p>
      <p> //define NR_SUPERS 3</p>
      <p> ^define NAME_SIZE 14 ((/define FS_STACK_BYTES 512</p>
      <p> /* Miscellaneous constants */ //define SUPER_MAGIC 0xl37F</p>
      <p> //define SU_UID ^define SYSJJID //define SY5_GID ^define NORMAL tfdefine N0_READ</p>
      <p> //define XPIPE //define N0_BIT //define DUP_MASK</p>
      <p> //define L00K_UP ^define ENTER ^define DELETE</p>
      <p> //define CLEAN #define DIRTY</p>
      <p> (uid) 0 (uid) 0 (gid) 0 0</p>
      <p> (bit_nr) 0 0100</p>
      <p> 0 1 2</p>
      <p> 0</p>
      <p> 1</p>
      <p> /*  §  zone numbers in an inode */</p>
      <p> /*  it  blocks in the buffer cache */</p>
      <p> /* size of buf hash table; MUST BE POWER OF 2*/</p>
      <p> /* max file descriptors per process */</p>
      <p> /* it  slots in filp table */</p>
      <p> /* max  it  of blocks in the inode bit map */</p>
      <p> /* max // of blocks in the zone bit map */</p>
      <p> /*  it  slots in "in core" inode table */</p>
      <p> /*  it  slots in super block table */</p>
      <p> /*  it  bytes in a directory component */</p>
      <p> /* size of file system stack */</p>
      <p> /* magic number contained in super-block #/</p>
      <p> /* super_user's uid */</p>
      <p> /* uid for processes MM and INIT */</p>
      <p> /* gid for processes MM and INIT */</p>
      <p> /* forces get..block to do disk read */</p>
      <p> /* prevents get_block from doing disk read */</p>
      <p> /* used in fp..task when suspended on pipe */ /* returned by alloc_bit() to signal failure */ /# mask to distinguish dup2 from dup */</p>
      <p> /* tells search_dir to lookup string */ /# tells search_dir to make dir entry */ /* tells search_dir to delete entry */</p>
      <p> /* disk and memory copies identical */ /* disk and memory copies differ */</p>
      <p> //define B00T_BL0CK (block_nr) 0 /* block number of boot block */ ^define SUPER_BL0CK (block_nr)l /* block number of super block */ ^define R00T_IN0DE (inode_nr) 1 /* inode number for root directory */</p>
      <p> /* Derived sizes #/ //define Z0NE_NUM_SIZE ^define NR_DZ0NE_NUM //define DIR_ENTRY_SIZE ^define IN0DES_PER_BL0CK ^define IN0DE_SIZE //define NR_DIR_ENTRIES //define NR_INDIRECTS ^define INTS_PER_BL0CK //define 5UPER_SIZE //define PIPE_5IZE</p>
      <p> sizeof(zone_nr)</p>
      <p> (NR_Z0NE_NUMS-2)</p>
      <p> sizeof(dir_struct)</p>
      <p> (BL0CK_SIZE/IN0DE_SIZE)</p>
      <p> (sizeof (d_inode))</p>
      <p> (BLOCK_SIZE/DIR_ENTRY_SIZE)</p>
      <p> (BL0CK_SIZE/Z0NE_NUM_SIZE)</p>
      <p> (BL0CK_SIZE/sizeof(int))</p>
      <p> sizeof(struct super_block)</p>
      <p> (NR_DZ0NE_NUM*BL0CK_5IZE) ^define MAX_Z0NES (NR_DZONE_NUM+NR_INDIRECTS+(long)NR_</p>
      <p> /* max</p>
      <p> //define printf printk</p>
      <p> /*  it  bytes in zone nr*/ /*  it  zones in inode */ /*  it  bytes/dir entry #/ /*  H  inodes/disk blk */ /* bytes in disk inode*/ /# // dir entries/blk*/ /*  #  zones/indir blk */ /* # integers/blk */ /* super_block size */ /* pipe size in bytes*/ INDIRECTS*NR_INDIRECTS) #  of zones in a file */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/buf.h</p>
      <p> 585</p>
      <p> 7550 /* Buffer (block) cache.    To acquire a block, a routine calls get_block(),</p>
      <p> 7551 * telling which block it wants.   The block is then regarded as "in use"</p>
      <p> 7552 * and has its 'b_count' field incremented.    All the blocks, whether in use</p>
      <p> 7553 * or not, are chained together in an LRU list, with 'front' pointing</p>
      <p> 7554 * to the least recently used block, and 'rear' to the most recently used</p>
      <p> 7555 # block.    A reverse chain, using the field b_prev is also maintained.</p>
      <p> 7556 * Usage for LRU is measured by the time the put_block() is done.    The second</p>
      <p> 7557 * parameter to put_block() can violate the LRU order and put a block on the</p>
      <p> 7558 * front of the list, if it will probably not be needed soon.    If a block</p>
      <p> 7559 * is modified, the modifying routine must set b_dirt to DIRTY, so the block</p>
      <p> 7560 * will eventually be rewritten to the disk.</p>
      <p> 7561 #/ 7562</p>
      <p> 7563 EXTERN struct buf {</p>
      <p> 7564 /* Data portion of the buffer. */</p>
      <p> 7565 union {</p>
      <p> 7566 char b_data[BLOCK_SIZE] ;</p>
      <p> 7567 dir_struct b dir[NR_DIR_ENTRIES];</p>
      <p> 7568 zone_nr b_ind[NR_INDIRECTS];</p>
      <p> 7569 d_inode b_inode[ IN0DES_PER_BL0CK] ;</p>
      <p> 7570 int b int[INTS_PER_BLOCK];</p>
      <p> 7571 } b; 7572</p>
      <p> 7586</p>
      <p> 7587 A These defs make it possible to use to bp-&gt;b_data instead of bp-&gt;b.b data  */</p>
      <p> 7588 tfdefine b_data b.b_data</p>
      <p> 7589 ^define b_dir b.b_dir</p>
      <p> 7590 #define b_ind    b.b ind</p>
      <p> 7591 ^define b_inode b.b inode</p>
      <p> 7592 ^define b_int b.b_int 7593</p>
      <p> 7594 EXTERN struct buf #buf_hash[NR_BUF_HA5H]; /* the buffer hash table */</p>
      <p> 7595</p>
      <p> 7596 EXTERN struct buf *front; /* points to least recently used free block */</p>
      <p> 7597 EX'TERN struct buf #rear; /# points to most recently used free block */</p>
      <p> 7598 EXTERN int bufs_in_use; /*  #  bufs currently in use (not on free list) */ 7599</p>
      <p> /* ordinary user data */</p>
      <p> /* directory block */</p>
      <p> /* indirect block */</p>
      <p> /# inode block */</p>
      <p> /* block full of integers */</p>
      <p> 586 File: fs/buf.h MINIX SOURCE CODE</p>
      <p> 7600 /* When a block is released, the type of usage is passed to put_block(). */</p>
      <p> 7601 ^define WRITE_IMMED 0100 /* block should be written to disk now */</p>
      <p> 7602 ^define 0NE_SH0T 0200 /* set if bloek-not likely to be needed soon *</p>
      <p> 7603 ^define IN0DE_BL0CK 0 + WRITE_IMMED /* inode block */</p>
      <p> 7604 i!/define DIRECT0RY_BL0CK      1 + WRITE_IMMED /* directory block */</p>
      <p> 7605 ^define INDIRECT_BL0CK        2 + WRITE_IMMED /* pointer block */</p>
      <p> 7606 ^define I_MAP_BL0CK 3 + WRITE_IMMED + 0NE_SH0T      /* inode bit map */</p>
      <p> 7607 ^define ZMAP_BL0CK 4 + WRITE_IMMED + 0NE_SH0T      /* free zone map */</p>
      <p> 7608 ^define ZUPER_BL0CK 5 + WRITE_IMMEO + 0NE_SH0T      /* super block */</p>
      <p> 7609 ^define FULI DATA-BLOCK      6 /* data, fully used *</p>
      <p> 7610 ^define PARTIAl DATA_BL0CK 7 /* data, partly used</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: f&amp;fdev.h</p>
      <p> 587</p>
      <p> 7650 A Device table.   This table is indexed by major device number.   It provid</p>
      <p> 7651 &lt;■ the link between major device numbers and the routines that process the</p>
      <p> 7652  */ 7653</p>
      <p> 7654 EXTERN struct dmap {</p>
      <p> 7655 int (*dmap_open)();</p>
      <p> 7656 int (*dmap_rw)();</p>
      <p> 7657 int (#dmap_close)();</p>
      <p> 7658 int dmap_task;</p>
      <p> 7659 } dmap[]; 7660</p>
      <p> 588 File: fs/file.h MINIX SOURCE CODE</p>
      <p> 7700 /# This is the filp table.   It is an intermediary between file descriptors and</p>
      <p> 7701 * inodes.   A slot is free if filp_count == 0.</p>
      <p> 7702 */ 7703</p>
      <p> 7704 EXTERN struct filp {</p>
      <p> 7705 mask_bits filp_mode; /* RW bits, telling how file is opened */</p>
      <p> 7706 int filp_count; /* how many file descriptors share this slot? */</p>
      <p> 7707 struct inode #filp_ino; /* pointer to the inode #/</p>
      <p> 7708 file_pos filp_pos; /# file position #/</p>
      <p> 7709 } filp[NR_FILPS]; 7710</p>
      <p> 7711      #define Nil FILP (struct filp ») 0 /* indicates absence of a filp slot */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/fproc.h</p>
      <p> 589</p>
      <p> 590 File: fs/glo.h MINIX SOURCE CODE</p>
      <p> 7800 /* File System global variables */</p>
      <p> 7801 EXTERN struct fproc *fp; /* pointer to caller's fproc struct */</p>
      <p> 7802 EXTERN int super_user; /* 1 if caller is super_user, else 0 #/</p>
      <p> 7803 EXTERN int dont_reply; /* normally 0; set to 1 to inhibit reply */</p>
      <p> 7804 EXTERN int susp_count; /* number of procs suspended on pipe */</p>
      <p> 7805 EXTERN int reviving; /* number of pipe processes to be revived #/</p>
      <p> 7806 EXTERN file_pos rdahedpos; /* position to read ahead #/</p>
      <p> 7807 EXTERN struct inode *rdahed_inode; /* pointer to inode to read ahead */ 7808</p>
      <p> 7809 /* The parameters of the call are kept here. */</p>
      <p> 7810 EXTERN message m; /* the input message itself */</p>
      <p> 7811 EXTERN message ml; /* the output message used for reply */</p>
      <p> 7812 EXTERN int who; /* caller's proc number #/</p>
      <p> 7813 EXTERN int fs_call; /* system call number ♦/</p>
      <p> 7814 EXTERN char user_path[MAX_PATH];/* storage for user path name #/ 7815</p>
      <p> 7816 /* The following variables are used for returning results to the caller. */</p>
      <p> 7817 EXTERN int err_code; /* temporary storage for error number */ 7818</p>
      <p> 7819 EXTERN char fstack[FS_STACK_BYTES];        /* the File System's stack. ♦/</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/inode.h</p>
      <p> 591</p>
      <p> 7850 /* Inode table.   This table holds inodes that are currently in use.   In some</p>
      <p> 7851 ♦ cases they have been opened by an open() or creatO system call, in other</p>
      <p> 7852 * cases the file system itself needs the inode for one reason or another,</p>
      <p> 7853 * such as to search a directory for a path name.</p>
      <p> 7854 * The first part of the struct holds fields that are present on the</p>
      <p> 7855 * disk; the second part holds fields not present on the disk.</p>
      <p> 7856 * The disk inode part is also declared in "type.h" as 'd_inode'.</p>
      <p> 7857 */ 7858</p>
      <p> 7859 EXTERN struct inode {</p>
      <p> 7860 unshort i_mode; /# file type, protection, etc. #/</p>
      <p> 7861 uid i_uid; /♦ user id of the file's owner */</p>
      <p> 7862 file_pos i_size; /* current file size in bytes */</p>
      <p> 7863 :eal_time i_modtime; /* when was file data last changed */</p>
      <p> 7864 gid i_gid; /* group number */</p>
      <p> 7865 Links i_nlinks; /* how many links to this file */</p>
      <p> 7866 zone_nr i_zone[NR_ZONE_NUMS]; /# zone numbers for direct, ind, and dbl ind */ 7867</p>
      <p> 7868  I*  The following items are not present on the disk. */</p>
      <p> 7869 dev_nr i_devj /» which device is the inode on */</p>
      <p> 7870 inode_nr i_num; /# inode number on its (minor) device */</p>
      <p> 7871 short int i_count; /♦  H  times inode used; 0 means slot is free */</p>
      <p> 7872 :har i_dirt; /* CLEAN or DIRTY */</p>
      <p> 7873 char i_pipe; /* set to I_PIPE if pipe */</p>
      <p> 7874 char i_mount; /* this bit is set if file mounted on */</p>
      <p> 7875 char i_seek; /* set on LSEEK, cleared on READ/WRITE */</p>
      <p> 7876 } inode[NR_IN0DES]j 7877</p>
      <p> 7878</p>
      <p> 7879      ^define Nil INODE (struct inode *) 0      /* indicates absence of inode slot */</p>
      <p> 7880</p>
      <p> 7881 /♦ Field values.   Note that CLEAN and DIRTY are defined in "const.h" */</p>
      <p> 7882 #define N0_PIPE 0      /* i_pipe is N0_PIPE if inode is not a pipe */</p>
      <p> 7883 #define I_PIPE 1      /* i_pipe is I_PIPE if inode is a pipe */</p>
      <p> 7884 //define N0_M0UNT 0      /* i_mount is N0_M0UNT if file not mounted on */</p>
      <p> 7885 ^define I.MOUNT 1      /* i_mount is I_M0UNT if file mounted on */</p>
      <p> 7886 //define NCLSEEK 0      /* i_seek = N0_SEEK if last op was not SEEK #/</p>
      <p> 7887 dfdefine ISEEK 1      /* i_seek = ISEEK if last op was SEEK */</p>
      <p> 592 File: fs/param.h MINIX SOURCE CODE</p>
      <p> 7900 /* The following names are synonyms for the variables in the input message.</p>
      <p> 7901 //define acctime m.m2_ll</p>
      <p> 7902 ^define addr m.ml_i3</p>
      <p> 7903 //define buffer m.ml_pl</p>
      <p> 7904 /(define cd_flag m.ml_i2</p>
      <p> 7905 ^define child m.ml_i2</p>
      <p> 7906 //define co_mode m.ml_il</p>
      <p> 7907 /(define eff_grp_id m.ml_i3</p>
      <p> 7908 //define eff_user_id m.ml_i3</p>
      <p> 7909 //define erki m.ml_pl</p>
      <p> 7910 //define fd m.ml.il</p>
      <p> 7911 //define fd2 m.ml_i2</p>
      <p> 7912 //define ioflags m.ml_i3</p>
      <p> 7913 //define group m.ml_i3</p>
      <p> 7914 //define real_grp_id m.ml_i2</p>
      <p> 7915 //define ls_fd m.m2_il</p>
      <p> 7916 //define mk_mode m.ml_i2</p>
      <p> 7917 //define mode m.m3_i2</p>
      <p> 7918 //define name m.m3_pl</p>
      <p> 7919 //define namel m.ml_pl</p>
      <p> 7920 ^define name2 m.ml_p2</p>
      <p> 7921 //define name_length m.m3_il</p>
      <p> 7922 //define namel_length m.ml_il</p>
      <p> 7923 //define name2_length m.ml_i2</p>
      <p> 7924 ^define nbytes m.ml_i2</p>
      <p> 7925 //define offset m.m2_ll</p>
      <p> 7926 //define owner m.ml_i2</p>
      <p> 7927 //define parent m.ml_il</p>
      <p> 7928 //define pathname m.m3_cal</p>
      <p> 7929 //define pro m.ml_il</p>
      <p> 7930 //define rd_only m.ml_i3</p>
      <p> 7931 //define real_user_id m.ml_i2</p>
      <p> 7932 //define request m.ml_i2</p>
      <p> 7933 //define sig m.ml_i2</p>
      <p> 7934 ^define slotl m.ml_il</p>
      <p> 7935 //define tp m.m2_ll</p>
      <p> 7936 //define update_time m.m2_12</p>
      <p> 7937 //define utime_file m.m2_pl</p>
      <p> 7938 //define utime_length m.m2_il</p>
      <p> 7939 //define whence m.m2_i2 7940</p>
      <p> 7941 /* The following names are synonyms for the variables in the output message.</p>
      <p> 7942 //define reply_type ml.m_type</p>
      <p> 7943 //define reply_ll ml.m2_ll</p>
      <p> 7944 //define reply_il ml.ml_il</p>
      <p> 7945 //define reply_i2 ml.ml_i2</p>
      <p> 7946 /(define reply_tl ml.m4_ll</p>
      <p> 7947 /(define reply_t2 ml.m4_12</p>
      <p> 7948 /(define reply_t3 ml.m4_13</p>
      <p> 7949 //define reply_t4 ml.m4_14</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/super.h</p>
      <p> 593</p>
      <p> 7950 /-(• Super block table.    The root file system and every mounted file system</p>
      <p> 795!. f has an entry here.    The entry holds information about the sizes of the bit</p>
      <p> 795;! »■ maps and inodes.    The s_ninodes field gives the number of inodes available</p>
      <p> 79515 (■ for files and directories, including the root directory.   Inode 0 is</p>
      <p> 7954 on the disk, but not used.    Thus s_ninodes = 4 means that 5 bits will be</p>
      <p> 7955 «■ used in the bit map, bit 0, which is always 1 and not used, and bits 1-4 795() &lt;■ for files and directories.    The disk layout is:</p>
      <p> 7957 *</p>
      <p> 79513  ■*           Item              §  blocks</p>
      <p> 7959 *       boot block 1</p>
      <p> 7960 »■      super block 1</p>
      <p> 7961 *      inode map s_imap_blocks</p>
      <p> 7962 *      zone map s_zmap_blocks</p>
      <p> 7963 *      inodes (s_ninodes + 1 + IN0DES_PER_BL0CK - 1)/IN0DES_PER_BL0CK</p>
      <p> 7964 *      unused whatever is needed to fill out the current zone</p>
      <p> 7965 x-      data zones       (s_nzones - s_firstdatazone) &lt;&lt; s_log_zone_size</p>
      <p> 7966 *</p>
      <p> 7967 * A super_block slot is free if s_dev  ==  N0_DEV. 7963 */</p>
      <p> 796? 7973</p>
      <p> 7971 EXTERN struct super_block {</p>
      <p> 7972 inode_nr s_ninodes; /*  #  usable inodes on the minor device */</p>
      <p> 7973 zone_nr s_nzones; /* total device size, including bit maps etc ♦/</p>
      <p> 7974 unshort s_imap_blocks; /*  #  of blocks used by inode bit map */</p>
      <p> 7975 unshort s_zmap_blocks; /*  §  of blocks used by zone bit map #/</p>
      <p> 7976 zone_nr s_firstdatazone; /* number of first data zone */</p>
      <p> 7977 short int s_log_zone_size;       /* log2 of blocks/zone */</p>
      <p> 7978 file_pos s_max_size; /* maximum file size on this device #/</p>
      <p> 7979 int s_magic; /* magic number to recognize super-blocks */ 7980</p>
      <p> 7981 /* The following items are only used when the super_block is in memory. */</p>
      <p> 7982 struct buf *s_imap[I_MAP_SL0TS]; /* pointers to the in-core inode bit map */</p>
      <p> 7983 struct buf *s_zmap[ZMAP_SL0T5] ; /* pointers to the in-core zone bit map */</p>
      <p> 7984 dev_nr s_dev; /* whose super block is this? */</p>
      <p> 7985 struct inode #s_isup; /* inode for root dir of mounted file sys */</p>
      <p> 7986 struct inode *s_imount; /* inode mounted on */</p>
      <p> 7987 real_time s_time; /* time of last update */</p>
      <p> 7988 char s_rd_only; /* set to 1 iff file sys mounted read only */</p>
      <p> 7989 char s_dirt; /* CLEAN or DIRTY #/</p>
      <p> 7990 ] super_block[NR_SUPERS] ; 7991</p>
      <p> 7952 ^define NIL_5UPER (struct super_block *) 0</p>
      <p> File: fs/type.h</p>
      <p> MINIX SOURCE CODE</p>
      <p> 8000 /* Type definitions local to the File System. #/ 8001</p>
      <p> 8002 typedef struct { /♦ directory entry »/</p>
      <p> 8003 inode_nr d_inum; /* inode number #/</p>
      <p> 8004 char d_name[NAME_SIZE]; /* character string */</p>
      <p> 8005 } dir_struct; 8006</p>
      <p> 8007 /* Declaration of the disk inode used in rw_inode(). #/</p>
      <p> 8008 typedef struct { /* disk inode.   Memory inode is in "inotab.h" */</p>
      <p> 8009 mask_bits i_mode; /* file type, protection, etc. #/</p>
      <p> 8010 uid i_uid; /♦ user id of the file's owner */</p>
      <p> 8011 file_pos i_size; /* current file size in bytes */</p>
      <p> 8012 real_time i_modtime; /* when was file data last changed #/</p>
      <p> 8013 gid i_gid; /# group number */</p>
      <p> 8014 links i_nlinks; /* how many links to this file #/</p>
      <p> 8015 zone_nr i_zone[NR_Z0NE_NUMS]; /# block nums for direct, ind, and dbl ind */</p>
      <p> 8016 } d_inode;</p>
      <p> MINK SOURCE CODE</p>
      <p> File: fs/cache.c</p>
      <p> 595</p>
      <p> 8050 /* The file system maintains a buffer cache to reduce the number of disk</p>
      <p> 8051 * accesses needed.   Whenever a read or write to the disk is done, a check is</p>
      <p> 8052 * first made to see if the block is in the cache.   This file manages the</p>
      <p> 8053 * cache.</p>
      <p> 8054 *</p>
      <p> 8055 * The entry points into this file are:</p>
      <p> 8056 *     get_block:     request to fetch a block for reading or writing from cache</p>
      <p> 8057 *     put_block:     return a block previously requested with get_block</p>
      <p> 8058 *     alloc_zone:   allocate a new zone (to increase the length of a file)</p>
      <p> 8059  m      free_zone:     release a zone (when a file is removed)</p>
      <p> 8060 *■     rw_block:       read or write a block from the disk itself</p>
      <p> 8061 *     invalidate:    remove all the cache blocks on some device</p>
      <p> 8062 */ 8063</p>
      <p> 8064 ^include "../h/const.h"</p>
      <p> 8065 include ". ./h/type.h"</p>
      <p> 8066 include ". ./h/error.h"</p>
      <p> 8067 include "const.h"</p>
      <p> 8068 include "type.h"</p>
      <p> 8069 ^include "buf.h"</p>
      <p> 8070 ^include "file.h"</p>
      <p> 8071 if/include "fproc.h"</p>
      <p> 8072 include "glo.h"</p>
      <p> 8073 ^include "inode.h"</p>
      <p> 8074 ^include "super.h" 8075</p>
      <p> 8076 /*= = = = = = = = = = = = = = = = = = = = =r = = = = = = = = = r = = = = = = = = = = = =  =  = = = = = = :  =   =   =   =   =  - =  =   =   =   =   =   =   =   =   =   =   =   =   = :  =   =   =  *</p>
      <p> 8077 + get_block *</p>
      <p> 8078 = = = = = = = = = = = = = = = = - = = = = = = = = = = = = = = = = = = = = = = = = = : = : = = = = = = =     = =  = = = = = = = = = = = = = = = = =</p>
      <p> 8075 PUBLIC struct buf *get_block(dev, block, only_search)</p>
      <p> 808C register dev_nr dev;                    /* on which device is the block? */</p>
      <p> 8081 register block_nr block; /# which block is wanted? */</p>
      <p> 8082 int only_search; /* if N0_READ, don't read, else act normal */</p>
      <p> 8083 {</p>
      <p> 8084 /•»• Check to see if the requested block is in the block cache.    If so, return</p>
      <p> 8085 +• a pointer to it.   If not, evict some other block and fetch it (unless</p>
      <p> 8086 »■ 'only_search' is 1).    All blocks in the cache, whether in use or not,</p>
      <p> 8087 •&gt;■ are linked together in a chain, with 'front' pointing to the least recently</p>
      <p> 8088 used block and 'rear' to the most recently used block. If 'only_search' is 8085 1, the block being requested will be overwritten in its entirety, so it is</p>
      <p> 8090  i-  only necessary to see if it is in the cache; if it is not, any free buffer</p>
      <p> 8091 will do.    It is not necessary to actually read the block in from disk.</p>
      <p> 8092 v In addition to the LRU chain, there is also a hash chain to link together</p>
      <p> 8093 ■&gt;• blocks whose block numbers end with the same bit strings, for fast lookup. 8094</p>
      <p> 8095</p>
      <p> 8096 register struct buf *bp, #prev_ptr; 8097</p>
      <p> 8098 /* Search the list of blocks not currently in use for (dev, block). */</p>
      <p> 8099 bp = buf_hash[block &amp; (NR_BUF_HASH - 1)]; /# search the hash chain */</p>
      <p> 596 File: fs/cache.c MINIX SOURCE CODE</p>
      <p> 8100 if (dev != NCLDEV) {</p>
      <p> 8101 while (bp != Nil BUF)  {</p>
      <p> 8102 if (bp-&gt;b_blocknr == block &amp;&amp; bp-&gt;b_dev == dev) {</p>
      <p> 8103 /* Block needed has been found. */</p>
      <p> 8104 if (bp-&gt;b_count == 0) bufs_in_use++;</p>
      <p> 8105 bp-&gt;b_count++;    /* record that block is in use */</p>
      <p> 8106 return(bp);</p>
      <p> 8107 } else {</p>
      <p> 8108 /* This block is not the one sought. */</p>
      <p> 8109 bp = bp-&gt;b_hash; /* move to next block on hash chain */</p>
      <p> 8110 }</p>
      <p> 8111 }</p>
      <p> 8112 } 8113</p>
      <p> 8114 /* Desired block is not on available chain.    Take oldest block ('front').</p>
      <p> 8115 * However, a block that is already in use (b_count &gt; 0) may not be taken.</p>
      <p> 8116 */</p>
      <p> 8117 if (bufs_in_use == NFL.BUFS) panic("All buffers in use", NR_BUFS);</p>
      <p> 8118 bufs_in_use++; /* one more buffer in use now */</p>
      <p> 8119 bp = front;</p>
      <p> 8120 while (bp-&gt;b_count &gt; 0 &amp;&amp; bp-&gt;b_next != Nil BUF) bp = bp-&gt;b_next;</p>
      <p> 8121 if (bp == Nil BUF || bp-&gt;b_count &gt; 0) panicC'No free buffer", N0_NUM);</p>
      <p> 8122</p>
      <p> 8123 /* Remove the block that was just taken from its hash chain.  */</p>
      <p> 8124 prev_ptr = buf_hash[bp-&gt;b_blocknr &amp; (NR_BUF_HASH - 1)];</p>
      <p> 8125 if (prev_ptr == bp) {</p>
      <p> 8126 buf_hash[bp-&gt;b_blocknr &amp; (NR_BUF_HA5H - 1)] = bp-&gt;b_hash;</p>
      <p> 8127 } else {</p>
      <p> 8128 /* The block just taken is not on the front of its hash chain. */</p>
      <p> 8129 while (prev_ptr-&gt;b_hash != Nil BUF)</p>
      <p> 8130 if (prev_ptr-&gt;b_hash == bp) {</p>
      <p> 8131 prev_ptr-&gt;b_hash = bp-&gt;b_hash;    / * found it */</p>
      <p> 8132 break;</p>
      <p> 8133 } else {</p>
      <p> 8134 prev_ptr = prev_ptr-&gt;b_hash;       /* keep looking */</p>
      <p> 8135 ]</p>
      <p> 8136 } 8137</p>
      <p> 8138 /* If the   block taken is dirty, make it clean by rewriting it to disk. #/</p>
      <p> 8139 if (bp-&gt;b_dirt == DIRTY &amp;&amp; bp-&gt;b_dev != N0_DEV) rw_block(bp, WRITING); 8140</p>
      <p> 8141 /* Fill in block's parameters and add it to the hash chain where it goes. #/</p>
      <p> 8142 bp-&gt;b_dev = dev; /* fill in device number */</p>
      <p> 8143 bp-&gt;b_blocknr = block; /* fill in block number */</p>
      <p> 8144 bp-&gt;b_count++; /* record that block is being used */</p>
      <p> 8145 bp-&gt;b_hash = buf_hash[bp-&gt;b_blocknr &amp; (NR_BUF_HASH - 1)];</p>
      <p> 8146 buf_hash[bp-&gt;b_blocknr &amp; (NR_BUF_HASH - 1)] = bp; /* add to hash list */ 8147</p>
      <p> 8148  /*  Go get the requested block, unless only_search = N0_READ. */</p>
      <p> 8149 if (dev != N0_DEV U only_search == NORMAL) rw_block(bp, READING);</p>
      <p> MINIX SOURCE CODE                File: fs/cache.c 597</p>
      <p> 8150 return(bp); /# return the newly acquired block ♦/</p>
      <p> 8151 }</p>
      <p> 8154 /»: = = = = = = : = = = =  :  = = =  : =:::== =  :  = = ::= :  = = ::: : = = : = = = ::"==: = :=:= = i=:" = = = :: = = = = =====«</p>
      <p> 8155  &gt;t  put_block *</p>
      <p> 8156 f = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = r== = = = = = r = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = =: = */</p>
      <p> 8157 PUBLIC put_block(bp, block_type)</p>
      <p> 8158 register struct buf *bp; /* pointer to the buffer to be released */ 815!' int block_type;                            /* IN0DE_BL0CK, DIRECT0RY_BL0CK, or whatever */</p>
      <p> 8160 {</p>
      <p> 8161  /■*■  Return a block to the list of available blocks.     Depending on 'block_type' 816-'? * it may be put on the front or rear of the LRU chain.   Blocks that are</p>
      <p> 8163 ■&lt;• expected to be needed again shortly (e.g., partially full data blocks)</p>
      <p> 816a * go on the rear; blocks that are unlikely to be needed again shortly</p>
      <p> 8165 * (e.g., full data blocks) go on the front.   Blocks whose loss can hurt</p>
      <p> 816(3 ■* the integrity of the file system (e.g., inode blocks) are written to</p>
      <p> 8167  *  disk immediately if they are dirty.</p>
      <p> 816(3 */ 8169</p>
      <p> 81713 register struct buf *next_ptr, *prev_ptr; 8171</p>
      <p> 8172 if (bp — Nil BUF) return;       /# it is easier to check here than in caller */</p>
      <p> 8173</p>
      <p> 8174 /* If block is no longer in use, first remove it from LRU chain. */ 817? bp-&gt;b_count--;                         /# there is one use fewer now */</p>
      <p> 8175 if (bp-&gt;b_count &gt; 0) return;   /* block is still in use */ 8177</p>
      <p> 8179 bufs_in_use--; /* one fewer block buffers in use */ 817? next_ptr = bp-&gt;b_next;             /* successor on LRU chain */</p>
      <p> 8180 prev_ptr = bp-&gt;b_prev; /* predecessor on LRU chain */</p>
      <p> 8181 if (prev_ptr != Nil BUF)</p>
      <p> 8182 prev_ptr-&gt;b_next = next_ptr;</p>
      <p> 8183 else</p>
      <p> 8184 front = next_ptr; /# this block was at front of chain */ 8185</p>
      <p> 8186 if (next_ptr != Nil BUF)</p>
      <p> 8187 next_ptr-&gt;b_prev = prev_ptr;</p>
      <p> 8188 else</p>
      <p> 8189 rear = prev_ptr; /* this block was at rear of chain */ 8190</p>
      <p> 8191 /* Put this block back on the LRU chain.    If the 0NE_SH0T bit is set in</p>
      <p> 8192 * 'block_type', the block is not likely to be needed again shortly, so put</p>
      <p> 8193 * it on the front of the LRU chain where it will be the first one to be</p>
      <p> 8194 * taken when a free buffer is needed later.</p>
      <p> 8195 */</p>
      <p> 8196 if (block_type &amp; 0NE_SH0T) {</p>
      <p> 8197 /* Block probably won't be needed quickly. Put it on front of chain.</p>
      <p> 8198 * It will be the next block to be evicted from the cache.</p>
      <p> 8159 #/</p>
      <p> 598 File: fs/cache.c MINIX SOURCE CODE</p>
      <p> 8200 bp-&gt;b_prev = Nil BUT;</p>
      <p> 8201 bp-&gt;b_next = front;</p>
      <p> 8202 if (front := Nil BUF)</p>
      <p> 8203 rear = bp; /* LRU chain was empty #/</p>
      <p> 8204 else</p>
      <p> 8205 front-&gt;b_prev = bp;</p>
      <p> 8206 front = bp;</p>
      <p> 8207 } else {</p>
      <p> 8208 /* Block probably will be needed quickly.    Put it on rear of chain.</p>
      <p> 8209 * It will not be evicted from the cache for a long time.</p>
      <p> 8210 */</p>
      <p> 8211 bp-&gt;b_prev = rear;</p>
      <p> 8212 bp-&gt;b_next = Nil BUF;</p>
      <p> 8213 if (rear == Nil BUF)</p>
      <p> 8214 front = bp;</p>
      <p> 8215 else</p>
      <p> 8216 rear-&gt;b_next = bp;</p>
      <p> 8217 rear = bp;</p>
      <p> 8218 } 8219</p>
      <p> 8220 /# Some blocks are so important (e.g., inodes, indirect blocks) that they</p>
      <p> 8221 * should be written to the disk immediately to avoid messing up the file</p>
      <p> 8222 * system in the event of a crash.</p>
      <p> 8223 */</p>
      <p> 8224 if ((block_type &amp; WRITE_IMMED) &amp;&amp; bp-&gt;b_dirt==DIRTY &amp;&amp; bp-&gt;b_dev != N0_DEV)</p>
      <p> 8225 rw_block(bp, WRITING); 8226</p>
      <p> 8227 /* Super blocks must not be cached, lest mount use cached block. */</p>
      <p> 8228 if (block_type == ZUPER_BL0CK) bp-&gt;b_dev = N0_DEV;</p>
      <p> 8229 }</p>
      <p> 8233 * alloc_zone *</p>
      <p> 8234 * = = = = = = = = = = = = = = = = = = = = = — = = = = = = = = = — = = = = - = = = = = : = = = = = = = = = = = = = = = = r = = r = = = = = = = = = = */</p>
      <p> 8235 PUBLIC zone_nr alloc_zone(dev, z)</p>
      <p> 8236 dev_nr dev; /* device where zone wanted */</p>
      <p> 8237 zone_nr z; /# try to allocate new zone near this one */</p>
      <p> 8238 {</p>
      <p> 8239 /* Allocate a new zone on the indicated device and return its number. */ 8240</p>
      <p> 8241 bit_nr b, bit;</p>
      <p> 8242 struct super_block *sp;</p>
      <p> 8243 int major, minor;</p>
      <p> 8244 extern bit_nr alloc_bit();</p>
      <p> 8245 extern struct super_block *get_super(); 8246</p>
      <p> 8247 /* Note that the routine alloc_bit() returns 1 for the lowest possible</p>
      <p> 8248 * zone, which corresponds to sp-&gt;s_firstdatazone.    To convert a value</p>
      <p> 8249 * between the bit number, 'b', used by alloc_bit() and the zone number,  'z',</p>
      <p> MIN1X SOURCE CODE</p>
      <p> File: fs/cache.c</p>
      <p> 599</p>
      <p> 8250 * stored in the inode, use the formula:</p>
      <p> 8251 » z = b + sp-&gt;s_firstdatazone - 1</p>
      <p> 8252 # Alloc_bit() never returns 0, since this is used for NCLBIT (failure).</p>
      <p> 8253 ♦/</p>
      <p> 8254 sp = get_super(dev); /♦ find the super_block for this device */</p>
      <p> 8255 bit = (bit_nr) z - (sp-&gt;s_firstdatazone - 1);</p>
      <p> 8256 b  -  alloc_bit(sp-&gt;s_zmap, (bit_nr) sp-&gt;s_nzones - sp-&gt;s_firstdatazone + 1,</p>
      <p> 8257 sp-&gt;s_zmap_blocks, bit);</p>
      <p> 8258 if (b == N0_BIT) {</p>
      <p> 8259 err_code = ENOSPC;</p>
      <p> 8260 major = (int) (sp-&gt;s_dev » MAJOR) 4 BYTE;</p>
      <p> 8261 minor = (int) (sp-&gt;s_dev » MINOR) 4 BYTE;</p>
      <p> 8262 if (sp-&gt;s_dev == R00T_DEV)</p>
      <p> 8263 printfC'No space on root device (RAM disk)\n");</p>
      <p> 8264 else</p>
      <p> 8265 printfC'No space on device %d/?»d\n", major, minor);</p>
      <p> 8266 return(N0_Z0NE);</p>
      <p> 8267 }</p>
      <p> 8268 return(sp-&gt;s_firstdatazone - 1 + (zone_nr) b);</p>
      <p> 8269 }</p>
      <p> 8272 /* = = = = = === === = === = = === = = = = = = = = = = = = = = = = = = ===== = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = *</p>
      <p> 8273 * free_zone *</p>
      <p> 8275 PLBLIC free_zone(dev, numb)</p>
      <p> 8276 dev_nr dev; /* device where zone located #/</p>
      <p> 8277 zcne_nr numb; /* zone to be returned */</p>
      <p> 8278 {</p>
      <p> 8279 /» Return a zone. */ 8280</p>
      <p> 8281 register struct super_block *sp;</p>
      <p> 8282 extern struct super_block »get_super(); 8283</p>
      <p> 8284 if (numb == N0_Z0NE) return;   /♦ checking here easier than in caller #/ 8285</p>
      <p> 8286 /* Locate the appropriate super_block and return bit. #/</p>
      <p> 8287 sp = get_super(dev);</p>
      <p> 828E free_bit(sp-&gt;s_zmap, (bit_nr) numb - (sp-&gt;s_firstdatazone - 1) );</p>
      <p> 8285 }</p>
      <p> 8292 /^ = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = =  =  = = = = = =  =  = = = = = =  =  = = = = = =  =   =   =  = = =: =  I   =   =   =  = = =  =   =   =  #</p>
      <p> 8293 rw_block *</p>
      <p> 829^ .:::==:===::=:::::::===:::::::=;===:==;==:::::::====;==:===:=:=::::======::=,/</p>
      <p> 8293- PUBLIC rw_block(bp, rw_flag)</p>
      <p> 8296 register struct buf *bp; /* buffer pointer */</p>
      <p> 8297 int rw_flag; /* READING or WRITING */ 829fl {</p>
      <p> 600 File: fs/cache.c MINIX SOURCE CODE</p>
      <p> 8300 * I/O is invoked.    If an error occurs, a message is printed here, but the erro</p>
      <p> 8301 * is not reported to the caller.    If the error occurred while purging a block</p>
      <p> 8302 * from the cache, it is not clear what the caller could do about it anyway.</p>
      <p> 8303 */ 8304</p>
      <p> 8305 int r;</p>
      <p> 8306 long pos;</p>
      <p> 8307 dev_nr dev; 8308</p>
      <p> 8309 if (bp-&gt;b_dev != N0_DEV) {</p>
      <p> 8310 pos = (long) bp-&gt;b_blocknr * BL0CK_SIZE;</p>
      <p> 8311 r = dev_io(rw_flag, bp-&gt;b_dev, pos, BL0CK_SIZE, FS_PR0C_NR, bp-&gt;b_data)</p>
      <p> 8312 if (r &lt; 0) {</p>
      <p> 8313 dev = bp-&gt;b_dev;</p>
      <p> 8314 printf("Unrecoverable disk error on device  %d/°id,  block ?id\n",</p>
      <p> 8315 (dev»MA:0R)&amp;BYTE, (dev»MIN0R)&amp;BYTE, bp-&gt;b_blocknr);</p>
      <p> 8316 }</p>
      <p> 8317 } 8318</p>
      <p> 8319 bp-&gt;b_dirt = CLEAN;</p>
      <p> 8320 }</p>
      <p> 8324        * invalidate *</p>
      <p> 8326 PUBLIC invalidate(device)</p>
      <p> 8327 dev_nr device; /* device whose blocks are to be purged */</p>
      <p> 8328 {</p>
      <p> 8329 /* Remove all the blocks belonging to some device from the cache. ♦/ 8330</p>
      <p> 8331 register struct buf *bp;</p>
      <p> 8332</p>
      <p> 8333 for (bp = &amp;buf[0]; bp &lt; &amp;buf[NR_BUFS]; bp++)</p>
      <p> 8334 if (bp-&gt;b_dev == device) bp-&gt;b_dev = NCLDEV;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/inode.c</p>
      <p> 601</p>
      <p> 8350 /♦ This file manages the inode table.    There are procedures to allocate and</p>
      <p> 8351 * deallocate inodes, acquire, erase, and release them, and read and write</p>
      <p> 8352 * them from the disk.</p>
      <p> 8353 *</p>
      <p> 8354 * The entry points into this file are</p>
      <p> 8353 *     get_inode:     search inode table for a given inode; if not there, read it</p>
      <p> 8356 *     put_inode:     indicate that an inode is no longer needed in memory</p>
      <p> 8357 *     alloc_inode: allocate a new, unused inode</p>
      <p> 8353 *     wipe_inode:    erase some fields of a newly allocated inode</p>
      <p> 8359 *     free_inode:   mark an inode as available for a new file</p>
      <p> 8360 ♦     rw_inode;       read a disk block and extract an inode, or corresp. write 836L *     dup_inode:      indicate that someone else is using an inode table entry</p>
      <p> 8362 */ 8363</p>
      <p> 8364 //include "../h/const.h"</p>
      <p> 8363 //include ". ./h/type.h"</p>
      <p> 8366 //include ". ,/h/error.h"</p>
    </div>
  </body>
</html>
