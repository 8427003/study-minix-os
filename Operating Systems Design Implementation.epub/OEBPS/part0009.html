<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>part0009</title>
    <meta content="abbyy to epub tool, v0.2" name="generator"/>
    <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
    <meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
    <div class="body">
      <p> 8367 //include "const.h" 8363 //include "type.h" 836? //include "buf.h" 8373 ^include "file.h"</p>
      <p> 8371 //include "fproc.h"</p>
      <p> 8372 //include "glo.h"</p>
      <p> 8373 ^include "inode.h"</p>
      <p> 8374 //include "super.h" 8375</p>
      <p> 8376 /#===========================================================================</p>
      <p> 8377 * get_inode</p>
      <p> 8378 * = = = = = = : = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = r = = r = = = = = r = = = = = = = : :;  = = = = = = :</p>
      <p> 8379 PUBLIC struct inode *get_inode(dev, numb)</p>
      <p> 8380 dev_nr dev; /# device on which inode resides */</p>
      <p> 8381 inode_nr numb; /# inode number */</p>
      <p> 8382 {</p>
      <p> 8383 /* Find a slot in the inode table, load the specified inode into it, and</p>
      <p> 8384 * return a pointer to the slot.    If 'dev' == NCLDEV, just return a free slot</p>
      <p> 8385 */ 8386</p>
      <p> 8387 register struct inode *rip, *xp; 8388</p>
      <p> 8389 /♦ Search the inode table both for (dev, numb) and a free slot. #/</p>
      <p> 8390 xp = Nil INODE ;</p>
      <p> 8391 for (rip = &amp;inode[0]; rip &lt; &amp;inode[NR_IN0DES]; rip++) {</p>
      <p> 8352 if (rip-&gt;i_count &gt; 0) { /* only check used slots for (dev, numb) */</p>
      <p> 8353 if (rip-&gt;i_dev == dev &amp;&amp; rip-&gt;i_num == numb) {</p>
      <p> 8354 /* This is the inode that we are looking for. */</p>
      <p> 8355 rip-&gt;i_count++;</p>
      <p> 8356 return(rip);       /♦ (dev, numb) found */</p>
      <p> 8357 }</p>
      <p> 8358 } else</p>
      <p> 8359 xp = rip; /* remember this free slot for later */</p>
      <p> 602 File: fs/inode.c MINIX SOURCE CODE</p>
      <p> 8400 } 8401</p>
      <p> 8402 /* Inode we want is not currently in use.   Did we find a free slot? */</p>
      <p> 8403 if (xp == Nil INODE) { /* inode table completely full »/</p>
      <p> 8404 err_code = ENFILE;</p>
      <p> 8405 return(NIL_IN0DE);</p>
      <p> 8406 } 8407</p>
      <p> 8408 /* A free inode slot has been located.    Load the inode into it. */</p>
      <p> 8409 xp-&gt;i_dev = dev;</p>
      <p> 8410 xp-&gt;i_num = numb;</p>
      <p> 8411 xp-&gt;i_count = 1;</p>
      <p> 8412 if (dev != NCLDEV) rw_inode(xp, READING); /* get inode from disk */ 8413</p>
      <p> 8414 return(xp);</p>
      <p> 8415 }</p>
      <p> 8418 /*===========================================================================*</p>
      <p> 8419 # put_inode *</p>
      <p> 8420 » = ": ===::== = ==:::"::::::: = ::=:: = : = ::==:=: = =" = "= = = "" = "=:: = = := = = =: = = = = = »/</p>
      <p> 8421 PUBLIC put_inode(rip)</p>
      <p> 8422 register struct inode *rip; /* pointer to inode to be released */</p>
      <p> 8423 {</p>
      <p> 8424 /* The caller is no longer using this inode.   If no one else is using it either</p>
      <p> 8425 * write it back to the disk immediately.   If it has no links, truncate it and</p>
      <p> 8426 * return it to the pool of available inodes.</p>
      <p> 8427 */ 8428</p>
      <p> 8429 if (rip == Nil INODE) return; /# checking here is easier than in caller */</p>
      <p> 8430 if (--rip-&gt;i_count == 0) {       /* i_count == 0 means no one is using it now */</p>
      <p> 8431 if ((rip-&gt;i_nlinks &amp; BYTE) == 0) {</p>
      <p> 8432 /* i_nlinks == 0 means free the inode. */</p>
      <p> 8433 truncate(rip);    /* return all the disk blocks */</p>
      <p> 8434 rip-&gt;i_mode = I_N0T_ALL0C; /* clear I_TYPE field */</p>
      <p> 8435 rip-&gt;i_pipe = NCLPIPE;</p>
      <p> 8436 free_inode(rip-&gt;i_dev, rip-&gt;i_.num);</p>
      <p> 8437 } 8438</p>
      <p> 8439 if (rip-&gt;i_dirt == DIRTY) rw_inode(rip, WRITING);</p>
      <p> 8440 }</p>
      <p> 8441 }</p>
      <p> 8443 /»="""= = : = = = :== = "= = ::""=: = == = ===: === = ==="="=="=== = === = =""""=== ==*</p>
      <p> 8444 * alloc_inode *</p>
      <p> 8445 #===========================================================================*/</p>
      <p> 8446 PUBLIC struct inode *alloc_inode(dev, bits)</p>
      <p> 8447 dev_nr dev; /* device on which to allocate the inode */</p>
      <p> 8448 mask_bits bits; /* mode of the inode */</p>
      <p> MIN1X SOURCE CODE</p>
      <p> File: fs/inode.c</p>
      <p> 603</p>
      <p> 8450 /* Allocate a free inode on 'dev', and return a pointer to it. #/ 8451</p>
      <p> 8452 register struct inode *rip;</p>
      <p> 8453 register struct super_block *sp;</p>
      <p> 8454 int major, minor;</p>
      <p> 8455 inode_nr numb;</p>
      <p> 8456 bit_nr b;</p>
      <p> 8457 extern bit_nr alloc_bit();</p>
      <p> 8458 extern struct inode #get_inode();</p>
      <p> 8459 extern struct super_block *get_super(); 8460</p>
      <p> 8461 /* Acquire an inode from the bit map. #/</p>
      <p> 8462 sp = get_super(dev); /* get pointer to super_block */</p>
      <p> 8463 b=alloc_bit(sp-&gt;s_imap, (bit_nr)sp-&gt;s_ninodes+l, sp-&gt;s_imap_blocks,(bit_nr)0);</p>
      <p> 8464 if (b == N0_BIT) {</p>
      <p> 8465 err_code = ENFILE;</p>
      <p> 8466 major = (int) (sp-&gt;s_dev » MAJOR) 4 BYTE;</p>
      <p> 8467 minor = (int) (sp-&gt;s_dev &gt;&gt; MINOR) 4 BYTE;</p>
      <p> 8468 if (sp-&gt;s_dev == RO0T_DEV)</p>
      <p> 8469 printfC'Out of i-nodes on root device (RAM disk)\n");</p>
      <p> 8470 else</p>
      <p> 8471 printfC'Out of i-nodes on device  %d/'M\n",  major, minor);</p>
      <p> 8472 return(NIL_INODE);</p>
      <p> 8473 }</p>
      <p> 8474 numb = (inode_nr) b; 8475</p>
      <p> 8476 /* Try to acquire a slot in the inode table. */</p>
      <p> 8477 if ( (rip = get_inode(NO_DEV, numb))      Nil INODE) {</p>
      <p> 8478 /* No inode table slots available.   Free the inode just allocated. */</p>
      <p> 8479 free_bit(sp-&gt;s_imap, b);</p>
      <p> 8480 } else {</p>
      <p> 8481 /* An inode slot is available.    Put the inode just allocated into it. */</p>
      <p> 8482 rip-&gt;i_mode = bits;</p>
      <p> 8483 rip-&gt;i_nlinks = (links) 0;</p>
      <p> 8484 rip-&gt;i_uid = fp-&gt;fp_effuid;</p>
      <p> 8485 rip-&gt;i_gid = fp-&gt;fp_effgid;</p>
      <p> 8486 rip-&gt;i_dev = dev; /* was provisionally set to N0_DEV */ 8487</p>
      <p> 8^88 /♦ The fields not cleared already are cleared in wipe_inode().    They have</p>
      <p> 8489 * been put there because truncateO needs to clear the same fields if</p>
      <p> 8490 * the file happens to be open while being truncated.   It saves space</p>
      <p> 8491 * not to repeat the code twice.</p>
      <p> 8492 */</p>
      <p> 8493 wipe_inode(rip);</p>
      <p> 8494 } 8495</p>
      <p> 8496 return(rip);</p>
      <p> 604 File: fs/inode.c MINIX SOURCE CODE</p>
      <p> 8500 /*==============================================-============================*</p>
      <p> 8501 * wipe_inode *</p>
      <p> 8503 PUBLIC wipe_inode(rip)</p>
      <p> 8504 register struct inode *rip; /* The inode to be erased. */</p>
      <p> 8505 {</p>
      <p> 8506 /# Erase some fields in the inode.    This function is called from alloc_inode()</p>
      <p> 8507 * when a new inode is to be allocated, and from truncateO, when an existing</p>
      <p> 8508 * inode is to be truncated.</p>
      <p> 8509 */ 8510</p>
      <p> 8511 register int i;</p>
      <p> 8512 extern real_time clock_time(); 8513</p>
      <p> 8514 rip-&gt;i_size = 0;</p>
      <p> 8515 rip-&gt;i_modtime = clock_time();</p>
      <p> 8516 rip-&gt;i_dirt = DIRTY;</p>
      <p> 8517 for (i = 0; i &lt; NR_Z0NE_NUMS; i++)</p>
      <p> 8518 rip-&gt;i_zone[i] = N0_Z0NE;</p>
      <p> 8519 }</p>
      <p> 8522</p>
      <p> 8523 * free_inode *</p>
      <p> 8524 »=======:======:========:======:::===::==:====:===:=====================::==»/</p>
      <p> 8525 PUBLIC free_inode(dev, numb)</p>
      <p> 8526 dev_nr dev; /* on which device is the inode */</p>
      <p> 8527 inode_nr numb; /* number of inode to be freed */</p>
      <p> 8528 {</p>
      <p> 8529 /* Return an inode to the pool of unallocated inodes. ♦/ 8530</p>
      <p> 8531 register struct super_block *sp;</p>
      <p> 8532 extern struct super_block #get_super(); 8533</p>
      <p> 8534 /* Locate the appropriate super_block. */</p>
      <p> 8535 sp = get_super(dev);</p>
      <p> 8536 ' free_bit(sp-&gt;s_imap, (bit_nr) numb);</p>
      <p> 8537 }</p>
      <p> 8540 /*===========================================================================*</p>
      <p> 8541 * rw_inode *</p>
      <p> 8542 *===========================================================================*/</p>
      <p> 8543 PUBLIC rw_inode(rip, rw_flag)</p>
      <p> 8544 register struct inode #rip; /# pointer to inode to be read/written */</p>
      <p> 8545 int rw_flag; A READING or WRITING */</p>
      <p> 8546 {</p>
      <p> 8547 /* An entry in the inode table is to be copied to or from the disk. */ 8548</p>
      <p> 8549 register struct buf *bp;</p>
      <p> MIMX SOURCE CODE</p>
      <p> File: fs/inode.c</p>
      <p> 605</p>
      <p> 8550 register d_inode *dip;</p>
      <p> 8551 register struct super_block *sp; 855,? block_nr b;</p>
      <p> 8553 extern struct buf *get_block();</p>
      <p> 8554 extern struct super_block *get_super(); 8555</p>
      <p> 855(S  /*  Get the block where the inode resides. */</p>
      <p> 8557 sp = get_super(rip-&gt;i_dev);</p>
      <p> 85513 b = (block_nr) (rip-&gt;i_num - 1)/IN0DES_PER_BL0CK +</p>
      <p> 855 '' sp-&gt;s_imap_blocks + sp-&gt;s_zmap_blocks + 2;</p>
      <p> 8560 bp = get_block(rip-&gt;i_dev, b, NORMAL);</p>
      <p> 8561 dip = bp-&gt;b_inode + (rip-&gt;i_num - 1)  %  INODES_PER_BLOCK; 8562</p>
      <p> 8563 /* Do the read or write. */</p>
      <p> 8564 if (rw_flag == READING) {</p>
      <p> 856 '&gt; copy((char #)rip, (char #) dip, INODE_SIZE); /* copy from blk to inode */</p>
      <p> 8566 } else {</p>
      <p> 8567  copy((char *)dip, (char *) rip, INODE_SIZE); /* copy from inode to blk #/ 85613 bp-&gt;b_dirt = DIRTY;</p>
      <p> 8569 } 8570</p>
      <p> 8571 put_block(bp, IN0DE_BL0CK);</p>
      <p> 8572 rip-&gt;i_dirt = CLEAN;</p>
      <p> 8573 }</p>
      <p> 8576 7* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = =: = = = = = = = = = = = = =: = = = = = = = ^ = *</p>
      <p> 857 7        * dup_inode *</p>
      <p> 857(3 *=============================================================== ============ */</p>
      <p> 8579 PUBLIC dup_inode(ip)</p>
      <p> 8580 struct inode *ip; /* The inode to be duplicated. */</p>
      <p> 8581 {</p>
      <p> 858,'.' /# This routine is a simplified form of get_inode() for the case where</p>
      <p> 8583 * the inode pointer is already known.</p>
      <p> 8584 */ 8585</p>
      <p> 8586 ip-&gt;i_count++;</p>
      <p> 606 Pile: fs/super.c MINIX SOURCE CODE</p>
      <p> 8600 /* This file manages the super block table and the related data structures,</p>
      <p> 8601 * namely, the bit maps that keep track of which zones and which inodes are</p>
      <p> 8602 * allocated and which are free.   When a new inode or zone is needed, the</p>
      <p> 8603 * appropriate bit map is searched for a free entry.</p>
      <p> 8604 *</p>
      <p> 8605 * The entry points into this file are</p>
      <p> 8606 *     load_bit_maps:     get the bit maps for the root or a newly mounted device</p>
      <p> 8607 *     unload_bit_maps: write the bit maps back to disk after an UM0UNT</p>
      <p> 8608 #     alloc_bit: somebody wants to allocate a zone or inode; find one</p>
      <p> 8609 #     free_bit: indicate that a zone or inode is available for allocation</p>
      <p> 8610 *    get_super: search the 'superblock' table for a device</p>
      <p> 8611 *    mounted: tells if file inode is on mounted (or ROOT) file system</p>
      <p> 8612 *     scale_factor:      get the zone-to-block conversion factor for a device</p>
      <p> 8613 *     rw_supert read or write a superblock</p>
      <p> 8614 */ 8615</p>
      <p> 8616 ^include "../h/const.h"</p>
      <p> 8617 ^include "../h/type.h"</p>
      <p> 8618 ^include "../h/error.h"</p>
      <p> 8619 ^include "const.h"</p>
      <p> 8620 ^include "type.h"</p>
      <p> 8621 ^include "buf.h"</p>
      <p> 8622 ^include "inode.h"</p>
      <p> 8623 ^include "super.h" 8624</p>
      <p> 8625 ^define INT_BITS (sizeof(int)«3)</p>
      <p> 8626 ^define BIT_MAP_SHIFT 13 /* (log2 of BL0CK_SIZE) + 3; 13 for lk blocks */ 8627</p>
      <p> 8629 * load_bit_maps *</p>
      <p> 8630 *===========================================================================*/</p>
      <p> 8631 PUBLIC int load_bit_maps(dev)</p>
      <p> 8632 dev_nr dev; /* which device? */</p>
      <p> 8633 {</p>
      <p> 8634 /* Load the bit map for some device into the cache and set up superblock. */ 8635</p>
      <p> 8636 register int i;</p>
      <p> 8637 register struct super_block *sp;</p>
      <p> 8638 block_nr zbase;</p>
      <p> 8639 extern struct buf #get_block();</p>
      <p> 8640 extern struct super_block *get_super(); 8641</p>
      <p> 8642 sp = get_super(dev); /* get the superblock pointer */</p>
      <p> 8643 if (bufs_in_use + sp-&gt;s_imap_blocks + sp-&gt;s„zmap_blocks &gt;= NR_BUFS - 3)</p>
      <p> 8644 return(ERROR); /* insufficient buffers left for bit maps */</p>
      <p> 8645 if (sp-&gt;s_imap_blocks &gt; I_MAP_5L0TS || sp-&gt;s_zmap_blocks &gt; ZMAP_SL0T5)</p>
      <p> 8646 panicC'too many map blocks", N0_NUM); 8647</p>
      <p> 8648 /* Load the inode map from the disk. */</p>
      <p> 8649 for (i = 0; i &lt; sp-&gt;s_imap_blocks; i++)</p>
      <p> MIN1X SOURCE CODE</p>
      <p> File: fs/super.c</p>
      <p> 607</p>
      <p> 8650 sp-&gt;s_imap[i] = get_block(dev, SUPCR_BL0CK + 1 + i, NORMAL); 8651</p>
      <p> 8652 /♦ Load the zone map from the disk. #/</p>
      <p> 8653 zbase = SUPER_BL0CK + 1 + sp-&gt;s_imap_blocks;</p>
      <p> 8654 for (i = 0; i &lt; sp-&gt;s_zmap_blocks; i++)</p>
      <p> 8655 sp-&gt;s_zmap[i] = get_block(dev, zbase + i, NORMAL); 8656</p>
      <p> 8657 /* inodes 0 and 1, and zone 0 are never allocated.   Mark them as busy. */</p>
      <p> 8656 sp-&gt;s_imap[0]-&gt;b_int[0]  1= 3; /♦ inodes 0, 1 busy #/ 8655' sp-&gt;s_zmap[0]-&gt;b_int[0]  |= 1; /* zone 0 busy */</p>
      <p> 8660 bufs_in_use += sp-&gt;s_imap_blocks + sp-&gt;s_zmap_blocks;</p>
      <p> 8661 return(OK);</p>
      <p> 8662 }</p>
      <p> 8666 8667 8666 8669 8670 8671 8672 8673 867^ 8675 8676 8677 8676 8679 8680 8681 8682: 8683</p>
      <p> /*======</p>
      <p> *</p>
      <p> unload_bit_maps</p>
      <p> PUBLIC unload_bit_maps(dev) dev_nr dev; {</p>
      <p> /* Unload the bit maps so a device can be unmounted. */</p>
      <p> /* which device is being unmounted? */</p>
      <p> register int i;</p>
      <p> register struct super_block *sp; struct super_block *get_super();</p>
      <p> sp = get_super(dev); ,  =</p>
      <p> bufs_in_use -= sp-&gt;s_imap_blocks + for (i = 0; i &lt; sp-&gt;s_imap_blocks; for (i = 0; i &lt; sp-&gt;s_zmap_blocks; return(OK);</p>
      <p> /* get the superblock pointer */ sp-&gt;s_zmap_blocks; i++) put_block(sp-&gt;s_imap[i] i++) put_block(sp-&gt;s_zmap[i]</p>
      <p> I_MAP_BL0CK); ZMAP_BL0CK);</p>
      <p> 8686 8687 8686 8689 8690 8691 8692: 8693 8694 8695 8696 8697 869EI 8699</p>
      <p> alloc_bit</p>
      <p> PUBLIC bit_nr alloc_bit(map_ptr, map_bits, bit_blocks, origin) struct buf *map_ptr[]; /* pointer to array of bit block pointers */</p>
      <p> /* how many bits are there in the bit map? */ /# how many blocks are there in the bit map? */ /* number of bit to start searching at */</p>
      <p> bit_nr map_bits; unshort bit_blocks; bit_nr origin;</p>
      <p> /* Allocate a bit from</p>
      <p> a bit map and return its bit number. */</p>
      <p> register unsigned k;</p>
      <p> register int *wptr, *wlim;</p>
      <p> int i, a, b, w. o, block_count:</p>
      <p> 608 File: fs/super.c MINIX SOURCE CODE</p>
      <p> 8700 struct buf *bp;</p>
      <p> 8701</p>
      <p> 8702 /* Figure out where to start the bit search (depends on 'origin'). */</p>
      <p> 8703 if (origin &gt;= map_bits) origin = 0;     /* for robustness */</p>
      <p> 8704 b = origin &gt;&gt; BIT_MAP_SHIFT;</p>
      <p> 8705 o = origin - (b &lt;&lt; BIT_MAP_SHIFT);</p>
      <p> 8706 w = o/INT_BITS;</p>
      <p> 8707 block_count = (w == 0 ? bit_blocks : bit_blocks +1); 8708</p>
      <p> 8709 /* The outer while loop iterates on the blocks of the map.    The inner</p>
      <p> 8710 * while loop iterates on the words of a block.    The for loop iterates</p>
      <p> 8711 * on the bits of a word.</p>
      <p> 8712 */</p>
      <p> 8713 while (block_count--) {</p>
      <p> 8714 /* If need be, loop on all the blocks in the bit map. */</p>
      <p> 8715 bp = map_ptr[b];</p>
      <p> 8716 wptr = &amp;bp-&gt;b_int[w];</p>
      <p> 8717 wlim = &amp;bp-&gt;b_int[INTS_PER_BL0CK];</p>
      <p> 8718 while (wptr != wlim) {</p>
      <p> 8719 /* Loop on all the words of one of the bit map blocks. */</p>
      <p> 8720 if ((k = (unsigned) *wptr)  != (unsigned) ~0) {</p>
      <p> 8721 /* This word contains a free bit.   Allocate it. */</p>
      <p> 8722 for (i = 0; i &lt; INT_BIT5; i++)</p>
      <p> 8723 if (((•&lt; » i) &amp; D == °) f</p>
      <p> 8724 a = i + (wptr - &amp;bp-&gt;b_int[0])*INT_BITS</p>
      <p> 87 25 + (b « BIT_MAP_SHIFT);</p>
      <p> 8726 /* !f ' a ' beyond map check other blks*/</p>
      <p> 8727 if (a &gt;= map_bits) {</p>
      <p> 8728 wptr = wlim - 1;</p>
      <p> 8729 break;</p>
      <p> 8730 )</p>
      <p> 8731 *wptr |= 1 «  i;</p>
      <p> 8732 bp-&gt;b._dirt = DIRTY;</p>
      <p> 8733 return( (bit_nr) a);</p>
      <p> 8734 }</p>
      <p> 8735 }</p>
      <p> 8736 wptr++; /* examine next word in this bit map block */</p>
      <p> 8737 }</p>
      <p> 8738 if (++b == bit_blocks) b = 0;     /* we have wrapped around */</p>
      <p> 8739 w = 0;</p>
      <p> 8740 }</p>
      <p> 8741 return(N0_BIT); /* no bit could be allocated */</p>
      <p> 8742 }</p>
      <p> 8745 * free_bit *</p>
      <p> 8746 *=========================================== ================================*/</p>
      <p> 8747 PUBLIC free_bit(map_ptr, bit_returned)</p>
      <p> 8748 struct buf *map_ptr[]; /* pointer to array of bit block pointers */</p>
      <p> 8749 bit_nr bit_returned; /* number of bit to insert into the map */</p>
      <p> j</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/super.c</p>
      <p> 609</p>
      <p> 8750 {</p>
      <p> 8751 /* Return a zone or inode by turning off its bitmap bit. */ 8757</p>
      <p> 875.3 int b, r, w, bit;</p>
      <p> 875&gt;4 struct buf *bp; 875.5</p>
      <p> 875&gt;6 b = bit_returned » BIT_MAP_SHIFT;      /* 'b' tells which block it is in */</p>
      <p> 8757 r = bit_returned - (b &lt;&lt; BIT_MAP_SHIFT);</p>
      <p> 8738 w = r/INT_BITS;  /*  'w' tells which word it is in */</p>
      <p> 8739 bit = r  1i  INT_BITS;</p>
      <p> 8760 bp = map_ptr[b];</p>
      <p> 8761 if (((bp-&gt;b_int[w] » bit)4 1)== 0)</p>
      <p> 8762 panic("trying to free unused block--check file sys",  (int)bit_returned);</p>
      <p> 8763 bp-&gt;b_int[w] &amp;= "(1 &lt;&lt; bit);    /* turn the bit off */</p>
      <p> 8764 bp-&gt;b_dirt = DIRTY;</p>
      <p> 8765 }</p>
      <p> 8768</p>
      <p> 8769 * get_super *</p>
      <p> 87 70 *= = = = = = =  =   ::  = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = r ===========================*/</p>
      <p> 8771 PUBLIC struct super_block *get_super(dev)</p>
      <p> 8772 dev_nr dev; /* device number whose super_block is sought */</p>
      <p> 8773 {</p>
      <p> 8774 /* Search the superblock table for this device. It is supposed to be there. */ 8775</p>
      <p> 8776 register struct super_block *sp;</p>
      <p> 8777</p>
      <p> 8778 for (sp = &amp;super_block[0]; sp &lt; &amp;super_block[NR_SUPERS] ; sp++)</p>
      <p> 8779 if (sp-&gt;s_dev == dev) return(sp); 8780</p>
      <p> 8781 /* Search failed.    Something wrong. #/</p>
      <p> 8782 panicC'can't find superblock for device",  (int) dev);</p>
      <p> 8783 }</p>
      <p> 8786 /*= = = = = = = r = = = = = = = = = = = = = = = = = = = =: = = = =:=: = = = = == = = = = = = = = =  =   =   =   =   =  = =  =   =  = = = =  =   =   =  =  =  =  =   =   =  =  =   =   =  = *</p>
      <p> 8787 * mounted *</p>
      <p> 8788 *= = = = = = = = = = - = = = = = . = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = - = = = = = = = =:*/</p>
      <p> 8789 PUBLIC int mounted(rip)</p>
      <p> 8790 register struct inode *rip; /* pointer to inode */</p>
      <p> 8791 {</p>
      <p> 8792 /* Report on whether the given inode is on a mounted (or ROOT) file system. #/ 8793</p>
      <p> 8794 register struct super_block *sp;</p>
      <p> 8795 register dev_nr dev; 87 96</p>
      <p> 8797 dev = rip-&gt;i_dev;</p>
      <p> 8798 if (dev == R00T_DEV) return(TRUE);       /* inode is on root file system */ 8799</p>
      <p> 8800 for (sp = &amp;super_block[0]; sp &lt; &amp;super_block[NR_SUPERS]; sp++)</p>
      <p> 8801 if (sp-&gt;s_dev == dev) return(TRUE); 8802</p>
      <p> 8803 return(FALSE);</p>
      <p> 8804 }</p>
      <p> 8807 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =     = = = = = = = = = = = = =   = = = = = = = = = = = = = = = = *</p>
      <p> 8808 * scale_factor *</p>
      <p> 8810 PUBLIC int scale_factor(ip) *</p>
      <p> 8811 struct inode *ip; /* pointer to inode whose superblock needed */</p>
      <p> 8812 {</p>
      <p> 8813 /* Return the scale factor used for converting blocks to zones. */</p>
      <p> 8814 register struct super_block #sp;</p>
      <p> 8815 extern struct super_block *get_super(); 8816</p>
      <p> 8817 sp = get_super(ip-&gt;i_dev);</p>
      <p> 8818 return(sp-&gt;s_log_zone_size);</p>
      <p> 8819 }</p>
      <p> 8822 *                                              rw_super #</p>
      <p> 8823</p>
      <p> 8824 PUBLIC rw_super(sp, rw_flag)</p>
      <p> 8825 register struct super_block *sp; /* pointer to a superblock */</p>
      <p> 8826 int rw_flag; /* READING or WRITING */</p>
      <p> 8827 {</p>
      <p> 8828 /* Read or write a superblock. */ 8829</p>
      <p> 8830 register struct buf *bp;</p>
      <p> 8831 dev_nr dev;</p>
      <p> 8832 extern struct buf #get_block(); 8833</p>
      <p> 8834 /* Check if this is a read or write, and do it. */</p>
      <p> 8835 if (rw_flag == READING) {</p>
      <p> 8836 dev = sp-&gt;s_dev; /* save device; it will be overwritten by copy*/</p>
      <p> 8837 bp = get_block(sp-&gt;s_dev, (block_nr) SUPER_BL0CK, NORMAL);</p>
      <p> 8838 copy( (char *) sp, bp-&gt;b_data, 5UPER_SIZE);</p>
      <p> 8839 sp-&gt;s_dev = dev; /# restore device number ♦/</p>
      <p> 8840 } else {</p>
      <p> 8841 /* On a write, it is not necessary to go read superblock from disk. */</p>
      <p> 8842 bp = get_block(sp-&gt;s_dev, (block_nr) SUPER_BL0CK, N0_READ);</p>
      <p> 8843 copy(bp-&gt;b_data, (char *) sp, SUPER_SIZE);</p>
      <p> 8844 bp-&gt;b_dirt = DIRTY;</p>
      <p> 8845 } 8846</p>
      <p> 8847 sp-&gt;s_dirt = CLEAN;</p>
      <p> 8848 put_block(bp, ZUPER_BL0CK);</p>
      <p> 8849 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/filedes.c</p>
      <p> 611</p>
      <p> 8850 /* This file contains the procedures that manipulate file descriptors.</p>
      <p> 8851 *</p>
      <p> 8852 * The entry points into this file are</p>
      <p> 8853 *     get_fd:      look for free file descriptor and free filp slots</p>
      <p> 8854 *     get_filp:    look up the filp entry for a given file descriptor</p>
      <p> 8855 *     find_filp: find a filp slot that points to a given inode</p>
      <p> 8856 */ 8857</p>
      <p> 8858 ^include "../h/const.h"</p>
      <p> 8859 ifinclude ". ./h/type.h"</p>
      <p> 8860 ^include ".,/h/error.h"</p>
      <p> 8861 ^include "const.h"</p>
      <p> 8862 ^/include "type.h"</p>
      <p> 8863 ^include "file.h"</p>
      <p> 8864 ^include "fproc.h"</p>
      <p> 8865 ^include "glo.h"</p>
      <p> 8866 ^include "inode.h" 8867</p>
      <p> 886 8 /*===========================================================================*</p>
      <p> 8869 * get_fd *</p>
      <p> 8870</p>
      <p> 8871 PUBLIC int get_fd(bits, k, fpt)</p>
      <p> 8872 mask_bits bits; /* mode of the file to be created (RWX bits) */</p>
      <p> 8873 int *k; /* place to return file descriptor */</p>
      <p> 8874 struct filp ##fpt; /# place to return filp slot #/</p>
      <p> 8875 {</p>
      <p> 8876 /* Look for a free file descriptor and a free filp slot.    Fill in the mode word</p>
      <p> 8877 * in the latter, but don't claim either one yet, since the open() or creat()</p>
      <p> 8878 * may yet fail.</p>
      <p> 8879 */ 8880</p>
      <p> 8881 register struct filp *f;</p>
      <p> 8882 register int i; 8883</p>
      <p> 8884 *k = -1; /* we need a way to tell if file desc found */</p>
      <p> 8885</p>
      <p> 8886 /* Search the fproc table for a free file descriptor. */</p>
      <p> 8887 for (1 = 0; i &lt; NR_FDS; i++) {</p>
      <p> 8888 if (fp-&gt;fp_filp[i] == NIL_FILP) {</p>
      <p> 8889 /* A file descriptor has been located. */</p>
      <p> 8890 *k = i;</p>
      <p> 8891 break;</p>
      <p> 8892 }</p>
      <p> 8893 } 8894</p>
      <p> 8895 /* Check to see if a file descriptor has been found. */</p>
      <p> 8896 if Ok &lt; 0) return(EMFILE);     /* this is why we initialized k to -1 */ 8897</p>
      <p> 8898 /* Now that a file descriptor has been found, look for a free filp slot. */</p>
      <p> 8899 for (f = &amp;filp[0]; f &lt; &amp;filp[NR_FILPS]; f++) {</p>
      <p> 612 File: fs/filedes.c MINIX SOURCE CODE</p>
      <p> 8900 if (f-&gt;filp_count == 0) {</p>
      <p> 8901 f-&gt;filp_mode = bits;</p>
      <p> 8902 f-&gt;filp_pos = OLj</p>
      <p> 8903 *fpt = f;</p>
      <p> 8904 return(OK);</p>
      <p> 8905 }</p>
      <p> 8906 } 8907</p>
      <p> 8908 /* If control passes here, the filp table must be full.    Report that back. */</p>
      <p> 8909 return(ENFILE);</p>
      <p> 8910 }</p>
      <p> 8914 * get_filp *</p>
      <p> 8915 *===========================================================================♦/</p>
      <p> 8916 PUBLIC struct filp *get_filp(fild)</p>
      <p> 8917 int fild; /* file descriptor */</p>
      <p> 8918 {</p>
      <p> 8919 /* See if 'fild' refers to a valid file descr. If so, return its filp ptr. */ 8920</p>
      <p> 8921 err_code = EBADF;</p>
      <p> 8922 if (fild &lt; 0 || fild &gt;= NR_FDS ) return(NIL_FILP);</p>
      <p> 8923 return(fp-&gt;fp_filp[fild]);       /* may also be NIL_FILP #/</p>
      <p> 8924 }</p>
      <p> 8927 /♦ = r = = = = = = = = = = =: = = : = = = = = = = : = = = = = : = = = = = = = = = = = r = = :: = = = = = = = = = = = =: = = = =: = = = = = = = = = = = = = = *</p>
      <p> 8928 * find_filp *</p>
      <p> 8929 * = = = = = = = = = = = = = = = r = = = = r = = c = = = = = = = r = = = = = = = = =:=: = = =: =  : : = = = = = = = = = = = = = = = = = = = = = = : = = = = = */</p>
      <p> 8930 PUBLIC struct filp *find_filp(rip, bits)</p>
      <p> 8931 register struct inode *rip;        /* inode referred to by the filp to be found */</p>
      <p> 8932 int bits; /♦ mode of the filp to be found (RWX bits) »/</p>
      <p> 8933 {</p>
      <p> 8934 /# Find a filp slot that refers to the inode 'rip' in a way as described</p>
      <p> 8935 * by the mode bit 'bits'. Used for determining whether somebody is still</p>
      <p> 8936  *  interested in either end of a pipe; other applications are conceivable.</p>
      <p> 8937 * Like 'get_fd' it performs its job by linear search through the filp table.</p>
      <p> 8938 */ 8939</p>
      <p> 8940 register struct filp *f;</p>
      <p> 8941</p>
      <p> 8942 for (f = 4filp[0]; f &lt; &amp;filp[NR_FILPS]; f++) {</p>
      <p> 8943 if (f-&gt;filp_count '.= 0 &amp;&amp; f-&gt;filp_ino == rip &amp;&amp; (f-&gt;filp_mode &amp; bits))</p>
      <p> 8944 return(f);</p>
      <p> 8945 } 8946</p>
      <p> 8947 /* If control passes here, the filp wasn't there.    Report that back. */</p>
      <p> 8948 return(NIL_FILP);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/main.c</p>
      <p> 613</p>
      <p> 8950 /* This file contains the main program of the File System.    It consists of</p>
      <p> 8951 * a loop that gets messages requesting work, carries out the work, and sends</p>
      <p> 8952 * replies.</p>
      <p> 8953 *</p>
      <p> 8954 * The entry points into this file are</p>
      <p> 8955 *     main: main program of the File System</p>
      <p> 8956 *     reply:        send a reply to a process after the requested work is done</p>
      <p> 8957 */ 8958</p>
      <p> 8959 ^include "../h/const.h"</p>
      <p> 8960 ^include "../h/type.h"</p>
      <p> 8961 ^include "../h/callnr.h"</p>
      <p> 8962 ^include ".,/h/com.h"</p>
      <p> 8963 ^include "../h/error.h"</p>
      <p> 8964 ^include "const.h"</p>
      <p> 8965 ^include "type.h"</p>
      <p> 8966 ^include "buf.h"</p>
      <p> 8967 ^include "file.h"</p>
      <p> 8968 ^include "fproc.h"</p>
      <p> 8969 ^include "glo.h" 89"'0 ^include "inode.h" 89''l ^include "param.h" 8972 ^include "super.h" 8973</p>
      <p> 8974 ^define M64K        OxFFFFOOOOL      /* 16 bit mask for DMA check */</p>
      <p> 8975 ^define INFO 2      /* where in data_org is info from build  */ 8976</p>
      <p> 8977 /*===========================================================================♦</p>
      <p> 8978 * main *</p>
      <p> 8979 *===========================================================================*/</p>
      <p> 8930 PUBLIC mainO</p>
      <p> 89131 {</p>
      <p> 8932 /* This is the main program of the file system.    The main loop consists of</p>
      <p> 8933 * three major activities: getting new work, processing the work, and sending</p>
      <p> 8934 * the reply.    This loop never terminates as long as the file system runs.</p>
      <p> 8935 */</p>
      <p> 8936 int error;</p>
      <p> 8937 extern int (*call_vector[NCALLS]) (); 89B8</p>
      <p> 89B9 fs_init(); 8990</p>
      <p> 8991 /* This is the main loop that gets work, processes it, and sends replies. */</p>
      <p> 8992 while (TRUE) {</p>
      <p> 8993 get_work(); /* sets who and fs_call */ 8994</p>
      <p> 8995 fp = &amp;fproc[who];  I*  pointer to proc table struct */</p>
      <p> 8996 super_user = (fp-&gt;fp_effuid == SUJJID ? TRUE : FALSE);     /* su? */</p>
      <p> 8997 dont_reply = FALSE;        /* in other words, do reply is default */ 8998</p>
      <p> 8999 /* Call the internal function that does the work. */</p>
      <p> 614 File: fs/main.c MINIX SOURCE CODE</p>
      <p> 9000 if (fs_call &lt; 0 || fs_call &gt;= NCALLS)</p>
      <p> 9001 error = E_BAD_CALL;</p>
      <p> 9002 else</p>
      <p> 9003 error = (*call_vector[fs.call])(); 9004</p>
      <p> 9005 /* Copy the results back to the user and send reply. */</p>
      <p> 9006 if (dont_reply) continue;</p>
      <p> 9007 reply(who, error);</p>
      <p> 9008 if (rdahed_inode != NIL_IN00E) read_ahead(); /* do block read ahead */</p>
      <p> 9009 }</p>
      <p> 9010 }</p>
      <p> 9013 /* = r = = = = = z = = = = = = = =: = = = = = = = = = :: = = = = = = = = = = = - = = r = =  ::  = = = = = = = = = = -r = = = = r = = = = = = = = r = = = = *</p>
      <p> 9014 * get_work *</p>
      <p> 9015 «===: : =:= :::: : ; : ====:"r= ::: ==:= :: == :: : : :=:i = : : : : == = : = = " :: := = = :: = = :::: :  = = = =  f /</p>
      <p> 9016 PRIVATE get_work()</p>
      <p> 9017 {</p>
      <p> 9018 /* Normally wait for new input.   However, if 'reviving' is</p>
      <p> 9019 * nonzero, a suspended process must be awakened.</p>
      <p> 9020 */ 9021</p>
      <p> 9022 register struct fproc *rp; 9023</p>
      <p> 9024 if (reviving != 0) {</p>
      <p> 9025 /* Revive a suspended process. */</p>
      <p> 9026 for (rp = &amp;fproc[0]; rp &lt; &amp;fproc[NR_PR0CS]; rp++)</p>
      <p> 9027 if (rp-&gt;fp_revived — REVIVING) {</p>
      <p> 9028 who = rp - fproc;</p>
      <p> 9029 fs.call = rp-&gt;fp_fd &amp; BYTE;</p>
      <p> 9030 fd = (rp-&gt;fp_fd »8) &amp; BYTE;</p>
      <p> 9031 buffer = rp-&gt;fp_buffer;</p>
      <p> 9032 nbytes = rp-&gt;fp_nbytes;</p>
      <p> 9033 rp-&gt;fp_suspended = N0T..SUSPENDED; /* no longer hanging*/</p>
      <p> 9034 rp-&gt;fp_revived = N0T_REVIVING;</p>
      <p> 9035 reviving—;</p>
      <p> 9036 return;</p>
      <p> 9037 }</p>
      <p> 9038 panic("get_work couldn't revive anyone", N0_NUM);</p>
      <p> 9039 } 9040</p>
      <p> 9041 /* Normal case.   No one to revive. */</p>
      <p> 9042 if (receive(ANY, 4m) != OK) panicC'fs receive error", N0_NUM); 9043</p>
      <p> 9044 who = m.m_source;</p>
      <p> 9045 fs_call = m.m_type;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/main.c</p>
      <p> 615</p>
      <p> 9050 /*= = = = = = = = = = = = = - = = = = = = = = = = = =:- = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 9051 * reply *</p>
      <p> 905;:</p>
      <p> 905."i PUBLIC reply(whom, result)</p>
      <p> 9054 int whom; /* process to reply to */</p>
      <p> 9055 int result; /* result of the call (usually OK or error  H) */ 905&lt;&gt; {</p>
      <p> 905 7  /* Send a reply to a user process. It may fail (if the process has just</p>
      <p> 9050 * been killed by a signal), so don't check the return code.    If the send</p>
      <p> 9059 * fails, just ignore it.</p>
      <p> 9060 */ 906.1</p>
      <p> 906!! reply_type = result;</p>
      <p> 906:5 send(whom, &amp;ml);</p>
      <p> 9064 }</p>
      <p> 9067 * fs_init *</p>
      <p> 9068 * = = = = = = = = r = = = = = = = = = = = =  =   =   =   =  = = = = =  =   =   =   =   =   =   =   =   =  : : -  =   =  —= = "- -========================*/</p>
      <p> 9069 PRIVATE fs_init()</p>
      <p> 9070 {</p>
      <p> 9071 /* Initialize global variables, tables, etc. */ 9072</p>
      <p> 9073 register struct inode *rip;</p>
      <p> 9074 int i;</p>
      <p> 9073 extern struct inode *get_inode(); 9076</p>
      <p> 9077 buf_pool();                                 /* initialize buffer pool */</p>
      <p> 9073 load_ram();                               /* Load RAM disk from root diskette. */</p>
      <p> 9079 load_super();                            /* Load super block for root device */</p>
      <p> 9080</p>
      <p> 9081 /* Initialize the 'fproc' fields for process 0 and process 2. */</p>
      <p> 9082 for (i = 0; i &lt; 3; i+= 2) {</p>
      <p> 9083 fp = &amp;fproc[i];</p>
      <p> 9084 rip = get_inode(R00T_DEV, R00T_IN0DE);</p>
      <p> 9085 fp-&gt;fp_rootdir = rip;</p>
      <p> 9086 dup_inode(rip);</p>
      <p> 9087 fp-&gt;fp_workdir = rip;</p>
      <p> 908B fp-&gt;fp_realuid = (uid) SYS_UID;</p>
      <p> 9089 fp-&gt;fp_effuid = (uid) SYSJJID;</p>
      <p> 9093 fp-&gt;fp_realgid = (gid) 5YS_GID;</p>
      <p> 9091 fp-&gt;fp_effgid = (gid) SYS_GID;</p>
      <p> 9092 fp-&gt;fp_umask = "0;</p>
      <p> 9093 } 9094</p>
      <p> 9095 /* Certain relations must hold for the file system to work at all. */</p>
      <p> 9096 if (Z0NE_NUM_SIZE != 2) panic("Z0NE_NUM_SIZE !=  2",  N0_NUM);</p>
      <p> 9097 if (SUPER_SIZE &gt; BL0CK_SIZE) panic("SUPER_SIZE &gt; BL0CK_SIZE", N0_NUM);</p>
      <p> 9098 if(BL0CK_SIZE  %  IN0DE_5IZE != 0)panic("BL0CK_SIZE  %  IN0DE_SIZE != 0", N0_NUM);</p>
      <p> 9099 if (NR_EDS &gt; 127) panic("NR_FDS &gt; 127", N0_NUM);</p>
      <p> 616 File: fs/main.c MINIX SOURCE CODE</p>
      <p> 9100 if (NR_BUFS &lt; 6) panic("NR_BUFS &lt; 6", N0_NUM);</p>
      <p> 9101 if (sizeof(d_inode) != 32) panicC'inode size != 32", N0_NUM);</p>
      <p> 9102 }</p>
      <p> 9104 /* = = = = = = = = = = = = = = = : = = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = . = = = = = r = = = z = z = =  i; :- = = = = *</p>
      <p> 9105 * buf_pool *</p>
      <p> 9106 * = = = = = = = = =   = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   = = = = = = = = = = = = = = =   = =   = = = = = = = = = = =</p>
      <p> 9107 PRIVATE buf_pool()</p>
      <p> 9108 {</p>
      <p> 9109 /* Initialize the buffer pool.    On the IBM PC, the hardware DMA chip is</p>
      <p> 9110  *  not able to cross 64K boundaries, so any buffer that happens to lie</p>
      <p> 9111 * across such a boundary is not used.    This is not very elegant, but all</p>
      <p> 9112 * the alternative solutions are as bad, if not worse.    The fault lies with</p>
      <p> 9113 * the PC hardware.</p>
      <p> 9114 */</p>
      <p> 9115 register struct buf +bp;</p>
      <p> 9116 vir_bytes low_off, high_off;</p>
      <p> 9117 phys_bytes org;</p>
      <p> 9118 extern phys_clicks get_base(); 9119</p>
      <p> 9120 bufs_in_use = 0;</p>
      <p> 9121 front = &amp;buf[0];</p>
      <p> 9122 rear = &amp;buf[NR_BUFS - l]; 9123</p>
      <p> 9124 for (bp = &amp;buf[0]; bp &lt; &amp;buf[NR_BUFS]; bp++) {</p>
      <p> 9125 bp-&gt;b_blocknr = NCLBL0CK;</p>
      <p> 9126 bp-&gt;b_dev = N0_DEV;</p>
      <p> 9127 bp-&gt;b_next = bp + 1;</p>
      <p> 9128 bp-&gt;b_prev = bp - 1;</p>
      <p> 9129 }</p>
      <p> 9130 buf[0].b_prev = Nil BUF;</p>
      <p> 9131 buf[NR_BUFS - l].b_next = Nil BUF;</p>
      <p> 9132</p>
      <p> 9133 /# Delete any buffers that span a 64K boundary. */</p>
      <p> 9134 #ifdef i8088</p>
      <p> 9135 for (bp = &amp;buf[0]; bp &lt; &amp;buf[NR_BUFS]; bp++) {</p>
      <p> 9136 org = get_base() « CLICK_SHIFT; /* phys addr where FS is +/</p>
      <p> 9137 low_off = (vir_bytes) bp-&gt;b_data;</p>
      <p> 9138 high_off = low_off + BLOCK_SIZE - 1;</p>
      <p> 9139 if (((org + low.off) &amp; M64K)  != ((org + high_off) &amp; M64K)) {</p>
      <p> 9140 if (bp == &amp;buf[0]) {</p>
      <p> 9141 front = &amp;buf[l];</p>
      <p> 9142 buf[l].b_prev = Nil BUF;</p>
      <p> 9143 } else if (bp == 4buf[NR_BUFS - l]) {</p>
      <p> 9144 rear = &amp;buf[NR_BUF5 - 2];</p>
      <p> 9145 buf[NR_BUFS - 2].b_next = Nil BUF;</p>
      <p> 9146 } else {</p>
      <p> 9147 /* Delete a buffer in the middle. */</p>
      <p> 9148 bp-&gt;b_prev-&gt;b_next = bp + 1;</p>
      <p> 9149 bp-&gt;b_next-&gt;b_prev = bp - 1;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/main.c</p>
      <p> 617</p>
      <p> 9150 }</p>
      <p> 9151 }</p>
      <p> 9152 }</p>
      <p> 9153 tfendif 9154</p>
      <p> 9155 for (bp = &amp;buf[0]; bp &lt; &amp;buf[NR_BUFS]; bp++) bp-&gt;b_hash = bp-&gt;b_next;</p>
      <p> 9156 buf_hash[NO_BLOCK &amp; (NR_BUF_HASH - D] = front;</p>
      <p> 9157 }</p>
      <p> 9160 /*r = ===================================================r====================:</p>
      <p> 9161 * load_ram</p>
      <p> 9162 * = = = = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = = = ; = = = = = : = = = ; = = = = = = = = = = = = = = : = = = = = =</p>
      <p> 9163 PRIVATE load_ram()</p>
      <p> 9164 {</p>
      <p> 9165 /* The root diskette contains a block-by-block image of the root file system</p>
      <p> 9166 * starting at 0.    Go get it and copy it to the RAM disk.</p>
      <p> 9167 */ 9168</p>
      <p> 9169 register struct buf *bp, *bpl;</p>
      <p> 9170 int count;</p>
      <p> 9171 long k_loaded;</p>
      <p> 9172 struct super_block *sp;</p>
      <p> 9173 block_nr i;</p>
      <p> 9174 phys_clicks ram_clicks, init_org, init_text_clicks, init_data_clicks;</p>
      <p> 9175 extern phys_clicks data_org[INFO + 2];</p>
      <p> 9176 extern struct buf #get_block();</p>
      <p> 9177</p>
      <p> 9178 /* Get size of INIT by reading block on diskette where 'build' put it. */</p>
      <p> 9179 init_org = data_org[INFO] ;</p>
      <p> 91(10 init_text_clicks = data_org[ INFO + 1];</p>
      <p> 91fil init_data_clicks = data_org[INFO + 2]; 9182</p>
      <p> 9183 /* Get size of RAM disk by reading root file system's super block */</p>
      <p> 9184 bp = get_block(B00T_DEV, SUPER_BL0CK, NORMAL);    /* get RAM super block */</p>
      <p> 9185 copy(super_block, bp-&gt;b_data, sizeof(struct super_block));</p>
      <p> 9186 sp = &amp;super_block[0];</p>
      <p> 9187 if (sp-&gt;s_magic != 5UPER_MAGIC)</p>
      <p> 9188 panicC'Diskette in drive 0 is not root file system", N0_NUM);</p>
      <p> 9189 count = sp-&gt;s_nzones &lt;&lt; sp-&gt;s_log_zone_size;    /*  H  blocks on root dev */</p>
      <p> 9190 ram_clicks = count * (BL0CK_SIZE/CLICK_SIZE);</p>
      <p> 9191 put_block(bp, FULI DATA_BL0CK);</p>
      <p> 9192</p>
      <p> 9193 /* Tell MM the origin and size of INIT, and the amount of memory used for</p>
      <p> 9194 * system plus RAM disk combined, so it can remove all of it from the map.</p>
      <p> 9195 */</p>
      <p> 9196 ml.ro_type  =  BRK2;</p>
      <p> 9197 ml.ml_il = init_text_clicks;</p>
      <p> 9198 ml.ml_i2 = init_data_clicks;</p>
      <p> 9199 ml.ml_i3 = init_org + init_text_clicks + init_data_clicks + ram_clicks;</p>
      <p> 618 File: fs/main.c MINIX SOURCE CODE</p>
      <p> 9200 ml.ml_.pl = (char *) init_.org;</p>
      <p> 9201 if (sendrec(MM_PROC_NR, 4ml) != OK) panicC'FS Can't report to MM", N0_NUM); 9202</p>
      <p> 9203 /* Tell RAM driver where RAM disk is and how big it is. */</p>
      <p> 9204 ml.m_type = DISK_IOCTL;</p>
      <p> 9205 ml.DEVICE = RAM_DEV;</p>
      <p> 9206 ml.POSITION = (long) init_.org + (long) init_text_clicks + init_data_clicks;</p>
      <p> 9207 ml.POSITION = ml.POSITION « CLICK_SHIFT;</p>
      <p> 9208 ml.COUNT - count;</p>
      <p> 9209 if (sendrec(MEM, 4ml) != OK) panicC'Can't report size to MEM", N0_NUM); 9210</p>
      <p> 9211 /* Copy the blocks one at a time from the root diskette to the RAM */</p>
      <p> 9212 printf("Loading RAM disk from root diskette. Loaded:     OK ");</p>
      <p> 9213 for (i = 0; i &lt; count; i++) {</p>
      <p> 9214 bp = get_block(BOOT_DEV, (block_nr) i, NORMAL);</p>
      <p> 9215 bpl - get_block(ROOT_DEV, i, N0_REA0);</p>
      <p> 9216 copy(bpl-&gt;b_data, bp-&gt;b_data, BLOCK_SIZE);</p>
      <p> 9217 bpl-&gt;b_dirt - DIRTY;</p>
      <p> 9218 put_block(bp, I_MAP_BLOCK);</p>
      <p> 9219 put_block(bpl, I_MAP_BLOCK);</p>
      <p> 9220 k_loaded = ( (long) i * BL0CK_SIZE)/1024L; /» K loaded so far */</p>
      <p> 9221 if (k_loaded ! 5 - 0) printf("\b\b\b\b\b*3DK Kc", k_loaded, 0);</p>
      <p> 9222 } 9223</p>
      <p> 9224 printf("\rRAM disk loaded.   Please remove root diskette. \n\n");</p>
      <p> 9225 }</p>
      <p> 9228 /*-____.______=__.-==_=_=___===-===__--=__===_=:=--___-=-===_-=-_=--====__-===*</p>
      <p> 9229 # load_super *</p>
      <p> 9230 *_=_.__=_==_=_===---=_=_._--_==___-_=____-___=-=-==____=-=______----___=-===:*/</p>
      <p> 9231 PRIVATE load_super()</p>
      <p> 9232 {</p>
      <p> 9233 register struct super_block »sp;</p>
      <p> 9234 register struct inode *rip;</p>
      <p> 9235 extern struct inode *get_inode(); 9236</p>
      <p> 9237 /# Initialize the super_block table. ♦/ 9238</p>
      <p> 9239 for (sp - 4super_block[0]; sp &lt; 4super_block[NR_SUPERS]; sp++)</p>
      <p> 9240 sp-&gt;s_dev = N0_DEV; 9241</p>
      <p> 9242 /* Read in super_block for the root file system. */</p>
      <p> 9243 sp = 4super_block[0];</p>
      <p> 9244 sp-&gt;s_dev = R00T_DEV;</p>
      <p> 9245 rw_super(sp,READING);</p>
      <p> 9246 rip = get_inode(ROOT_DEV, R00T_IN0DE); /* inode for root dir */ 9247</p>
      <p> 9248 /* Check super_block for consistency (is it the right diskette?). */</p>
      <p> 9249 if ( (rip-&gt;i_mode 4 I_TYPE) != I-DIRECTORY || rip-&gt;i_nlinks &lt; 3 ||</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/main.c</p>
      <p> 619</p>
      <p> 9250 sp-&gt;s_magic != SUPER_MAGIC)</p>
      <p> 9251 panicC'Root file system corrupted. Possibly wrong diskette.", N0_NUM); 9252</p>
      <p> 9253 sp-&gt;s_imount = rip;</p>
      <p> 9254 dup_inode(rip);</p>
      <p> 9255 sp-&gt;s_isup = rip;</p>
      <p> 9256 sp-&gt;s_rd_only = 0;</p>
      <p> 9257 if (load_bit_maps(R00T_DEV) != OK)</p>
      <p> 9258 panicC'init: can't load root bit maps", NCLNUM);</p>
      <p> File: fs/table.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 9300 9301 9302 9303 9304 9305 9306 9307 9308 9309 9310 9311 9312 9313 9314 9315 9316 9317 9318 9319 9320 9321 9322 9323 9324 9325 9326 9327 9328 9329 9330 9331 9332 9333 9334</p>
      <p> /# This file contains the table used to map system call numbers onto the * routines that perform them. */</p>
      <p> ^include ^include ^include ^include ^include ^include</p>
      <p> ../h/const.h" ../h/type.h" ../h/stat.h" const.h" type.h" dev.h"</p>
      <p> tfundef EXTERN if/define EXTERN</p>
      <p> ^include ^include ^include ^include</p>
      <p> '../h/callnr.h" '. ./h/com.h" '../h/error.h" 'buf.h"</p>
      <p> ^include "file.h" ^include "fproc.h" ^include "glo.h" ^include "inode.h" ^include "super.h"</p>
      <p> extern do_access(), do_chdir(), do_chmod(), do_chown(), do_chroot(); extern do_close(), do_creat(), do_dup(), do_exit(), do_fork(), do_fstat(); extern do_ioctl(), do_link(), do_lseek(), do_mknod(), do_mount(), do_open(); extern do_pipe(), do_read(), do_revive(), do_set(), do_stat(), do_stime(); extern do_sync(), do_time(), do_tims(), do_umask(), do_umount(), do_unlink(); extern do_unpause(), do_utime(), do_write(), no_call(), no_sys();</p>
      <p> extern char fstack[];</p>
      <p> char *stackpt = &amp;fstack[FS_STACK_BYTES]; int (*call_vector[NCALLS])() = {</p>
      <p> /* initial stack pointer */</p>
      <p> MINIX SOURCE CODE File: fs/table.c 621</p>
      <p> File: fs/table.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 9400 9401 9402 9403 9404 9405 9406 9407 9408 9409 9410 9411 9412 9413 9414 9415 9416</p>
      <p> 9426 9427 9428</p>
      <p> };</p>
      <p> no_sys, do_unpause, no_sys, do_revive, no_sys</p>
      <p> /* 64 /* 65 /* 66</p>
      <p> 67 68</p>
      <p> KSIG: signals originating in the kernel */ UNPAUSE */</p>
      <p> BRK2 (used to tell MM size of FS.INIT) */ REVIVE */ TASK_REPLY */</p>
      <p> extern rw_dev(), rw_dev2();</p>
      <p> /* The order of the entries here determines the mapping between major device</p>
      <p> * numbers and tasks.    The first entry (major device 0) is not used. The</p>
      <p> * next entry is major device 1, etc.    Character and block devices can be</p>
      <p> * intermixed at random.    If this ordering is changed, B00T_DEV and R00T_DEV</p>
      <p> * must be changed to correspond to the new values. */</p>
      <p> struct dmap dmap[] = {</p>
      <p> };</p>
      <p> int max_major = sizeof(dmap)/sizeof(struct dmap);</p>
      <p> MINJX SOURCE CODE</p>
      <p> File: fs/open.c</p>
      <p> 623</p>
      <p> 9450 /* This file contains the procedures for creating, opening, closing, and</p>
      <p> 9451 * seeking on files.</p>
      <p> 9452 *</p>
      <p> 9453 * The entry points into this file are</p>
      <p> 9454 *     do_creat:    perform the CREAT system call</p>
      <p> 9455 *     do_mknod:   perform the MKNOD system call</p>
      <p> 9456 #    do_open:     perform the OPEN system call</p>
      <p> 9457 *    do_close:   perform the CLOSE system call</p>
      <p> 9458 #    do_lseek:   perform the LSEEK system call</p>
      <p> 9459 */ 9460</p>
      <p> 9461 ^include "../h/const.h"</p>
      <p> 9462 ^include "../h/type.h"</p>
      <p> 9463 ^include "../h/callnr.h"</p>
      <p> 9464 ^include "../h/error.h"</p>
      <p> 9465 ^include "const.h"</p>
      <p> 9466 ^include "type.h"</p>
      <p> 9467 ^include "buf.h"</p>
      <p> 9468 ^include "file.h"</p>
      <p> 9469 ^include "fproc.h"</p>
      <p> 9470 ^include "glo.h"</p>
      <p> 9471 ^include "inode.h"</p>
      <p> 9472 ^include "param.h" 9473</p>
      <p> 9474 PRIVATE char mode_map[] = {R_BIT, W_BIT, R_BITJW_BIT, 0}j 9475</p>
      <p> 9476  /* = = = = = = = = = = = — = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  s  = = = = =  =   =   =   =   =   =   =   =   =   =   s   =   =   =   =   =   =   =   =   =   =  z</p>
      <p> 9477 * do_creat</p>
      <p> 9478 *====================================== = ========= ========: =======  -.</p>
      <p> 9479 PUBLIC int do_creat()</p>
      <p> 9480 {</p>
      <p> 9481 /* Perform the creat(name, mode) system call. */ 9482</p>
      <p> 9483 register struct inode *rip;</p>
      <p> 9484 register int r;</p>
      <p> 9485 register mask_bits bits;</p>
      <p> 9486 struct filp *fil_ptr;</p>
      <p> 9487 int file_d;</p>
      <p> 9488 extern struct inode *new_node(); 9489</p>
      <p> 9490 /* See if name ok and file descriptor and filp slots are available. */</p>
      <p> 9491 if (fetch_name(name, name_length, M3) != OK) return(err code);</p>
      <p> 9492 if ( (r = get_fd(W_BIT, 4file_d, &amp;fil_ptr)) != OK) return(r); 9493</p>
      <p> 9494 /* Create a new inode by calling new_node(). */</p>
      <p> 9495 bits = I_REGULAR |  (mode &amp; ALI MODES &amp; fp-&gt;fp_umask);</p>
      <p> 9496 rip = new_node(user_path, bits, N0_Z0NE);</p>
      <p> 9497 r = err_code;</p>
      <p> 9498 if (r != OK &amp;&amp; r != EEXIST) return(r); 9499</p>
      <p> File: fs/open.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 9500 /* At this point two possibilities exist: the given path did not exist</p>
      <p> 9501 * and has been created, or it pre-existed.    In the latter case, truncate</p>
      <p> 9502 * if possible, otherwise return an error.</p>
      <p> 9503 */</p>
      <p> 9504 if (r == EEXIST) {</p>
      <p> 9505 /* File exists already. */</p>
      <p> 9506 switch (rip-&gt;i_mode &amp; I_TYPE) {</p>
      <p> 9507 case I_REGULAR: /# truncate regular file */</p>
      <p> 9508 if ( (r = forbidden(rip, W_BIT, 0)) == OK) truncate(rip);</p>
      <p> 9509 break; 9510</p>
      <p> 9511 case I_DIRECT0RY:     /* can't truncate directory */</p>
      <p> 9512 r = EISDIR;</p>
      <p> 9513 break; 9514</p>
      <p> 9515 case I_CHAR_SPECIAL: /# special files are special */</p>
      <p> 9516 case I_BL0CK_SPECIAL:</p>
      <p> 9517 if ( (r = forbidden(rip, W_BIT, 0)) != OK) break;</p>
      <p> 9518 r = dev_open( (dev_nr) rip-&gt;i_zone[0], W_BIT);</p>
      <p> 9519 break;</p>
      <p> 9520 }</p>
      <p> 9521 } 9522</p>
      <p> 9523 /# If error, return inode. */</p>
      <p> 9524 if (r != OK) {</p>
      <p> 9525 put_inode(rip);</p>
      <p> 9526 return(r);</p>
      <p> 9527 } 9528</p>
      <p> 9529 /# Claim the file descriptor and filp slot and fill them in. */</p>
      <p> 9530 fp-&gt;fp_filp[file_d] = fil_ptr;</p>
      <p> 9531 fil_ptr-&gt;filp_count = 1;</p>
      <p> 9532 fil_ptr-&gt;filp_ino = rip;</p>
      <p> 9533 return(file_d);</p>
      <p> 9534 }</p>
      <p> 9538 /* = r = = = = = z = =: = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =; = = = = = = := = = = = = = = = = = = = = = = = =*</p>
      <p> 9539 * do_mknod *</p>
      <p> 9540 # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = :: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */</p>
      <p> 9541 PUBLIC int do_mknod()</p>
      <p> 9542 {</p>
      <p> 9543 /* Perform the mknod(name, mode, addr) system call. */ 9544</p>
      <p> 9545 register mask_bits bits; 9546</p>
      <p> 9547 if (!super_user) return(EPERM); /* only super_user may make nodes #/</p>
      <p> 9548 if (fetch_name(namel, namel_length, Ml)  != OK) return(err_code);</p>
      <p> 9549 bits = (mode &amp; I_TYPE)  |  (mode   &amp; AL I MODES &amp; fp-&gt;fp_umask);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/open.c</p>
      <p> 625</p>
      <p> 9550 put_inode(new_node(user_path, bits, (zone_nr) addr));</p>
      <p> 9551 return(err_code);</p>
      <p> 9552 }</p>
      <p> 9554 /*===========================================================================*</p>
      <p> 9555 * new_node *</p>
      <p> 9556 »=: = ::::::::: = :::::::====:: ====::: = =:==::: = ::::: = = " = = = = =========:===: = -"=#/</p>
      <p> 9557 PRIVATE struct inode *new_node(path, bits, zO)</p>
      <p> 9558 char *path; /* pointer to path name */</p>
      <p> 9559 mask_bits bits; /* mode of the new inode */</p>
      <p> 9560 zone_nr zO; /* zone number 0 for new inode #/</p>
      <p> 9561 {</p>
      <p> 9562 /# This function is called by do_creat() and do_mknod().    In both cases it</p>
      <p> 9563 * allocates a new inode, makes a directory entry for it on the path 'path',</p>
      <p> 9564 # and initializes it.    It returns a pointer to the inode if it can do this;</p>
      <p> 9565 * err_code is set to OK or EEXIST. If it can't, it returns Nil INODE and</p>
      <p> 9566  *  'err_code' contains the appropriate message.</p>
      <p> 9567 */ 9568</p>
      <p> 9569 register struct inode *rlast_dir_ptr, *rip;</p>
      <p> 9570 register int r;</p>
      <p> 9571 char string[NAME_SIZE];</p>
      <p> 9572 extern struct inode #alloc_inode(), *advance(), *last_dir(); 9573</p>
      <p> 9574 /* See if the path can be opened down to the last directory. */</p>
      <p> 9575 if ((rlast_dir_ptr = last_dir(path, string)) == Nil INODE) return(NIL_INODE);</p>
      <p> 9576</p>
      <p> 9577 /* The final directory is accessible. Get final component of the path. */</p>
      <p> 9578 rip = advance(rlast_dir_ptr, string);</p>
      <p> 9579 if ( rip == Nil INODE &amp;&amp; err_code  -=  ENOENT) {</p>
      <p> 9580 /* Last path component does not exist.    Make new directory entry. */</p>
      <p> 9581 if ( (rip = alloc_inode(rlast_dir_ptr-&gt;i_dev, bits)) == Nil INODE) {</p>
      <p> 9582 /* Can't creat new inode: out of inodes. */</p>
      <p> 9583 put_inode(rlast_dir_ptr);</p>
      <p> 9584 return(NIL_INODE);</p>
      <p> 9585 } 9586</p>
      <p> 9587 /* Force inode to the disk before making directory entry to make</p>
      <p> 9588 * the system more robust in the face of a crash: an inode with</p>
      <p> 9589 * no directory entry is much better than the opposite.</p>
      <p> 9590 #/</p>
      <p> 9591 rip-&gt;i_nlinks++;</p>
      <p> 9592 rip-&gt;i_zone[0] = zO;</p>
      <p> 9593 rw_inode(rip, WRITING);  I*  force inode to disk now */ 9594</p>
      <p> 9595 /* New inode acquired.    Try to make directory entry. */</p>
      <p> 9596 if ((r = search_dir(rlast_dir_ptr, string, &amp;rip~&gt;i_num,ENTER))  != OK) {</p>
      <p> 9597 put_inode(rlast_dir_ptr);</p>
      <p> 9598 rip-&gt;i_nlinks—; /* pity, have to free disk inode */</p>
      <p> 9599 rip-&gt;i_dirt = DIRTY;      /* dirty inodes are written out */</p>
      <p> 626 File: fs/open.c MINIX SOURCE CODE</p>
      <p> 9600 put_inode(rip); /* this call frees the inode */</p>
      <p> 9601 err_code = r;</p>
      <p> 9602 return(NIL_INODE);</p>
      <p> 9603 } 9604</p>
      <p> 9605 } else {</p>
      <p> 9606 /* Either last component exists, or there is some problem. */</p>
      <p> 9607 if (rip != Nil INODE)</p>
      <p> 9608 r = EEXIST;</p>
      <p> 9609 else</p>
      <p> 9610 r = err_code;</p>
      <p> 9611 } 9612</p>
      <p> 9613 /* Return the directory inode and exit. */</p>
      <p> 9614 put_inode(rlast_dir_ptr);</p>
      <p> 9615 err_code = r;</p>
      <p> 9616 return(rip);</p>
      <p> 9617 }</p>
      <p> 9619</p>
      <p> 9620 * do_open *</p>
      <p> 9621 ♦ === ====================^===================================================*/</p>
      <p> 9622 PUBLIC int do_open()</p>
      <p> 9623 {</p>
      <p> 9624 /* Perform the open(name, mode) system call. */ 9625</p>
      <p> 9626 register struct inode »rip;</p>
      <p> 9627 struct filp *fil_ptr;</p>
      <p> 9628 register int r;</p>
      <p> 9629 register mask-bits bits;</p>
      <p> 9630 int file_d;</p>
      <p> 9631 extern struct inode *eat_path(); 9632</p>
      <p> 9633 /* See if file descriptor and filp slots are available.   The variable</p>
      <p> 9634 ♦ 'mode' is 0 for read, 1 for write, 2 for read+write.   The variable</p>
      <p> 9635 * 'bits' needs to be R_BIT, W_BIT, and R_BIT|W_BIT respectively.</p>
      <p> 9636 */</p>
      <p> 9637 if (mode &lt; 0 || mode &gt; 2) return(EINVAL);</p>
      <p> 9638 if (fetch_name(name, name_length, M3) != OK) return(err_code);</p>
      <p> 9639 bits = (mask_bits) mode_map[mode];</p>
      <p> 9640 if ( (r = get_fd(bits, 4file_d, &amp;fil_ptr)) != OK) return(r); 9641</p>
      <p> 9642 /* Scan path name. */</p>
      <p> 9643 if ( (rip = eat_path(user_path))      Nil INODE) return(err_code);</p>
      <p> 9644</p>
      <p> 9645 if ((r = forbidden(rip, bits, 0)) != OK) {</p>
      <p> 9646 put_inode(rip); /* can't open: protection violation */</p>
      <p> 9647 return(r);</p>
      <p> 9648 } 9649</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/open.c</p>
      <p> 627</p>
      <p> 9650 /* Opening regular files, directories and special files are different. */</p>
      <p> 9651 switch (rip-&gt;i_mode 4 I_TYPE) {</p>
      <p> 9652 case I_DIRECT0RY:</p>
      <p> 9653 if (bits 4 W_BIT) {</p>
      <p> 9654 put_inode(rip);</p>
      <p> 9655 return(EISDIR);</p>
      <p> 9656 }</p>
      <p> 9657 break; 9658</p>
      <p> 9659 case I_CHAR_SPECIAL:</p>
      <p> 9660 /* Assume that first open of char special file is controlling tty. */</p>
      <p> 9661 if (fp-&gt;fs_tty == 0) fp-&gt;fs_tty = (dev_nr) rip-&gt;i_zone[0];</p>
      <p> 9662 dev_open((dev_nr) rip-&gt;i_zone[0], (int) bits);</p>
      <p> 9663 break; 9664</p>
      <p> 9665 case I_BLOCK_SPECIAL:</p>
      <p> 9666 dev_open((dev_nr) rip-&gt;i_zone[0], (int) bits);</p>
      <p> 9667 break;</p>
      <p> 9668 } 9669</p>
      <p> 9670 /* Claim the file descriptor and filp slot and fill them in. */</p>
      <p> 9671 fp-&gt;fp_filp[file_d] = fil_ptr;</p>
      <p> 9672 fil_ptr-&gt;filp_count = 1;</p>
      <p> 9673 fil_ptr-&gt;filp_ino = rip;</p>
      <p> 9674 return(file_d);</p>
      <p> 9675 }</p>
      <p> 9677 = = = = = = = = = = = = = = : = = = = ; = = = = = = = = = = = = = =  = = = = = = = = = = = = = = =     = = = = = = = : = = = = = = = = = = - = = =</p>
      <p> 9678 * do_close</p>
      <p> 9679 *===================================================== = ===== == ===== ==== r ====</p>
      <p> 9680 PUBLIC int do_close()</p>
      <p> 9681 {</p>
      <p> 9682 /* Perform the close(fd) system call. */ 9683</p>
      <p> 9684 register struct filp *rfilp;</p>
      <p> 9685 register struct inode *rip;</p>
      <p> 9686 int rw;</p>
      <p> 9687 int mode_word;</p>
      <p> 9688 extern struct filp *get_filp(); 9689</p>
      <p> 9690 /* First locate the inode that belongs to the file descriptor. */</p>
      <p> 9691 if ( (rfilp = get_filp(fd)) == NIL_FILP) return(err_code);</p>
      <p> 9692 rip = rfilp-&gt;filp_ino; /♦ 'rip' points to the inode */ 9693</p>
      <p> 9694 /* Check to see if the file is special. */</p>
      <p> 9695 mode_word = rip-&gt;i_mode 4 I_TYPE;</p>
      <p> 9696 if (mode_word == I_CHAR_SPECIAL || mode_word       I_BL0CK_SPECIAL) {</p>
      <p> 9697 if (mode_word — I_BLOCK_SPECIAL) {</p>
      <p> 9698 /♦ Invalidate cache entries unless special is mounted or ROOT</p>
      <p> 9699 do_sync(); /♦ purge cache */</p>
      <p> 628 File: fs/open.c MINIX SOURCE CODE</p>
      <p> 9700 if (mounted(rip) == FALSE) invalidate((dev_nr) rip-&gt;i_zone[0]);</p>
      <p> 9701 }</p>
      <p> 9702 dev_close((dev_nr) rip-&gt;i_zone[0]);</p>
      <p> 9703 } 9704</p>
      <p> 9705 /# If the inode being closed is a pipe, release everyone hanging on it. */</p>
      <p> 9706 if (rfilp-&gt;filp_ino-&gt;i_pipe) {</p>
      <p> 9707 rw = (rfilp-&gt;filp_mode &amp; R_BIT ? WRITE : READ);</p>
      <p> 9708 release(rfilp-&gt;filp_ino, rw, NR_PR0CS);</p>
      <p> 9709 } 9710</p>
      <p> 9711 /* If a write has been done, the inode is already marked as DIRTY. */</p>
      <p> 9712 if (—rfilp-&gt;filp_count — 0) put_inode(rfilp-&gt;filp_ino); 9713</p>
      <p> 9714 fp-&gt;fp_filp[fd] = NIL_FILP;</p>
      <p> 9715 return(OK);</p>
      <p> 9716 }</p>
      <p> 9718 /#===========================================================================*</p>
      <p> 9719 * do_lseek *</p>
      <p> 9721 PUBLIC int do_lseek()</p>
      <p> 9722 t</p>
      <p> 9723 /* Perform the lseek(ls_fd, offset, whence) system call. */ 9724</p>
      <p> 9725 register struct filp *rfilp;</p>
      <p> 9726 register file_pos pos;</p>
      <p> 9727 extern struct filp *get_filp(); 9728</p>
      <p> 9729 /* Check to see if the file descriptor is valid. */</p>
      <p> 9730 if ( (rfilp = get_filp(ls_fd)) == NIL_FILP) return(err_code); 9731</p>
      <p> 9732 /* No lseek on pipes. */</p>
      <p> 9733 if (rfilp-&gt;filp_ino-&gt;i_pipe == I_PIPE) return(ESPIPE); 9734</p>
      <p> 9735 /* The value of 'whence' determines the algorithm to use. */</p>
      <p> 9736 switch(whence) {</p>
      <p> 9737 case 0: pos = offset; break;</p>
      <p> 9738 case 1: pos = rfilp-&gt;filp_pos + offset; break;</p>
      <p> 9739 case 2: pos = rfilp-&gt;filp_ino-&gt;i_size + offset; break;</p>
      <p> 9740 default: return(EINVAL);</p>
      <p> 9741 }</p>
      <p> 9742 if (pos &lt; (file_pos) 0) return(EINVAL); 9743</p>
      <p> 9744 rfilp-&gt;filp_ino-&gt;i_seek = ISEEK; /* inhibit read ahead */</p>
      <p> 9745 rfilp-&gt;filp_pos = pos; 9746</p>
      <p> 9747 reply_ll = pos; /* insert the long into the output message */</p>
      <p> 9748 return(OK);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/read.c</p>
      <p> 629</p>
      <p> 9750 /* This file contains the heart of the mechanism used to read (and write)</p>
      <p> 9751 * files.    Read and write requests are split up into chunks that do not cross</p>
      <p> 9752 # block boundaries.    Each chunk is then processed in turn.    Reads on special</p>
      <p> 9753 * files are also detected and handled.</p>
      <p> 9754 *</p>
      <p> 9755 * The entry points into this file are</p>
      <p> 9756 *     do_read:       perform the READ system call by calling read_write</p>
      <p> 9757 *     read_write: actually do the work of READ and WRITE</p>
      <p> 9758 *     read_map:     given an inode and file position, look up its zone number</p>
      <p> 9759 *     rw_user:       call the kernel to read and write user space</p>
      <p> 9760 *     read_ahead: manage the block read ahead business</p>
      <p> 9761 */ 9762</p>
      <p> 9763 ^include "../h/const.h"</p>
      <p> 9764 ^include "../h/type.h"</p>
      <p> 9765 ^include "../h/com.h"</p>
      <p> 9766 ^include "../h/error.h"</p>
      <p> 9767 ^include "const.h"</p>
      <p> 9768 ^include "type.h"</p>
      <p> 9769 ^include "buf.h"</p>
      <p> 9770 ^include "file.h"</p>
      <p> 9771 ^include "fproc.h"</p>
      <p> 9772 ^include "glo.h"</p>
      <p> 9773 ^include "inode.h"</p>
      <p> 9774 ^include "param.h"</p>
      <p> 9775 ^include "super.h" 9776</p>
      <p> 9777 ^define FD_MASK                 077       /* max file descriptor is 63 #/ 9778</p>
      <p> 9779 PRIVATE message umess; /* message for asking SYSTASK for user copy */ 9780</p>
      <p> 9781</p>
      <p> 9782 # do_read * 9783</p>
      <p> 9784 PUBLIC int do_read()</p>
      <p> 9785 {</p>
      <p> 9786 return(read_write(READING));</p>
      <p> 9787 }</p>
      <p> 9791 /*= = = = = = = = = = = = = = = = = = = = = = = = = ^ = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 9792 * read_write *</p>
      <p> 9793 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 9794 PUBLIC int read_write(rw_flag)</p>
      <p> 9795 int rw_flag; /* READING or WRITING */</p>
      <p> 9796 {</p>
      <p> 9797 /* Perform read(fd, buffer, nbytes) or write(fd, buffer, nbytes) call. ♦/ 9798</p>
      <p> 9799 register struct inode *rip;</p>
      <p> 630 File: fs/read.c MINIX SOURCE CODE</p>
      <p> 9800 register struct filp *f;</p>
      <p> 9801 register file_pos bytes_left, f_size;</p>
      <p> 9802 register unsigned off, cum_io;</p>
      <p> 9803 file_pos position;</p>
      <p> 9804 int r, chunk, virg, mode_word, usr, seg;</p>
      <p> 9805 struct filp *wf;</p>
      <p> 9806 extern struct super_block *get_super();</p>
      <p> 9807 extern struct filp *find_filp(), *get_filp();</p>
      <p> 9808 extern real_time clock_time(); 9809</p>
      <p> 9810 /* MM loads segments by putting funny things in upper 10 bits of 'fd'. */</p>
      <p> 9811 if (who == MM_PR0C_NR 44 (fd 4 ("BYTE)) ) {</p>
      <p> 9812 usr = (fd » 8) &amp; BYTE;</p>
      <p> 9813 seg r (fd » 6) 4 03;</p>
      <p> 9814 fd 4= FD_MASK; /* get rid of user and segment bits */</p>
      <p> 9815 } else {</p>
      <p> 9816 usr = who; /* normal case */</p>
      <p> 9817 seg = D;</p>
      <p> 9818 } 9819</p>
      <p> 9820 /* If the file descriptor is valid, get the inode, size and mode. */</p>
      <p> 9821 if (nbytes == 0) return(O);     /* so char special files need not check for 0*/</p>
      <p> 9822 if (who != MM_PR0C_NR 44 nbytes &lt; 0) return(EINVAL);    /# only MM &gt; 32K */</p>
      <p> 9823 if ( (f = get_filp(fd)) == NIL.FILP) return(err_code);</p>
      <p> 9824 if ( ((f-&gt;filp_mode) &amp; (rw_flag == READING ? R_BIT : W_BIT)) == 0)</p>
      <p> 9825 return(EBADF);</p>
      <p> 9826 position = f-&gt;filp_pos;</p>
      <p> 9827 if (position &lt; (file_pos) 0) return(EINVAL);</p>
      <p> 9828 rip = f-&gt;filp_ino;</p>
      <p> 9829 f_size = rip-&gt;i_size;</p>
      <p> 9830 r = OK;</p>
      <p> 9831 cum_io = 0;</p>
      <p> 9832 virg = TRUE;</p>
      <p> 9833 mode_word = rip-&gt;i_mode 4 I_TYPE; 9834</p>
      <p> 9835 /* Check for character special files. #/</p>
      <p> 9836 if (mode_word = = I_CHAR_SPECIAL) {</p>
      <p> 9837 if ((r = dev_io(rw_flag, (dev_nr) rip-&gt;i_zone[0], (long) position,</p>
      <p> 9838 nbytes, who, buffer)) &gt;= 0) {</p>
      <p> 9839 cum_io = r;</p>
      <p> 9840 position += r;</p>
      <p> 9841 r = OK;</p>
      <p> 9842 }</p>
      <p> 9843 } else {</p>
      <p> 9844 if (rw.flag == WRITING 44 mode_word != I_BL0CK_SPECIAL) {</p>
      <p> 9845 /* Check in advance to see if file will grow too big. */</p>
      <p> 9846 if (position &gt; get_super(rip-&gt;i_dev)-&gt;s_max_size - nbytes )</p>
      <p> 9847 return(EFBIG); 9848</p>
      <p> 9849 /* Clear the zone containing present EOF if hole about</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/read.c</p>
      <p> 631</p>
      <p> 9850 * to be created.   This is necessary because all unwritten</p>
      <p> 9851 + blocks prior to the EOF must read as zeros.</p>
      <p> 9852 */</p>
      <p> 9853 if (position &gt; f_size) clear_zone(rip, f_size, 0);</p>
      <p> 9854 } 9855</p>
      <p> 9856 /♦ Pipes are a little different.   Check. */</p>
      <p> 9857 if (rip-&gt;i_pipe &amp;&amp; (r = pipe_check(rip, rw_flag, virg,</p>
      <p> 9858 nbytes, &amp;position)) &lt;= 0) return(O); 9859</p>
      <p> 9860 /* Split the transfer into chunks that don't span two blocks. */</p>
      <p> 9861 while (nbytes != 0) {</p>
      <p> 9862 off = position  %  BL0TK_SIZE;      /* offset within a block */</p>
      <p> 9863 chunk = MIN(nbytes, BL0CK_SIZE - off);</p>
      <p> 9864 if (chunk &lt; 0) chunk = BL0CK_SIZE - off; 9865</p>
      <p> 9866 if (rw_flag == READING) {</p>
      <p> 9867 if ((bytes_left = f_size - position) &lt;= 0)</p>
      <p> 9868 break;</p>
      <p> 9869 else</p>
      <p> 9870 if (chunk &gt; bytes_left) chunk = bytes_left;</p>
      <p> 9871 } 9872</p>
      <p> 9873 /* Read or write 'chunk' bytes. */</p>
      <p> 9874 r=rw_chunk(rip, position, off, chunk, rw_flag, buffer, seg,usr);</p>
      <p> 9875 if (r != OK) break;        /* EOF reached */ 9876</p>
      <p> 9877 /♦ Update counters and pointers. */</p>
      <p> 9878 buffer += chunk; /* user buffer address */</p>
      <p> 9879 nbytes -= chunk; /* bytes yet to be read */</p>
      <p> 9880 cum_io += chunk; /* bytes read so far */</p>
      <p> 9881 position += chunk; /* position within the file */</p>
      <p> 9882 virg = FALSE; /* tells pipe_check() that data has been copied */</p>
      <p> 9883 }</p>
      <p> 9884 } 9885</p>
      <p> 9886 /* On write, update file size and access time. #/</p>
      <p> 9887 if (rw.flag == WRITING) {</p>
      <p> 9888 if (mode_word != I_CHAR_SPECIAL &amp;&amp; mode_word != I_BL0CK_SPECIAL &amp;&amp;</p>
      <p> 9889 position &gt; f_size)</p>
      <p> 9890 rip-&gt;i_size = position;</p>
      <p> 9891 rip-&gt;i_modtime = clock_time();</p>
      <p> 9892 rip-&gt;i_dirt = DIRTY;</p>
      <p> 9893 } else {</p>
      <p> 9894 if (rip-&gt;i_pipe &amp;&amp; position &gt;= rip-&gt;i_size) {</p>
      <p> 9895 /# Reset pipe pointers. */</p>
      <p> 9896 rip-&gt;i_size = 0; /* no data left */</p>
      <p> 9897 position = 0; /* reset reader(s) */</p>
      <p> 9898 if ( (wf = find_filp(rip, W_BIT)) != NIL_FILP) wf-&gt;filp_pos = 0;</p>
      <p> 632 File: fs/read.c MINIX SOURCE CODE</p>
      <p> 9900 }</p>
      <p> 9901 f-&gt;filp_pos = position; 9902</p>
      <p> 9903 /* Check to see if read-ahead is called for, and if so, set it up. */</p>
      <p> 9904 if (rw_flag == READING &amp;&amp; rip-&gt;i_seek — N0_SEEK &amp;&amp; position  %  BI_0CK_SIZE = = 0</p>
      <p> 9905 &amp;&amp; (mode_word == I_REGULAR || mode_word == I_DIRECT0RY)) {</p>
      <p> 9906 rdahed_inode = rip;</p>
      <p> 9907 rdahedpos = position;</p>
      <p> 9908 }</p>
      <p> 9909 if (mode_word == I_REGULAR) rip-&gt;i_seek = N0..SEEK; 9910</p>
      <p> 9911 return(r == OK ? cum_io : r);</p>
      <p> 9912 }</p>
      <p> 9916 /*===========================================================================*</p>
      <p> 9917 * rw_chunk *</p>
      <p> 9918 # = = = = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = = = = r = = = = = = r: :  = = = = rrr = = = = = = = = = = = = = = = = = = = = = = = */</p>
      <p> 9919 PRIVATE int rw_chunk(rip, position, off, chunk, rw_flag, buff, seg, usr)</p>
      <p> 9920 register struct inode *rip; /* pointer to inode for file to be rd/wr #/</p>
      <p> 9921 file_pos position; /* position within file to read or write */</p>
      <p> 9922 unsigned off; /* off within the current block */</p>
      <p> 9923 int chunk; /* number of bytes to read or write */</p>
      <p> 9924 int rw_flag; /♦ READING or WRITING */</p>
      <p> 9925 char #buff; /* virtual address of the user buffer */</p>
      <p> 9926 int seg; /* T or D segment in user space */</p>
      <p> 9927 int usr;  /*  which user process */</p>
      <p> 9928 {</p>
      <p> 9929 /* Read or write (part of) a block. */ 9930</p>
      <p> 9931 register struct buf *bp;</p>
      <p> 9932 register int r;</p>
      <p> 9933 int dir, n, block_spec;</p>
      <p> 9934 block_nr b;</p>
      <p> 9935 dev_nr dev;</p>
      <p> 9936 extern struct buf »get_block(), *new_block();</p>
      <p> 9937 extern block_nr read_map(); 9938</p>
      <p> 9939 block_spec = (rip-&gt;i_mode 4 I_TYPE) == I_BL0CK_SPECIAL;</p>
      <p> 9940 if (block_spec) {</p>
      <p> 9941 b = position/BL0CK_SIZE;</p>
      <p> 9942 dev = (dev_nr) rip-&gt;i_zone[0];</p>
      <p> 9943 } else {</p>
      <p> 9944 b = read_map(rip, position);</p>
      <p> 9945 dev = rip-&gt;i_dev;</p>
      <p> 9946 } 9947</p>
      <p> 9948 if (!block_spec &amp;&amp; b == N0_BL0CK) {</p>
      <p> 9949 if (rw_flag == READING) {</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/read.c</p>
      <p> 633</p>
      <p> 9950 /* Reading from a nonexistent block.    Must read as all zeros. */</p>
      <p> 9951 bp = get_block(N0_DEV, N0_BL0CK, NORMAL);        /* get a buffer */</p>
      <p> 9952 zero_block(bp);</p>
      <p> 9953 } else {</p>
      <p> 9954 /* Writing to a nonexistent block. Create and enter in inode. #/</p>
      <p> 9955 if ((bp = new_block(rip, position)) — Nil BUF)return(err_code);</p>
      <p> 9956 }</p>
      <p> 9957 } else {</p>
      <p> 9958 /* Normally an existing block to be partially overwritten is first read</p>
      <p> 9959 * in.   However, a full block need not be read in.   If it is already in</p>
      <p> 9960 * the cache, acquire it, otherwise just acquire a free buffer.</p>
      <p> 9961 */</p>
      <p> 9962 n = (rw_flag == WRITING &amp;&amp; chunk == BL0CK_SIZE ? N0_READ : NORMAL);</p>
      <p> 9963 if(rw_flag == WRITING &amp;&amp; off == 0 &amp;&amp; position &gt;= rip-&gt;i_size) n=N0_READ;</p>
      <p> 9964 bp = get_block(dev, b, n);</p>
      <p> 9965 } 9966</p>
      <p> 9967 /* In all cases, bp now points to a valid buffer. */</p>
      <p> 9968 if (rw_flag == WRITING &amp;&amp; chunk != BL0CK_SIZE &amp;&amp; !block_spec &amp;&amp;</p>
      <p> 9969 position &gt;= rip-&gt;i_size &amp;&amp; off =- 0)</p>
      <p> 9970 zero_block(bp);</p>
      <p> 9971 dir = (rw_flag = = READING ? TOJJSER : FR0M_USER);</p>
      <p> 9972 r = rw_user(seg, usr, (vir_bytes)buff, (vir_bytes)chunk, bp-&gt;b_data+off, dir);</p>
      <p> 9973 if (rw_flag == WRITING) bp-&gt;b_dirt = DIRTY;</p>
      <p> 9974 n = (off + chunk — BL0CK_SIZE ? FULI DATA_BL0CK : PARTIAL_DATA_BL0CK);</p>
      <p> 9975 put_block(bp, n);</p>
      <p> 9976 return(r);</p>
      <p> 9977 }</p>
      <p> 9981</p>
      <p> 9982 * read_map *</p>
      <p> 9983 * = - = = = = = = = = = = = = = : = = = = = =: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = =*/</p>
      <p> 9984 PUBLIC block_nr read_map(rip, position)</p>
      <p> 9985 register struct inode *rip;        /* ptr to inode to map from */</p>
      <p> 9986 file_pos position; /* position in file whose blk wanted */</p>
      <p> 9987 {</p>
      <p> 9988 /* Given an inode and a position within the corresponding file, locate the</p>
      <p> 9989 * block (not zone) number in which that position is to be found and return it.</p>
      <p> 9990 */ 9991</p>
      <p> 9992 register struct buf *bp;</p>
      <p> 9993 register zone_nr z;</p>
      <p> 9994 register block_nr b;</p>
      <p> 9995 register long excess, zone, block_pos;</p>
      <p> 9996 register int scale, boff;</p>
      <p> 9997 extern struct buf *get_block(); 9998</p>
      <p> 9999 scale = scale_factor(rip);       /* for block-zone conversion */</p>
      <p> File: fs/read.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 10000 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 10011 10012 10013 10014 10015 10016 10017 10018 10019 10020 10021 10022 10023 10024 10025 10026 10027 10028 10029 10030 10031 10032 10033 10034 10035 10036 10037</p>
      <p> block_pos = position/BLOCK_SIZE; /* relative blk  #  in file */</p>
      <p> zone = block_pos &gt;&gt; scale;      /* position's zone */</p>
      <p> boff = block_pos - (zone &lt;&lt; scale);     /» relative blk  ft  within zone */</p>
      <p> /* Is 'position' to be found in the inode itself? */ if (zone &lt; NR_DZ0NE_NUM) {</p>
      <p> if ( (z = rip-&gt;i_zone[zone]) == N0_Z0NE) return(N0_BLOCK);</p>
      <p> b = ((block_nr) z &lt;&lt; scale) + boff;</p>
      <p> return(b);</p>
      <p> }</p>
      <p> /* It is not in the inode, so it must be single or double indirect. */ excess = zone - NR_DZ0NE_NUM; /* first NR_DZ0NE_NUM don't count */</p>
      <p> if (exces /* z = } else { /* if exc b = bp z = put. exc</p>
      <p> s &lt; NR.INDIRECTS) { 'position' can be located via the single indirect block. rip-&gt;i_zone[NR_DZ0NE_NUM];</p>
      <p> */</p>
      <p> 'position' can be located via the double indirect block. */ ( (z = rip-&gt;i_zone[NR_DZ0NE_NUM+l]) — N0_Z0NE) return(N0_BL0CK);</p>
      <p> }</p>
      <p> ess -= NR_INDIRECTS; (block_nr) z &lt;&lt; scale; get_block(rip-&gt;i_dev, b, NORMAL); bp-&gt;b_ind[excess/NR_INDIRECTS]; block(bp, INDIRECT_BL0CK); ess = excess  %  NR_INDIRECTS;</p>
      <p> /* single indir doesn't count  m</p>
      <p> /*  get double indirect block */ /* z is zone  ft  for single ind * /* release double ind block #/ /♦ index into single ind blk  */</p>
      <p> /*  'z' is zone number for single indirect block; if (z == N0_Z0NE) return(N0_BL0CK); b = (block_nr) z &lt;&lt; scale; bp = get_block(rip-&gt;i_dev, b, NORMAL); z = bp-&gt;b_ind[excess]; put_block(bp, INDIRECT_BL0CK); if (z — N0.Z0NE) return(N0_BL0CK); b = ((block_nr) z « scale) + boff; return(b);</p>
      <p> 'excess' is index into it. *</p>
      <p> /* get single indirect block */ /* release single indirect blk</p>
      <p> 10039 10040 10041 10042 10043 10044 10045 10046 10047 10048 10049</p>
      <p> /*=</p>
      <p> PUBLIC int rw_user(s, int s; int u;</p>
      <p> vir_bytes vir; vir_bytes bytes; char *buff; int direction; {</p>
      <p> bytes, buff, direction)</p>
      <p> /* D or T space (stack is also D) */</p>
      <p> /* process number to r/w (usually = 'who') */</p>
      <p> /* virtual address to move to/from */</p>
      <p> /* how many bytes to move #/</p>
      <p> /» pointer to FS space */</p>
      <p> /* T0_USER or FR0M_USER */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/read.c</p>
      <p> 635</p>
      <p> 10050 /* Transfer a block of data.    Two options exist, depending on 'direction':</p>
      <p> 10051 * T0_USER:        Move from FS space to user virtual space</p>
      <p> 10052 * FR0MJJSER:     Move from user virtual space to FS space</p>
      <p> 10053 */ 10054</p>
      <p> 10055 if (direction — TCLUSER ) {</p>
      <p> 10056 /* Write from FS space to user space.  */</p>
      <p> 10057 umess.SRC_SPACE   = D;</p>
      <p> 10058 umess.SRC_PR0C_NR = FS_PR0C_NR;</p>
      <p> 10059 umess.SRC_BUFFER = (long) buff;</p>
      <p> 10060 unless. DST_SPACE   = s;</p>
      <p> 10061 umess.DST_PR0C_NR = u;</p>
      <p> 10062 umess.DST_BUFFER = (long) vir;</p>
      <p> 10063 } else {</p>
      <p> 10064 /# Read from user space to FS space. */</p>
      <p> 10065 umess.SRC_SPACE   = s;</p>
      <p> 10066 umess.SRC_PR0C_NR = u;</p>
      <p> 10067 umess.SRC_BUFFER = (long) vir;</p>
      <p> 10068 umess.DST_SPACE   = D;</p>
      <p> 10069 umess.DST_PR0C_NR = FS_PR0C_NR;</p>
      <p> 10070 umess.DST_BUFFER = (long) buff;</p>
      <p> 10071 } 10072</p>
      <p> 10073 umess.C0PY_BYTES = (long) bytes;</p>
      <p> 10074 sys_copy(iumess);</p>
      <p> 10075 return(umess.m_type);</p>
      <p> 10076 }</p>
      <p> 10080 * read_ahead</p>
      <p> 10081 *===========================================================================</p>
      <p> 10082 PUBLIC read_ahead()</p>
      <p> 10083 {</p>
      <p> 10084 /* Read a block into the cache before it is needed. #/ 10085</p>
      <p> 10086 register struct inode *rip;</p>
      <p> 10087 struct buf  *bp;</p>
      <p> 10088 block_nr b;</p>
      <p> 10089 extern struct buf *get_block(); 10090</p>
      <p> 10091 rip r rdahed_inode; /* pointer to inode to read ahead from */</p>
      <p> 10092 rdahed_inode  -  Nil INODE; /* turn off read ahead #/</p>
      <p> 10093 if ( (b = read_map(rip, rdahedpos)) =- NCLBL0CK) return; /* at EOF */</p>
      <p> 10094 bp = get_block(rip-&gt;i_dev, b, NORMAL);</p>
      <p> 10095 put_block(bp, PARTIAI DATA_BL0CK);</p>
      <p> 10096 }</p>
      <p> File: fs/write.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 10100 10101 10102 10103 10104 10105 10106 10107 10108 10109 10110 10111 10112 10113 10114 10115 10116 10117 10118 10119 10120 10121 10122 10123 10124 10125 10126 10127 10128 10129</p>
      <p> This file is the counterpart of "read.c". It contains the code for writing insofar as this is not contained in read_write().</p>
      <p> The entry points into this file are</p>
      <p> do_write:        call read_write to perform the WRITE system call write_map:       add a new zone to an inode clear_zone:     erase a zone in the middle of a file new_block:       acquire a new block</p>
      <p> do_write</p>
      <p> =*/</p>
      <p> PUBLIC int do_write() {</p>
      <p> /* Perform the write(fd, buffer, nbytes) system call, return(read_write(WRITING));</p>
      <p> */</p>
      <p> 10132 10133 10134 10135 10136 10137 10138 10139 10140 10141 10142 10143 10144 10145 10146 10147 10148 10149</p>
      <p> write_map</p>
      <p> PRIVATE int write_map(rip, position, new_zone)</p>
      <p> register struct inode *rip;        /* pointer to inode to be changed */</p>
      <p> = */</p>
      <p> file_pos position; zone_nr new_zone; {</p>
      <p> /* Write a new zone int scale; zone_nr z, *zp; register block_nr long excess, zone; int index; struct buf *bp; int new_ind, new_dbl;</p>
      <p> extern zone_nr alloc_zone();</p>
      <p> /*</p>
      <p> file address to be mapped */ zone # to be inserted */</p>
      <p> into an inode. */</p>
      <p> b;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/write.c</p>
      <p> 637</p>
      <p> 10150 extern struct buf #get_block();</p>
      <p> 10151 extern real_time clock_time(); 10152</p>
      <p> 10153 rip-&gt;i_dirt = DIRTY; /# inode will be changed */</p>
      <p> 10154 bp = Nil BUF j</p>
      <p> 10155 scale = scale_factor(rip);       /# for zone-block conversion */</p>
      <p> 10156 zone = (position/BL0CK_SIZE) &gt;&gt; scale; /# relative zone # to insert */ 10157</p>
      <p> 10158  I*  Is 'position' to be found in the inode itself? */</p>
      <p> 10159 if (zone &lt; NR_DZ0NE_NUM) {</p>
      <p> 10160 rip-&gt;i_zone[zone] = new_zone;</p>
      <p> 10161 rip-&gt;i_modtime = clock_time();</p>
      <p> 10162 return(OK);</p>
      <p> 10163 } 10164</p>
      <p> 10165 /* It is not in the inode, so it must be single or double indirect. #/</p>
      <p> 10166 excess = zone - NR_DZ0NE_NUM; /* first NR_DZ0NE_NUM don't count */</p>
      <p> 10167 new_ind = FALSE;</p>
      <p> 10168 new_dbl = FALSE; 10169</p>
      <p> 10170 if (excess &lt; NR_INDIRECTS) {</p>
      <p> 10171 /* 'position' can be located via the single indirect block. */</p>
      <p> 10172 zp = &amp;rip-&gt;i_zone[NR_DZ0NE_NUM];</p>
      <p> 10173 } else {</p>
      <p> 10174 /* 'position' can be located via the double indirect block. */</p>
      <p> 10175 if ( (z  -  rip-&gt;i_zone[NR_DZ0NE_NUM+l]) — N0_Z0NE) {</p>
      <p> 10176 /* Create the double indirect block. */</p>
      <p> 10177 if ( (z = alloc_zone(rip-&gt;i_dev, rip-&gt;i_zone[0])) == N0_Z0NE)</p>
      <p> 10178 return(err_code);</p>
      <p> 10179 rip-&gt;i_zone[NR_DZ0NE_NUM+l] = z;</p>
      <p> 10180 new_dbl = TRUE; /* set flag for later */</p>
      <p> 10181 } 10182</p>
      <p> 10183 /* Either way, 'z' is zone number for double indirect block. */</p>
      <p> 10184 excess -= NR_INDIRECTS; /* single indirect doesn't count ♦/</p>
      <p> 10185 index = excess / NR_INDIRECTS;</p>
      <p> 10186 excess = excess  %  NR_INDIRECTS;</p>
      <p> 10187 if (index &gt;= NR_INDIRECTS) return(EFBIG);</p>
      <p> 10188 b = (block_nr) z &lt;&lt; scale;</p>
      <p> 10189 bp = get_block(rip-&gt;i_dev, b, (new_dbl ? N0_READ : NORMAL));</p>
      <p> 10190 if (new_dbl) zero_block(bp);</p>
      <p> 10191 zp= &amp;bp-&gt;b_ind[indexj;</p>
      <p> 10192 } 10193</p>
      <p> 10194 /* 'zp' now points to place where indirect zone  ft  goes; 'excess' is index. */</p>
      <p> 10195 if (*zp — N0_Z0NE) {</p>
      <p> 10196 /* Create indirect block. */</p>
      <p> 10197 #zp = alloc_zone(rip-&gt;i_dev, rip-&gt;i_zone[0]);</p>
      <p> 10198 new_ind = TRUE;</p>
      <p> 10199 if (bp != Nil BUF) bp-&gt;b_dirt = DIRTY;   /* if double ind, it is dirty */</p>
      <p> 638 File: fs/write.c MINIX SOURCE CODE</p>
      <p> 10200 if (*zp — N0_Z0NE) {</p>
      <p> 10201 put_block(bp, INDIRECT_BLOCK);   /* release dbl indirect blk */</p>
      <p> 10202 return(err_code); /* couldn't create single ind */</p>
      <p> 10203 }</p>
      <p> 10204 }</p>
      <p> 10205 put_block(bp, INDIRECT_BLOCK); /* release double indirect blk */ 10206</p>
      <p> 10207 /* 'zp' now points to indirect block's zone number. */</p>
      <p> 10208 b = (block_nr) *zp &lt;&lt; scale;</p>
      <p> 10209 bp = get_block(rip-&gt;i_dev, b, (new_ind ? N0..READ : NORMAL) );</p>
      <p> 10210 if (new_ind) zero_block(bp);</p>
      <p> 10211 bp-&gt;b_ind[excess] = new_zone;</p>
      <p> 10212 rip-&gt;i_modtime = clock_time();</p>
      <p> 10213 bp-&gt;b_dirt = DIRTY;</p>
      <p> 10214 put_block(bp, INDIRECT_BL0CK); 10215</p>
      <p> 10216 return(OK);</p>
      <p> 10217 }</p>
      <p> 10220 * clear_zone *</p>
      <p> 10221 * = = = = : = = = = - = = = = = = = = = = = = = = = =   = = = = = = : = : = = = = = =     = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 10222 PUBLIC clear_zone(rip, pos, flag)</p>
      <p> 10223 register struct inode *rip; /* inode to clear */</p>
      <p> 10224 file_pos pos; /* points to block to clear */</p>
      <p> 10225 int flag; /* 0 if called by read_write, 1 by new_block */</p>
      <p> 10226 {</p>
      <p> 10227 /* Zero a zone, possibly starting in the middle.    The parameter 'pos' gives</p>
      <p> 10228 * a byte in the first block to be zeroed.    ClearzoneO is called from</p>
      <p> 10229 * read_write and new_block().</p>
      <p> 10230 */ 10231</p>
      <p> 10232 register struct buf *bp;</p>
      <p> 10233 register block_nr b, bio, bhi;</p>
      <p> 10234 register file_pos next;</p>
      <p> 10235 register int scale;</p>
      <p> 10236 register zone_type zone_size;</p>
      <p> 10237 extern struct buf #get_block();</p>
      <p> 10238 extern block_nr read_map(); 10239</p>
      <p> 10240 /* If the block size and zone size are the same, clear_zone() not needed. */</p>
      <p> 10241 if ( (scale = scale_factor(rip)) == 0) return; 10242</p>
      <p> 10243</p>
      <p> 10244 zone_size = (zone_type) BL0CK_5IZE « scale;</p>
      <p> 10245 if (flag == 1) pos = (pos/zone_size) * zone._size;</p>
      <p> 10246 next = pos + BL0CK_SIZE - 1; 10247</p>
      <p> 10248 /* If 'pos'  is in the last block of &lt;a zone, do not clear the zone. */</p>
      <p> 10249 if (next/zone_size != pos/zone_size) return;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/write.c</p>
      <p> 639</p>
      <p> J0250 if ( (bio = read_map(rip, next)) == N0_BL0CK) return;</p>
      <p> 10251 bhi = (   ((blo»scale)+l) « scale)     - 1;</p>
      <p> 10252</p>
      <p> 10253 /* Clear all the blocks between 'bio' and 'bhi'. */</p>
      <p> 10254 for (b  =  bio; b &lt;= bhi; b++) {</p>
      <p> 10255 bp = get_block(rip-&gt;i_dev, b, N0_READ);</p>
      <p> 10256 zero_block(bp);</p>
      <p> 10257 put_block(bp, FULI DATA_BL0CK);</p>
      <p> 10258 }</p>
      <p> 10259 }</p>
      <p> 10262 /»: = == = ::::: = :::::::"":::: = ::======= = ====== = :::= = :::::;:: = = :; = : = :;::: = == = = =</p>
      <p> 10263 * new_block</p>
      <p> 10265 PUBLIC struct buf *new_block(rip, position)</p>
      <p> 10266 register struct inode *rip; /* pointer to inode */</p>
      <p> 10267 file_pos position; /* file pointer */</p>
      <p> 10268 {</p>
      <p> 10269 /* Acquire a new block and return a pointer to it.   Doing so may require</p>
      <p> 10270 * allocating a complete zone, and then returning the initial block.</p>
      <p> 10271 * On the other hand, the current zone may still have some unused blocks.</p>
      <p> 10272 */ 10273</p>
      <p> 10274 register struct buf *bp;</p>
      <p> 10275 block_nr b, base_block;</p>
      <p> 10276 zone_nr z;</p>
      <p> 10277 zone_type zone_size;</p>
      <p> 10278 int scale, r;</p>
      <p> 10279 struct super_block *sp;</p>
      <p> 10280 extern struct buf *get_block();</p>
      <p> 10281 extern struct super_block *get_super();</p>
      <p> 10282 extern block_nr read_map();</p>
      <p> 10283 extern zone_nr alloc_zone(); 10284</p>
      <p> 10285 /* Is another block available in the current zone? */</p>
      <p> 10286 if ( (b = read_map(rip, position))      N0_BL0CK) {</p>
      <p> 10287 /* Choose first zone if need be. »/</p>
      <p> 10288 if (rip-&gt;i_size == 0) {</p>
      <p> 10289 sp = get_super(rip-&gt;i_dev);</p>
      <p> 10290 z = sp-&gt;s_firstdatazone;</p>
      <p> 10291 } else {</p>
      <p> 10292 z = rip-&gt;i_zone[0];</p>
      <p> 10293 }</p>
      <p> 10294 if ( (z = alloc_zone(rip-&gt;i_dev, z)) == N0_Z0NE) return(NIL_BUF);</p>
      <p> 10295 if ( (r = write_map(rip, position, z)) != OK) {</p>
      <p> 10296 free_zone(rip-&gt;i_dev, z);</p>
      <p> 10297 err_code = r;</p>
      <p> 10298 return(NIL_BUF);</p>
      <p> 10299 }</p>
      <p> 640 File: fs/write.c                  MINIX SOURCE CODE 10300</p>
      <p> 10301 /* If we are not writing at EOF, clear the zone, just to be safe. */</p>
      <p> 10302 if ( position != rip-&gt;i_size) clear_zone(rip, position, 1);</p>
      <p> 10303 scale = scale_factor(rip);</p>
      <p> 10304 base_block = (block_nr) z &lt;&lt; scale;</p>
      <p> 10305 zone_size = (zone_type) BL0CK_SIZE &lt;&lt; scale;</p>
      <p> 10306 b = base_block + (block_nr)((position  %  zone_size)/BL0CK_SIZE);</p>
      <p> 10307 } 10308</p>
      <p> 10309 bp = get_block(rip-&gt;i_dev, b, N0_READ);</p>
      <p> 10310 zero_block(bp);</p>
      <p> 10311 return(bp);</p>
      <p> 10312 }</p>
      <p> 10315 /*==========================================================================</p>
      <p> 10316 # zero_block</p>
      <p> 10317 * = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 10318 PUBLIC zero_block(bp)</p>
      <p> 10319 register struct buf *bp; /* pointer to buffer to zero */</p>
      <p> 10320 {</p>
      <p> 10321 /* Zero a block. */ 10322</p>
      <p> 10323 register int n;</p>
      <p> 10324 register int *zip; 10325</p>
      <p> 10326 n = INTS_PER_BL0CK; /* number of integers in a block */</p>
      <p> 10327 zip = bp-&gt;b_int; /* where to start clearing */ 10328</p>
      <p> 10329 do { *zip++ = 0;}   while (~n);</p>
      <p> 10330 bp-&gt;b_dirt  -  DIRTY;</p>
      <p> 10331 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/pipe.c</p>
      <p> 641</p>
      <p> 10350 /* This file deals with the suspension and revival of processes.    A process can</p>
      <p> 10351 * be suspended because it wants to read or write from a pipe and can't, or</p>
      <p> 10352 * because it wants to read or write from a special file and can't.    When a</p>
      <p> 10353 * process can't continue it is suspended, and revived later when it is able</p>
      <p> 10354 # to continue.</p>
      <p> 10355 *</p>
      <p> 10356 * The entry points into this file are</p>
      <p> 10357 *     do_pipe:        perform the PIPE system call</p>
      <p> 10358 *    pipe_check:   check to see that a read or write on a pipe is feasible now</p>
      <p> 10359 #     suspend:        suspend a process that cannot do a requested read or write</p>
      <p> 10360 *    release:        check to see if a suspended process can be released and do it</p>
      <p> 10361 *    revive: mark a suspended process as able to run again</p>
      <p> 10362 *    do_unpause:   a signal has been sent to a process; see if it suspended</p>
      <p> 10363 */ 10364</p>
      <p> 10365 if/include ". ./h/const.h"</p>
      <p> 10366 //include ". ./h/type.h"</p>
      <p> 10367 #include "../h/callnr.h"</p>
      <p> 10368 if/include ". ./h/com.h"</p>
      <p> 10369 if/include ". ./h/error.h"</p>
      <p> 10370 //include ". ./h/signal.h"</p>
      <p> 10371 ((/include "const.h"</p>
      <p> 10372 //include "type.h"</p>
      <p> 10373 //include "file.h"</p>
      <p> 10374 ^include "fproc.h"</p>
      <p> 10375 //include "glo.h"</p>
      <p> 10376 ^include "inode.h"</p>
      <p> 10377 //include "param.h" 10378</p>
      <p> 10379 PRIVATE message mess; 10380</p>
      <p> 10381 /.==================:::::=:::::======:===:::=:===:=:======:==:=:=============.</p>
      <p> 10382 * do_pipe *</p>
      <p> 10383 »:: = :== = "::::::::::::::::::::::::::::=:::: = :::::::=: = :=:"::::"""====="*/</p>
      <p> 10384 PUBLIC int do_pipe()</p>
      <p> 10385 {</p>
      <p> 10386 /* Perform the pipe(fil_des) system call. */ 10387</p>
      <p> 10388 register struct fproc *rfp;</p>
      <p> 10389 register struct inode *rip;</p>
      <p> 10390 int r;</p>
      <p> 10391 dev_nr device;</p>
      <p> 10392 struct filp *fil_ptr0, *fil_ptrl;</p>
      <p> 10393 int fil_des[2]; /* reply goes here #/</p>
      <p> 10394 extern struct inode *alloc_inode(); 10395</p>
      <p> 10396 /* Acquire two file descriptors. */</p>
      <p> 10397 rfp = fp;</p>
      <p> 10398 if ( (r = get_fd(R_BIT, ifil_des[0], &amp;fil_ptr0)) != OK) return(r);</p>
      <p> 10399 rfp-&gt;fp_filp[fil_des[0]] = fil_ptr0;</p>
      <p> 642 File: fs/pipe.c MINIX SOURCE CODE</p>
      <p> 10400 fil_ptrO-&gt;filp_count = 1;</p>
      <p> 10401 if ( (r = get_fd(W_BIT, &amp;fil_des[l], &amp;fil_ptrl)) ! = OK) {</p>
      <p> 10402 rfp-&gt;fp_filp[fil_des[0]] = NIL_FILP;</p>
      <p> 10403 fil_ptrO-&gt;filp_count = 0;</p>
      <p> 10404 return(r);</p>
      <p> 10405 }</p>
      <p> 10406 rfp-&gt;fp_filp[fil_des[l]] = fil_ptrl;</p>
      <p> 10407 fil_ptrl-&gt;filp_count = 1; 10408</p>
      <p> 10409 /* Make the inode in the current working directory. */</p>
      <p> 10410 device = rfp-&gt;fp_workdir-&gt;i_dev; /* inode dev is same as working dir */</p>
      <p> 10411 if ( (rip = alloc_inode(device, I_REGULAR)) == Nil—INODE) {</p>
      <p> 10412 rfp-&gt;fp_filp[fil_des[0]] = NIL_FILP;</p>
      <p> 10413 fil_ptr0-&gt;filp_count = 0;</p>
      <p> 10414 rfp-&gt;fp_filp[fil_des[l]] = NIL_FILP;</p>
      <p> 10415 fil_ptrl-&gt;filp_count = 0;</p>
      <p> 10416 return(err_code);</p>
      <p> 10417 } 10418</p>
      <p> 10419 rip-&gt;i_pipe = I_PIPE;</p>
      <p> 10420 fil_ptr0-&gt;filp_ino = rip;</p>
      <p> 10421 dup_inode(rip); /* for double usage */</p>
      <p> 10422 fil_ptrl-&gt;filp_ino = rip;</p>
      <p> 10423 rw_inode(rip, WRITING); /* mark inode as allocated */</p>
      <p> 10424 reply_il = fil_des[0];</p>
      <p> 10425 reply_i2 = fil_des[l];</p>
      <p> 10426 return(OK);</p>
      <p> 10427 }</p>
      <p> 10430 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = =: = = = =: = = = = = = = - = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 10431 * pipe_check * 10432</p>
      <p> 10433 PUBLIC int pipe_check(rip, rw_flag, virgin, bytes, position)</p>
      <p> 10434 register struct inode «ip; /* the inode of the pipe */</p>
      <p> 10435 int rw_flag; /* READING or WRITING */</p>
      <p> 10436 int virgin; /* 1 if no data transferred yet, else 0 */</p>
      <p> 10437 register int bytes; /* bytes to be read or written (all chunks) */</p>
      <p> 10438 register file_pos *position;      /* pointer to current file position */</p>
      <p> 10439 {</p>
      <p> 10440 /* Pipes are a little different.   If a process reads from an empty pipe for</p>
      <p> 10441 * which a writer still exists, suspend the reader.   If the pipe is empty</p>
      <p> 10442 * and there is no writer, return 0 bytes.   If a process is writing to a</p>
      <p> 10443 * pipe and no one is reading from it, give a broken pipe error.</p>
      <p> 10444 */ 10445</p>
      <p> 10446 extern struct filp *find_filp(); 10447</p>
      <p> 10448 /* If reading, check for empty pipe. */</p>
      <p> 10449 if (rw_flag == READING) {</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/pipe.c</p>
      <p> 643</p>
      <p> 10450 if (#position &gt;= rip-&gt;i_size) {</p>
      <p> 10451 /* Process is reading from an empty pipe. */</p>
      <p> 10452 if (find_filp(rip, W_BIT) != NIL_FILP) {</p>
      <p> 10453 /* Writer exists; suspend rdr if no data already read.*/</p>
      <p> 10454 if (virgin) suspend(XPIPE);        /* block reader */ 10455</p>
      <p> 10456 /* If need be, activate sleeping writer. */</p>
      <p> 10457 if (susp_count &gt; 0) release(rip, WRITE, 1);</p>
      <p> 10458 }</p>
      <p> 10459 return(O);</p>
      <p> 10460 }</p>
      <p> 10461 } else {</p>
      <p> 10462 /* Process is writing to a pipe. */</p>
      <p> 10463 if (find_filp(rip, R_BIT)  --  NIL_FILP) {</p>
      <p> 10464 /* Tell MM to generate a SIGPIPE signal. */</p>
      <p> 10465 mess.m_type = KSIG;</p>
      <p> 10466 mess.PROCl = fp - fproc;</p>
      <p> 10467 mess.SIG_MAP = 1 « (SIGPIPE - 1);</p>
      <p> 10468 send(MM_PR0C_NR, &amp;mess);</p>
      <p> 10469 return(EPIPE);</p>
      <p> 10470 } 10471</p>
      <p> 10472 if (*position + bytes &gt; PIPE.SIZE) {</p>
      <p> 10473 suspend(XPIPE); /* stop writer — pipe full */</p>
      <p> 10474 return(O);</p>
      <p> 10475 } 10476</p>
      <p> 10477 /* Writing to an empty pipe.    Search for suspended reader. */</p>
      <p> 10478 if Uposition == 0) release(rip, READ, 1);</p>
      <p> 10479 } 10480</p>
      <p> 10481 return(l);</p>
      <p> 10482 }</p>
      <p> 10485 /* = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = : = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 10486 * suspend *</p>
      <p> 10488 PUBLIC suspend(task)</p>
      <p> 10489 int task; /* who is proc waiting for? (PIPE = pipe) */</p>
      <p> 10490 {</p>
      <p> 10491 /* Take measures to suspend the processing of the present system call.</p>
      <p> 10492 * Store the parameters to be used upon resuming in the process table.</p>
      <p> 10493 * (Actually they are not used when a process is waiting for an 1/0 device,</p>
      <p> 10494 * but they are needed for pipes, and it is not worth making the distinction.)</p>
      <p> 10495 */ 10496</p>
      <p> 10497 if (task == XPIPE) susp_count++; /* count procs suspended on pipe */</p>
      <p> 10498 fp-&gt;fp_suspended = SUSPENDED;</p>
      <p> 10499 fp-&gt;fp_fd = fd « 8 | fs_call;</p>
      <p> 644 File: fs/pipe.c MINIX SOURCE CODE</p>
      <p> 10500 fp-&gt;fp_buffer = buffer;</p>
      <p> 10501 fp-&gt;fp_nbytes = nbytes;</p>
      <p> 10502 fp-&gt;fp_task = -task;</p>
      <p> 10503 dont_reply = TRUE; /* da not send caller a reply message now */</p>
      <p> 10504 }</p>
      <p> 10507 /*===========================================================================</p>
      <p> 10508 * release</p>
      <p> 10509 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =:r = r:= = = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = r =</p>
      <p> 10510 PUBLIC releasedp, call_nr, count)</p>
      <p> 10511 register struct inode *ip; /# inode of pipe */</p>
      <p> 10512 int call_nr; /* READ or WRITE */</p>
      <p> 10513 int count; /* max number of processes to release */</p>
      <p> 10514 {</p>
      <p> 10515 /* Check to see if any process is hanging on the pipe whose inode is in '-ip' .</p>
      <p> 10516 # If one is, and it was trying to perform the call indicated by 'call_nr'</p>
      <p> 10517 * (READ or WRITE), release it.</p>
      <p> 10518 */ 10519</p>
      <p> 10520 register struct fproc *rp; 10521</p>
      <p> 10522 /* Search the proc table. */</p>
      <p> 10523 for (rp = &amp;fproc[0]; rp &lt; &amp;fproc[NR_PR0CS]; rp++) {</p>
      <p> 10524 if (rp-&gt;fp_suspended == SUSPENDED &amp;&amp; (rp-&gt;fp_fd &amp; BYTE) == call_nr &amp;&amp;</p>
      <p> 10525 rp-&gt;fp_filp[rp-&gt;fp_fd»8]-&gt;filp_ino == ip) {</p>
      <p> 10526 revive(rp - fproc, 0);</p>
      <p> 10527 susp_count—;     /# keep track of who is suspended */</p>
      <p> 10528 if (--count == 0) return;</p>
      <p> 10529 }</p>
      <p> 10530 }</p>
      <p> 10531 }</p>
      <p> 10534 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r:: = = = = r = = = =: = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 10535 * revive</p>
      <p> 10536 # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = :: = = = = = = = = = = = = = = = = = = = = = =: = = = =: = = = = = = =</p>
      <p> 10537 PUBLIC revive(proc_nr, bytes)</p>
      <p> 10538 int proc_nr; /* process to revive */</p>
      <p> 10539 int bytes; /* if hanging on task, how many bytes read */</p>
      <p> 10540 {</p>
      <p> 10541 /* Revive a previously blocked process. When a process hangs on tty, this</p>
      <p> 10542 * is the way it is eventually released.</p>
      <p> 10543 #/ 10544</p>
      <p> 10545 register struct fproc *rfp; 10546</p>
      <p> 10547 if (proc_nr &lt; 0 || proc_nr &gt;= NR_PR0CS) panic("revive err", proc_nr);</p>
      <p> 10548 rfp = &amp;fproc[proc_nr];</p>
      <p> 10549 if (rfp-&gt;fp_suspended == N0T_SUSPENDED) return;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/pipe.c</p>
      <p> 645</p>
      <p> 10550</p>
      <p> 10551 /* The 'reviving' flag only applies to pipes.   Processes waiting for TTY get</p>
      <p> 10552 # a message right away.   The revival process is different for TTY and pipes</p>
      <p> 10553 # For TTY revival, the work is already done, for pipes it is not: the proc</p>
      <p> 10554 * must be restarted so it can try again.</p>
      <p> 10555  */</p>
      <p> 10556 if (rfp-&gt;fp_task == XPIPE) {</p>
      <p> 10557 /♦ Revive a process suspended on a pipe. */</p>
      <p> 10558 rfp-&gt;fp_revived = REVIVING;</p>
      <p> 10559 reviving++; /* process was waiting on pipe  */</p>
      <p> 10560 } else {</p>
      <p> 10561 /* Revive a process suspended on TTY or other device. */</p>
      <p> 10562 rfp-&gt;fp_suspended = N0T_SUSPENDED;</p>
      <p> 10563 rfp-&gt;fp_nbytes = bytes; /* pretend it only wants what there is */</p>
      <p> 10564 reply(proc_nr, bytes);    /* unblock the process */</p>
      <p> 10565 }</p>
      <p> 10566 }</p>
      <p> 10569 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = ^ = = = = r = = = = = = = = = = = = =: = = = = = = = = = = *</p>
      <p> 10570 * do_unpause *</p>
      <p> 10571  = = — — = = — — — — — - = — = — = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 10572 PUBLIC int do_unpause()</p>
      <p> 10573 {</p>
      <p> 10574 /* A signal has been sent to a user who is paused on the file system.</p>
      <p> 10575 * Abort the system call with the EINTR error message.</p>
      <p> 10576 */ 10577</p>
      <p> 10578 register struct fproc *rfp;</p>
      <p> 10579 int proc_nr, task;</p>
      <p> 10580 struct filp *f;</p>
      <p> 10581 dev_nr dev;</p>
      <p> 10582 extern struct filp »get_filp(); 10583</p>
      <p> 10584 if (who &gt; MM_PR0C_NR) return(EPERM);</p>
      <p> 10585 proc_nr = pro;</p>
      <p> 10586 if (proc_nr &lt; 0 || proc_nr &gt;= NR_PR0CS) panicC'unpause err 1", proc_nr);</p>
      <p> 10587 rfp = &amp;fproc[proc_nr];</p>
      <p> 10588 if (rfp-&gt;fp_suspended == N0T_SUSPENDED) return(OK);</p>
      <p> 10589 task = -rfp-&gt;fp_task; 10590</p>
      <p> 10591 if (task != XPIPE) {</p>
      <p> 10592 f = get_filp(rfp-&gt;fp_fd);</p>
      <p> 10593 dev = f-&gt;filp_ino-&gt;i_zone[0];     /* device on which proc is hanging #/</p>
      <p> 10594 mess.TTY_LINE = (dev » MINOR) 4 BYTE;</p>
      <p> 10595 mess.PR0C_NR = procnr;</p>
      <p> 10596 mess.m_type = CANCEL;</p>
      <p> 10597 if (sendrec(task, &amp;mess) != OK) panicC'unpause err 2", N0_NUM);</p>
      <p> 10598 while (mess.REP_PR0C_NR != procnr) {</p>
      <p> 10599 revive(mess.REP_PR0C_NR, mess.REP_STATUS);</p>
      <p> 646 File: fs/pipe.c MINIX SOURCE CODE</p>
      <p> 10600 if (receive(task, &amp;m) != OK) panicC'unpause err 3", N0_NUM);</p>
      <p> 10601 }</p>
      <p> 10602 revive(proc_nr, EINTR); /* signal interrupted call */</p>
      <p> 10603 } 10604</p>
      <p> 10605 return(OK);</p>
      <p> 10606' }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/path.c</p>
      <p> 647</p>
      <p> 10650 /* This file contains the procedures that look up path names in the directory</p>
      <p> 10651 * system and determine the inode number that goes with a given path name.</p>
      <p> 10652 *</p>
      <p> 10653 *   The entry points into this file are</p>
      <p> 10654 ♦     eat_path:     the 'main' routine of the path-to-inode conversion mechanism</p>
      <p> 10655 *     last_dir:     find the final directory on a given path</p>
      <p> 10656 *    advance:      parse one component of a path name</p>
      <p> 10657 *    search_dir: search a directory for a string and return its inode number</p>
      <p> 10658 */ 10659</p>
      <p> 10660 ^include "../h/const.h"</p>
      <p> 10661 ^include "../h/type.h"</p>
      <p> 10662 ^include "../h/error.h"</p>
      <p> 10663 ^include "const.h"</p>
      <p> 10664 ^include "type.h"</p>
      <p> 10665 ^include "buf.h"</p>
      <p> 10666 ^include "file.h"</p>
      <p> 10667 ^include "fproc.h"</p>
      <p> 10668 ^include "glo.h"</p>
      <p> 10669 ^include "inode.h"</p>
      <p> 10670 /((include "super.h" 10671</p>
      <p> 10672</p>
      <p> 10673 * eat_path *</p>
      <p> 10674 * = = = = = = = = = = =  I  = r = r = r = = = = = = = = = = = = = = = = = = = = = = rx: = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */</p>
      <p> 10675 PUBLIC struct inode *eat_path(path)</p>
      <p> 10676 char *path; /* the path name to be parsed */</p>
      <p> 10677 {</p>
      <p> 10678 /* Parse the path 'path' and put its inode in the inode table.   If not</p>
      <p> 10679 * possible, return Nil INODE as function value and an error code in 'err_code'.</p>
      <p> 10680 #/ 10681</p>
      <p> 10682 register struct inode *ldip, *rip;</p>
      <p> 10683 char string[NAME_SIZE]; /* hold 1 path component name here */</p>
      <p> 10684 extern struct inode *last_dir(), #advance(); 10685</p>
      <p> 10686 /* First open the path down to the final directory. */</p>
      <p> 10687 if ( (ldip = last_dir(path, string)) == Nil INODE)</p>
      <p> 10688 return(NII INODE); /* we couldn't open final directory */</p>
      <p> 10689</p>
      <p> 10690 /* The path consisting only of "/" is a special case, check for it. */</p>
      <p> 10691 if (string[0] == '\0') return(ldip); 10692</p>
      <p> 10693 /* Get final component of the path. */</p>
      <p> 10694 rip = advanceddip, string);</p>
      <p> 10695 put_inode(ldip);</p>
      <p> 10696 return(rip);</p>
      <p> 10697 }</p>
      <p> 648 File: fs/path.c MINIX SOURCE CODE</p>
      <p> 10700 /*======r====================r==========================;====================*</p>
      <p> 10701 * last_dir *</p>
      <p> 10702 #===========================================================================*/</p>
      <p> 10703 PUBLIC struct inode *last_dir(path, string)</p>
      <p> 10704 char *path; /# the path name to be parsed */</p>
      <p> 10705 char string[NAME_SIZE]; /* the final component is returned here */</p>
      <p> 10706 {</p>
      <p> 10707 /* Given a path, 'path', located in the fs address space, parse it as</p>
      <p> 10708 * far as the last directory, fetch the inode for the last directory into</p>
      <p> 10709 * the inode table, and return a pointer to the inode. In</p>
      <p> 10710 * addition, return the final component of the path in 'string'.</p>
      <p> 10711 * If the last directory can't be opened, return Nil INODE and</p>
      <p> 10712 * the reason for failure in 'err_code'.</p>
      <p> 10713 */ 10714</p>
      <p> 10715 register struct inode *rip;</p>
      <p> 10716 register char #new_name;</p>
      <p> 10717 register struct inode *new_ip;</p>
      <p> 10718 extern struct inode #advance();</p>
      <p> 10719 extern char *get_name(); 10720</p>
      <p> 10721 /* Is the path absolute or relative?   Initialize 'rip' accordingly. */</p>
      <p> 10722 rip = (*path == V ? fp-&gt;fp_rootdir : fp-&gt;fp_workdir);</p>
      <p> 10723 dup_inode(rip); /* inode will be returned with put_inode */ 10724</p>
      <p> 10725 /* Scan the path component by component. */</p>
      <p> 10726 while (TRUE) {</p>
      <p> 10727 /* Extract one component. */</p>
      <p> 10728 if ( (new_name = get_name(path, string)) == (char*) 0) {</p>
      <p> 10729 put_inode(rip); /* bad path in user space +/</p>
      <p> 10730 return(NIL_IN0DE);</p>
      <p> 10731 }</p>
      <p> 10732 if (*new_name == '\0') return(rip); /* normal exit */ 10733</p>
      <p> 10734 /» There is more path.    Keep parsing. */</p>
      <p> 10735 new_ip = advance(rip, string);</p>
      <p> 10736 put_inode(rip); /* rip either obsolete or irrelevant */</p>
      <p> 10737 if (new_ip == Nil INODE) return(NIL_IN0DE);</p>
      <p> 10738</p>
      <p> 10739 /* The call to advanceO succeeded.    Fetch next component. */</p>
      <p> 10740 path = new_name;</p>
      <p> 10741 rip = new_ip;</p>
      <p> 10742 }</p>
      <p> 10743 }</p>
      <p> 10746 /» = = = = "::::::: = = ::=:::"" = = "-":":":" = :::= = ::::==="= = = = = :" = ":" = = = :=»</p>
      <p> 10747 * get_name *</p>
      <p> 10748 #===========================================================================*/</p>
      <p> 10749 PRIVATE char *get_name(old_name, string)</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/path.c</p>
      <p> 649</p>
      <p> 10750 char *old_name; /* path name to parse */</p>
      <p> 10751 char string[NAME_SIZE]; /# component extracted from 'old_name' */</p>
      <p> 10752 {</p>
      <p> 1C753 /* Given a pointer to a path name in fs space, 'old_name', copy the next</p>
      <p> 1C754 * component to 'string' and pad with zeros.    A pointer to that part of</p>
      <p> 10755 * the name as yet unparsed is returned.    Roughly speaking,</p>
      <p> 1C756 * 'get_name' = 'old_name' - 'string'.</p>
      <p> 10757 *</p>
      <p> 1C758 * This routine follows the standard convention that /usr/ast, /usr//ast,</p>
      <p> 10759 * //usr///ast and /usr/ast/ are all equivalent.</p>
      <p> 10760 */ 10761</p>
      <p> 10762 register int c;</p>
      <p> 10763 register char *np, #rnp; 10764</p>
      <p> 10765 np = string; /* 'np' points to current position */</p>
      <p> 10766 rnp = old_name; /* 'rnp' points to unparsed string */</p>
      <p> 10767 while ( (c = *rnp) ==  '/')  rnp++; /* skip leading slashes */ 10768</p>
      <p> 10769 /* Copy the unparsed path, 'old_name', to the array, 'string'. */</p>
      <p> 10770 while ( rnp &lt; &amp;user_path[MAX_PATH]   &amp;&amp;   c != '/'     &amp;&amp;   c != '\0') {</p>
      <p> 10771 if (np &lt; &amp;string[NAME_SIZE]) *np++ = c;</p>
      <p> 10772 c = #++rnp; /* advance to next character */</p>
      <p> 10773 } 10774</p>
      <p> 10775 /# To make /usr/ast/ equivalent to /usr/ast, skip trailing slashes. */</p>
      <p> 10776 while (c ==  '/'  &amp;&amp; rnp &lt; &amp;user_path[MAX_PATH]) c - *++rnp; 10777</p>
      <p> 10778 /* Pad the component name out to NAME_SIZE chars, using 0 as filler. */</p>
      <p> 10779 while (np &lt; &amp;string[NAME_SIZE]) *np++ = '\0'; 10780</p>
      <p> 10781 if (rnp &gt;= &amp;user_path[MAX_PATH]) {</p>
      <p> 10782 err_code = E_L0NG_STRING;</p>
      <p> 10783 return((char *) 0);</p>
      <p> 10784 }</p>
      <p> 10785 return(rnp);</p>
      <p> 10786 }</p>
      <p> 10789 /*=======================================r=============r====================</p>
      <p> 10790  *  advance</p>
      <p> 10791 *=============================================;============================</p>
      <p> 10792 PUBLIC struct inode ^advance(dirp, string)</p>
      <p> 10793 struct inode *dirp; /* inode for directory to be searched */</p>
      <p> 10794 char string[NAME_SIZE]; /* component name to look for */</p>
      <p> 10795 {</p>
      <p> 10796 /* Given a directory and a component of a path, look up the component in</p>
      <p> 10797 * the directory, find the inode, open it, and return a pointer to its inode</p>
      <p> 10798 * slot.   If it can't be done, return Nil INODE.</p>
      <p> 10799 */</p>
      <p> 650 File: fs/path.c MINIX SOURCE CODE</p>
      <p> 10800</p>
      <p> 10801 register struct inode *rip;</p>
      <p> 10802 register struct super_block *sp;</p>
      <p> 10803 register int r;</p>
      <p> 10804 dev_nr mnt_dev;</p>
      <p> 10805 inode_nr numb;</p>
      <p> 10806 extern struct inode *get_inode(); 10807</p>
      <p> 10808 /* If 'string' is empty, yield same inode straight away. */</p>
      <p> 10809 if (string[0] == '\0') return(get_inode(dirp-&gt;i_dev, dirp-&gt;i_num)); 10810</p>
      <p> 10811 /♦ If 'string' is not present in the directory, signal error. */</p>
      <p> 10812 if ( (r = search_dir(dirp, string, inumb, L00KJJP)) != OK) {</p>
      <p> 10813 err_code = r;</p>
      <p> 10814 return(NIL_INODE);</p>
      <p> 10815 } 10816</p>
      <p> 10817 /* The component has been found in the directory.   Get inode. */</p>
      <p> 10818 if ( (rip = get_inode(dirp-&gt;i_dev, numb)) == Nil INODE) return(NIL_INODE);</p>
      <p> 10819</p>
      <p> 10820 if (rip-&gt;i_num == R00T_IN0DE)</p>
      <p> 10821 if (dirp-&gt;i_num == RO0T_IN0DE) {</p>
      <p> 10822 if (stringtl] == '.') {</p>
      <p> 10823 for (sp = &amp;super_block[l]; sp &lt; &amp;super_block[NR_SUPERS]; sp++)</p>
      <p> 10824 if (sp-&gt;s_dev == rip-&gt;i_dev) {</p>
      <p> 10825 /* Release the root inode.    Replace by the</p>
      <p> 10826 * inode mounted on.</p>
      <p> 10827 */</p>
      <p> 10828 put_inode(rip);</p>
      <p> 10829 mnt_dev = sp-&gt;s_imount-&gt;l_dev;</p>
      <p> 10830 rip  -  get_inode(mnt_dev, sp-&gt;s_imount-&gt;i_num);</p>
      <p> 10831 rip = advance(rip, string);</p>
      <p> 10832 break;</p>
      <p> 10833 }</p>
      <p> 10834 }</p>
      <p> 10835 }</p>
      <p> 10836 }</p>
      <p> 10837 /* See if the inode is mounted on.   If so, switch to root directory of the</p>
      <p> 10838 # mounted file system.   The super_block provides the linkage between the</p>
      <p> 10839 ♦ inode mounted on and the root directory of the mounted file system.</p>
      <p> 10840 */</p>
      <p> 10841 while (rip-&gt;ijnount == I_M0UNT) {</p>
      <p> 10842 /* The inode is indeed mounted on. #/</p>
      <p> 10843 for (sp = &amp;super_block[0]; sp &lt; &amp;super_block[NR_SUPERS]; sp++) {</p>
      <p> 10844 if (sp-&gt;s_imount == rip) {</p>
      <p> 10845 /* Release the inode mounted on.   Replace by the</p>
      <p> 10846 * inode of the root inode of the mounted device.</p>
      <p> 10847 */</p>
      <p> 10848 put_inode(rip);</p>
      <p> 10849 rip = get_inode(sp-&gt;s_dev, R00T_IN0DE);</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/path.c</p>
      <p> 651</p>
      <p> 10850 break;</p>
      <p> 10851 }</p>
      <p> 10852 }</p>
      <p> 10853 }</p>
      <p> 10854 return(rip); /* return pointer to inode's component */</p>
      <p> 10855 }</p>
      <p> 10858 /*==============z=z;==rr=================== == =z=-==r=============== = ==r===r==</p>
      <p> 10859 # search_dir</p>
      <p> 10860 *============================================r=r============================</p>
      <p> 10861 PUBLIC int search.dir(ldir_ptr, string, numb, flag)</p>
      <p> 10862 register struct inode *ldir_ptr; /# ptr to inode for dir to search */</p>
      <p> 10863 char string[NAME_SIZE]; /* component to search for */</p>
      <p> 10864 inode_nr *numb; /* pointer to inode number #/</p>
      <p> 10865 int flag; /* L00KJJP, ENTER, or DELETE */</p>
      <p> 10866 {</p>
      <p> 10867 /* This function searches the directory whose inode is pointed to by 'ldip':</p>
      <p> 10868 * if (flag == L0OKJJP) search for 'string' and return inode  tt  in 'numb';</p>
      <p> 10869 * if (flag == ENTER)   enter 'string' in the directory with inode  tt  '*numb';</p>
      <p> 10870 * if (flag == DELETE) delete 'string' from the directory;</p>
      <p> 10871 */ 10872</p>
      <p> 10873 register dir_struct *dp;</p>
      <p> 10874 register struct buf *bp;</p>
      <p> 10875 register int r;</p>
      <p> 10876 mask_bits bits;</p>
      <p> 10877 file_pos pos;</p>
      <p> 10878 unsigned new_slots, old_slots;</p>
      <p> 10879 block_nr b;</p>
      <p> 10880 int e_hit;</p>
      <p> 10881 extern struct buf *get_block(), *new_block();</p>
      <p> 10882 extern block_nr r;ad_map();</p>
      <p> 10883 extern real_time clock_time(); 10884</p>
      <p> 10885 /♦ If 'ldir_ptr' is not a pointer to a searchable dir inode, error. »/</p>
      <p> 10886 if ( (ldir_ptr-&gt;i_mode 4 I_TYPE) != I_DIRECT0RY) return(ENOTDIR);</p>
      <p> 10887 bits = (flag == L00K_UP ? X_BIT : W_BIT|X_BIT);</p>
      <p> 10888 if ( (r = forbidden(ldir_ptr, bits, 0)) != OK)</p>
      <p> 10889 return(r); 10890</p>
      <p> 10891 /* Step through the directory one block at a time. */</p>
      <p> 10892 old_slots = ldir_ptr-&gt;i_size/DIR_ENTRY_SIZE;</p>
      <p> 10893 new_slots = 0;</p>
      <p> 10894 e_hit = FALSE;</p>
      <p> 10895 for (pos = 0; pos &lt; ldir_ptr-&gt;i_size; pos += BL0CK_SIZE) {</p>
      <p> 10896 b = read_map(ldir_ptr, pos);      /* get block number */ 10897</p>
      <p> 10898 /* Since directories don't have holes, 'b' cannot be N0_BL0CK. */</p>
      <p> 10899 bp = get_block(ldir_ptr-&gt;i_dev, b, NORMAL); /* get a dir block */</p>
      <p> 652 File: fs/path.c MINIX SOURCE CODE</p>
      <p> 10900</p>
      <p> 10901 /# Search a directory block. */</p>
      <p> 10902 for (dp = &amp;bp-&gt;b_dir[0]; dp &lt; &amp;bp-&gt;b_.dir[NR_DIR_ENTRIES]; dp++) {</p>
      <p> 10903 if (++new_slots &gt; old_slots) { /* not found, but room left */</p>
      <p> 10904 if (flag == ENTER) e_.hit = TRUE;</p>
      <p> 10905 break;</p>
      <p> 10906 }</p>
      <p> 10907 if (flag != ENTER &amp;&amp; dp-&gt;d_inum != 0</p>
      <p> 10908 &amp;&amp; cmp_strinq(dp-&gt;d_name, string, NAME_SIZE)) {</p>
      <p> 10909 /* L00K_UP or DELETE found what it wanted. */</p>
      <p> 10910 if (flag == DELETE) {</p>
      <p> 10911 dp-&gt;d_inura = 0; /# erase entry */</p>
      <p> 10912 bp-&gt;b_dirt = DIRTY;</p>
      <p> 10913 ldir_ptr-&gt;i_modtime = clock_time();</p>
      <p> 10914 } else</p>
      <p> 10915 *numb = dp-&gt;d_inum;        /* 'flag' is L00K_UP */</p>
      <p> 10916 put_block(bp, DIRECTCIRY_BL0CK);</p>
      <p> 10917 return(OK);</p>
      <p> 10918 } 10919</p>
      <p> 10920 /* Check for free slot for the benefit of ENTER. */</p>
      <p> 10921 if (flag == ENTER &amp;&amp; dp-&gt;d_inum == 0) {</p>
      <p> 10922 e_hit = TRUE;     /* we found a free slot */</p>
      <p> 10923 break;</p>
      <p> 10924 }</p>
      <p> 10925 } 10926</p>
      <p> 10927 /* The whole block has been searched or ENTER has a free slot. ♦/</p>
      <p> 10928 if (e_hit) break; /* e_hit set if ENTER can be performed now */</p>
      <p> 10929 put_block(bp, DIRECT0RY_BL0CK); /* otherwise, continue searching dir #/</p>
      <p> 10930 } 10931</p>
      <p> 10932 /# The whole directory has now been searched. */</p>
      <p> 10933 if (flag !r ENTER) return(ENOENT); 10934</p>
      <p> 10935 /* This call is for ENTER.   If no free slot has been found so far, try to</p>
      <p> 10936 * extend directory.</p>
      <p> 10937 */</p>
      <p> 10938 if (e_hit == FALSE) { /* directory is full and no room left in last block */</p>
      <p> 10939 new_slots ++; /* increase directory size by 1 entry */</p>
      <p> 10940 if (new_slots == 0) return(EFBIG); /* dir size limited by slot count */</p>
      <p> 10941 if ( (bp = new_block(ldir_ptr, ldir_ptr-&gt;i_size)) == Nil BUF)</p>
      <p> 10942 return(err_code);</p>
      <p> 10943 dp = &amp;bp-&gt;b_dir[0];</p>
      <p> 10944 } 10945</p>
      <p> 10946 /* 'bp' now points to a directory block with space, 'dp' points to slot. */</p>
      <p> 10947 copy(dp-&gt;d_name, string, NAME_SIZE);</p>
      <p> 10948 dp-&gt;d_inum = *numb;</p>
      <p> 10949 bp-&gt;b_dirt = DIRTY;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/path.c</p>
      <p> 653</p>
      <p> 10950 put_block(bp, DIRECTORY_BLOCK);</p>
      <p> 10951 ldir_ptr-&gt;i_modtime = clock_time();</p>
      <p> 10952 ldir_ptr-&gt;i_dirt = DIRTY;</p>
      <p> 10953 if (new_slots &gt; old_slots)</p>
      <p> 10954 ldir_ptr-&gt;i_size = (file_pos) new_slots * DIR_ENTRY_SIZE;</p>
      <p> 10955 return(OK);</p>
      <p> 10956 }</p>
      <p> 654 File: fs/mount.c MINIX SOURCE CODE</p>
      <p> 11000 /* This file performs the MOUNT and UMOUNT system calls.</p>
      <p> 11001 *</p>
      <p> 11002 * The entry points into this file are</p>
      <p> 11003 *    do_mount:   perform the MOUNT system call</p>
      <p> 11004 *     do_umount: perform the UMOUNT system call</p>
      <p> 11005 */ 11006</p>
      <p> 11007 ^include "../h/const.h"</p>
      <p> 11008 iCinclude ". ./h/type.h"</p>
      <p> 11009 ^include "../h/error.h"</p>
      <p> 11010 ^include "const.h"</p>
      <p> 11011 ^include "type.h"</p>
      <p> 11012 ^include "buf.h"</p>
      <p> 11013 ^include "file.h"</p>
      <p> 11014 ^include "fproc.h"</p>
      <p> 11015 ^include "glo.h"</p>
      <p> 11016 ^include "inode.h"</p>
      <p> 11017 ^include "param.h"</p>
      <p> 11018 ^include "super.h" 11019</p>
      <p> 11020 /#= = = = = = = = = = = = = = ======= = = === === = = r== = = = r = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 11021 # do_mount *</p>
      <p> 11022 * = = = = = = : = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = = = = =: = = = = : = = r = = = = = r = = = = = = = = = = = = = = = =: = = */</p>
      <p> 11023 PUBLIC int do_mount()</p>
      <p> 11024 {</p>
      <p> 11025 /* Perform the mount(name, mfile, rd_only) system call. #/ 11026</p>
      <p> 11027 register struct inode *rip, *root_ipj</p>
      <p> 11028 register struct super_block *xp, *spj</p>
      <p> 11029 register dev_nr dev;</p>
      <p> 11030 register mask_bits bits;</p>
      <p> 11031 register int r;</p>
      <p> 11032 int found;</p>
      <p> 11033 extern struct inode *get_inode(), *eat_path();</p>
      <p> 11034 extern dev_nr name_to_dev(); 11035</p>
      <p> 11036 /* Only the super-user may do MOUNT. #/</p>
      <p> 11037 if (!super_user) return(EPERM); 11038</p>
      <p> 11039 /# If 'name' is not for a block special file, return error. */</p>
      <p> 11040 if (fetch_name(namel, namel_length, Ml) != OK) return(err_code);</p>
      <p> 11041 if ( (dev = name_to_dev(user_path)) == N0_DEV) return(err_code); 11042</p>
      <p> 11043 /* Scan super block table to see if dev already mounted &amp; find a free slot.*/</p>
      <p> 11044 sp = NIL_SUPER;</p>
      <p> 11045 found = FALSE;</p>
      <p> 11046 for (xp = &amp;super_block[0]; xp &lt; &amp;super_block[NR_SUPERS]; xp++) {</p>
      <p> 11047 if (xp-&gt;s_dev — dev) found = TRUE; /* is it mounted already? */</p>
      <p> 11048 if (xp-&gt;s_dev == N0_DEV) sp = xp; /* record free slot */</p>
      <p> 11049 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/mount.c</p>
      <p> 655</p>
      <p> 656 File: fs/mount.c MINIX SOURCE CODE</p>
      <p> 11100 } 11101</p>
      <p> 11102 /* File types of 'rip' and 'root_ip' may not conflict. */</p>
      <p> 11103 if ( (rip-&gt;i_mode &amp; I_TYPE) == I-DIRECTORY &amp;&amp;</p>
      <p> 11104 (root_ip-&gt;i_mode &amp; I_TYPE) != I_DIRECT0RY) r = EN0TDIR; 11105</p>
      <p> 11106 /# If error, return the super block and both inodes. ♦/</p>
      <p> 11107 if (r != OK) {</p>
      <p> 11108 sp-&gt;s_dev = N0_DEV;</p>
      <p> 11109 put_inode(rip);</p>
      <p> 11110 put_inode(root_ip);</p>
      <p> 11111 return(r);</p>
      <p> 11112 } 11113</p>
      <p> 11114 /* Nothing else can go wrong.    Perform the mount. */</p>
      <p> 11115 rip-&gt;i_mount = I_M0UNT; /# this bit says the inode is mounted on */</p>
      <p> 11116 sp-&gt;s_imount = rip;</p>
      <p> 11117 sp-&gt;s_isup = root_ip;</p>
      <p> 11118 sp-&gt;s_rd_only = rd_only;</p>
      <p> 11119 return(OK);</p>
      <p> 11120 }</p>
      <p> 11123</p>
      <p> 11124 * do_umount *</p>
      <p> 11125 # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = *,</p>
      <p> 11126 PUBLIC int do_umount()</p>
      <p> 11127 {</p>
      <p> 11128 /* Perform the umount(name) system call. #/ 11129</p>
      <p> 11130 register struct inode *rip;</p>
      <p> 11131 struct super_block *sp, *spl;</p>
      <p> 11132 dev_nr dev;</p>
      <p> 11133 int count;</p>
      <p> 11134 extern dev_nr name_to_dev(); 11135</p>
      <p> 11136</p>
      <p> 11137 /* Only the super-user may do UM0UNT. */</p>
      <p> 11138 if (!super_user) return(EPERM); 11139</p>
      <p> 11140 /* If 'name' is not for a block special file, return error. */</p>
      <p> 11141 if (fetch_name(name, name_length, M3) != OK) return(err_code);</p>
      <p> 11142 if ( (dev = name_to_dev(user_path)) == N0_.DEV) return(err_code); 11143</p>
      <p> 11144 /* See if the mounted device is busy.   Only 1 inode using it should be</p>
      <p> 11145 # open — the root inode — and that inode only 1 time.</p>
      <p> 11146 */</p>
      <p> 11147 count = 0;</p>
      <p> 11148 for (rip = &amp;inode[0]; rip&lt; &amp;inode[NR_IN0DES] ; rip++)</p>
      <p> 11149 if (rip-&gt;i_count &gt; 0 &amp;&amp; rip-&gt;i_dev == dev) count += rip-&gt;i_count;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/mount.c</p>
      <p> 657</p>
      <p> 11150 if (count &gt; 1) return(EBUSY); /* can't umount a busy file system #/ 11151</p>
      <p> 11152  /*  Find the super block. */</p>
      <p> 11153 sp = NIL_SUPER;</p>
      <p> 11154 for (spl = &amp;super_block[0]; spl &lt; &amp;super_block[NR_SUPERS]; spl++) {</p>
      <p> 11155 if (spl-&gt;s_dev == dev) {</p>
      <p> 11156 sp = spl;</p>
      <p> 11157 break;</p>
      <p> 11158 }</p>
      <p> 11159 }</p>
      <p> 11160 if (sp == NIL_SUPER) return(EINVAL); 11161</p>
      <p> 11162 /# Release the bit maps, sync the disk, and invalidate cache. */</p>
      <p> 11163 if (unload_bit_maps(dev) != OK) panic("do_umount", N0_NUM);</p>
      <p> 11164 do_sync(); /* force any cached blocks out of memory */</p>
      <p> 11165 invalidate(dev); /* invalidate cache entries for this dev */ 11166</p>
      <p> 11167 /* Finish off the unmount. */</p>
      <p> 11168 sp-&gt;s_imount-&gt;i_mount = N0_M0UNT; /* inode returns to normal */</p>
      <p> 11169 put_inode(sp-&gt;s_imount); /* release the inode mounted on */</p>
      <p> 11170 put_inode(sp-&gt;s_isup); /* release the root inode of the mounted fs */</p>
      <p> 11171 sp-&gt;s_imount = Nil INODE;</p>
      <p> 11172 sp-&gt;s_dev = N0_DEV;</p>
      <p> 11173 return(OK);</p>
      <p> 11174 }</p>
      <p> 11177 /* = = r = = = = r = = = = = z = : = = : = = = = = = = =  =  = r = r = = = = z = = = = = = z = = : =  : : = = = = = z  =   =  = rz = =  =  = = = = = = = = = = =  =  *</p>
      <p> 11178 * name_to_dev *</p>
      <p> 11179 »: :: == : = :: =======:= : : : = : = = ==: :::==:::::::: = ;::=:: : =:::::::::::::::;=;===;=:: »/</p>
      <p> 11180 PRIVATE dev_nr name_to_dev(path)</p>
      <p> 11181 char *path; /* pointer to path name */</p>
      <p> 11182 {</p>
      <p> 11183 /# Convert the block special file 'path' to a device number.    If 'path'</p>
      <p> 11184 * is not a block special file, return error code in 'err_code'.</p>
      <p> 11185 */ 11186</p>
      <p> 11187 register struct inode *rip;</p>
      <p> 11188 register dev_nr dev;</p>
      <p> 11189 extern struct inode *eat_path(); 11190</p>
      <p> 11191 /* If 'path' can't be opened, give up immediately. #/</p>
      <p> 11192 if ( (rip = eat_path(path)) — Nil INODE) return(NO_DEV);</p>
      <p> 11193</p>
      <p> 11194 /+ If 'path' is not a block special file, return error. */</p>
      <p> 11195 if ( (rip-&gt;i_mode &amp; I_TYPE) != I_BLOCK_SPECIAL) {</p>
      <p> 11196 err_code = ENOTBLK;</p>
      <p> 11197 put_inode(rip);</p>
      <p> 11198 return(NO_DEV);</p>
      <p> 11199 }</p>
      <p> 658 File: fs/mount.c MINIX SOURCE CODE</p>
      <p> 11200</p>
      <p> 11201 /* Extract the device number. */</p>
      <p> 11202 dev = (dev_nr) rip-&gt;i_zone[0];</p>
      <p> 11203 put_inode(rip);</p>
      <p> 11204 return(dev);</p>
      <p> 11205 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/link.c</p>
      <p> 659</p>
      <p> 11250 /* This file handles the LINK and UNLINK system calls.    It also deals with</p>
      <p> 11251 * deallocating the storage used by a file when the last UNLINK is done to a</p>
      <p> 11252 * file and the blocks must be returned to the free block pool.</p>
      <p> 11253 *</p>
      <p> 11254 # The entry points into this file are</p>
      <p> 11255 *     do_link:     perform the LINK system call</p>
      <p> 11256 *     do_unlink: perform the UNLINK system call</p>
      <p> 11257 *     truncate:    release all the blocks associated with an inode</p>
      <p> 11258 */ 11259</p>
      <p> 11260 ^include "../h/const.h"</p>
      <p> 11261 ^include "../h/type.h"</p>
      <p> 11262 ^include "../h/error.h"</p>
      <p> 11263 ^include "const.h"</p>
      <p> 11264 ^include "type.h"</p>
      <p> 11265 ^include "buf.h"</p>
      <p> 11266 ^include "file.h"</p>
      <p> 11267 ^include "fproc.h"</p>
      <p> 11268 ^include "glo.h"</p>
      <p> 11269 ^include "inode.h"</p>
      <p> 11270 ^include "param.h" 11271</p>
      <p> 11272 7* = = = =: = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = :: = = = = = = = = = = = = = =:=: = = = = = = ^ = = = = = = = = = = = =</p>
      <p> 11273 * do_link</p>
      <p> 11274 *============================================= = ============== ===============</p>
      <p> 11275 PUBLIC int do_link()</p>
      <p> 11276 {</p>
      <p> 11277 /* Perform the link(namel, name2) system call. */ 11278</p>
      <p> 11279 register struct inode *ip, *rip;</p>
      <p> 11280 register int r;</p>
      <p> 11281 char string[NAME_SIZE];</p>
      <p> 11282 struct inode *new_ip;</p>
      <p> 11283 extern struct inode *advance(), *l.ist_dir () , *eat_path(); 11284</p>
      <p> 11285 /* See if 'name'  (file to be linked) exists. */</p>
      <p> 11286 if (fetch_name(namel, namel_length, Ml)  != OK) return(err_code);</p>
      <p> 11287 if (  (rip = eat_path(user_path)) == Nil INODE) return(err_code);</p>
      <p> 11288</p>
      <p> 11289  /*  Check to see if the file has maximum number of links already.  */</p>
      <p> 11290 r = OK;</p>
      <p> 11291 if ( (rip-&gt;i_nlinks &amp; BYTE) == MAX_LINKS) r = EMLINK; 11292</p>
      <p> 11293 /* Only super_user may link to directories. */</p>
      <p> 11294 if (r == OK)</p>
      <p> 11295 if ( (rip-&gt;i_mode &amp; I_TYPE) == I_DIRECTORY &amp;&amp; !super_user) r = EPERM; 11296</p>
      <p> 11297 /* If error with 'name', return the inode. */</p>
      <p> 11298 if (r != OK) {</p>
      <p> 11299 put_inode(rip);</p>
      <p> 660 File: fs/link.c MINIX SOURCE CODE</p>
      <p> 11300 return(r);</p>
      <p> 11301 } 11302</p>
      <p> 11303 /* Does the final directory of 'name2' exist? */</p>
      <p> 11304 if (fetch_name(name2, name2_length, Ml) != OK) return(err_code);</p>
      <p> 11305 if ( (ip = last_dir(user_path, string)) == Nil—IN0DE) r = err_code; 11306</p>
      <p> 11307 /* If 'name2' exists in full (even if no space) set 'r' to error. */</p>
      <p> 11308 if (r == OK) {</p>
      <p> 11309 if ( (new_ip = advance(ip, string)) = = Nil—IN0DE) {</p>
      <p> 11310 r = err_code;</p>
      <p> 11311 if (r == EN0ENT) r = OK;</p>
      <p> 11312 } else {</p>
      <p> 11313 put_inode(new_ip);</p>
      <p> 11314 r = EEXIST;</p>
      <p> 11315 }</p>
      <p> 11316 } 11317</p>
      <p> 11318 /* Check for links across devices. */</p>
      <p> 11319 if (r == OK)</p>
      <p> 11320 if (rip-&gt;i_dev != ip-&gt;i_dev) r = EXDEV; 11321</p>
      <p> 11322 /* Try to link. */</p>
      <p> 11323 if (r OK)</p>
      <p> 11324 r = search_dir(ip, string, &amp;rip-&gt;i_num, ENTER); 11325</p>
      <p> 11326 /* If success, register the linking. */</p>
      <p> 11327 if (r == OK) {</p>
      <p> 11328 rip-&gt;i_nlinks++;</p>
      <p> 11329 rip-&gt;i_dirt = DIRTY;</p>
      <p> 11330 } 11331</p>
      <p> 11332 /* Done.   Release both inodes. */</p>
      <p> 11333 put_inode(rip);</p>
      <p> 11334 put_inode(ip);</p>
      <p> 11335 return(r);</p>
      <p> 11336 }</p>
      <p> 11339 /»  =   =  = =: = r = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = = = = = = = = = - = r= = = = = = = = = = = = = = =</p>
      <p> 11340 * do_unlink</p>
      <p> 11341 ♦= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = == = = = = = = = = = = = = = =:=: = =</p>
      <p> 11342 PUBLIC int do_unlink()</p>
      <p> 11343 {</p>
      <p> 11344 /* Perform the unlink(name) system call. */ 11345</p>
      <p> 11346 register struct inode *rip, #rlast_dir_ptr;</p>
      <p> 11347 register int r;</p>
      <p> 11348 inode_nr numb;</p>
      <p> 11349 char string[NAME_SIZE];</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/link.c</p>
      <p> 661</p>
      <p> 11350 extern struct inode *advance(), #last_dir(); 11351</p>
      <p> 11352 /* Get the last directory in the path. */</p>
      <p> 11353 if (fetch_name(name, name_length, M3).!= OK) return(err_code);</p>
      <p> 11354 if ( (rlast_dir_ptr = last_dir(user_path, string)) == Nil INODE)</p>
      <p> 11355 return(err_code); 11356</p>
      <p> 11357 /* The last directory exists.   Does the file also exist? ♦/</p>
      <p> 11358 r = OK;</p>
      <p> 11359 if ( (rip = advance(rlast_dir_ptr, string)) == Nil INODE) r = err_code;</p>
      <p> 11360</p>
      <p> 11361 /* If error, return inode. */</p>
      <p> 11362 if (r != OK) {</p>
      <p> 11363 put_inode(rlast_dir_ptr);</p>
      <p> 11364 return(r);</p>
      <p> 11365 } 11366</p>
      <p> 11367 /* See if the file is a directory. */</p>
      <p> 11368 if ( (rip-&gt;i_mode &amp; I_TYPE) — I-DIRECTORY &amp;&amp; !super_user)</p>
      <p> 11369 r = EPERM; /* only super_user can unlink directory */</p>
      <p> 11370 if (r == OK)</p>
      <p> 11371 r = search_dir(rlast_dir_ptr, string, &amp;numb, DELETE); 11372</p>
      <p> 11373 if (r == OK) {</p>
      <p> 11374 rip-&gt;i_nlinks--;</p>
      <p> 11375 rip-&gt;i_dirt = DIRTY;</p>
      <p> 11376 } 11377</p>
      <p> 11378 /* If unlink was possible, it has been done, otherwise it has not. */</p>
      <p> 11379 put_inode(rip);</p>
      <p> 11380 put_inode(rlast_dir_ptr);</p>
      <p> 11381 return(r);</p>
      <p> 11382 }</p>
      <p> 11385 /#= = = = = = = = = = = = = = = = = = = = = = = = z = r = = = = = = = = = = = = = = = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =  -  =   =   =   =   =   =  -  =   =</p>
      <p> 11386 * truncate 11387</p>
      <p> 11388 PUBLIC truncate(rip)</p>
      <p> 11389 register struct inode *rip; /# pointer to inode to be truncated */</p>
      <p> 11390 {</p>
      <p> 11391 /* Remove all the zones from the inode 'rip' and mark it dirty. */ 11392</p>
      <p> 11393 register file_pos position;</p>
      <p> 11394 register zone_type zone_size;</p>
      <p> 11395 register block_nr b;</p>
      <p> 11396 register zone_nr z, *iz;</p>
      <p> 11397 register int scale;</p>
      <p> 11398 register struct buf *bp;</p>
      <p> 11399 register dev_nr dev;</p>
      <p> File: fs/link.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 11400 extern struct buf *get_block();</p>
      <p> 11401 extern block_nr read_map(); 11402</p>
      <p> 11403 dev = rip-&gt;i_dev; /* device on which inode resides */</p>
      <p> 11404 scale = scale_factor(rip);</p>
      <p> 11405 zone_size = (zone_type) BL0CK_SIZE « scale;</p>
      <p> 11406 if (rip-&gt;i_pipe == I_PIPE) rip-&gt;i_size = PIPE_SIZE; /* pipes can shrink */ 11407</p>
      <p> 11408 /* Step through the file a zone at a time, finding and freeing the zones. */</p>
      <p> 11409 for (position = 0; position &lt; rip-&gt;i_size; position += zone_size) {</p>
      <p> 11410 if ( (b = read_map(rip, position)) != N0_BL0CK) {</p>
      <p> 11411  z  = (zone_nr) b &gt;&gt; scale;</p>
      <p> 11412 free_zone(dev, z);</p>
      <p> 11413 }</p>
      <p> 11414 } 11415</p>
      <p> 11416 /* All the data zones have been freed.    Now free the indirect zones. *•/</p>
      <p> 11417 free_zone(dev, rip-&gt;i_zone[NRJDZ0NE_NUM]);       /* single indirect zone */</p>
      <p> 11418 if ( (z = rip-&gt;i_zone[NR_DZ0NE_NUM+l]) != N0_Z0NE) {</p>
      <p> 11419 b = (block_nr) z &lt;&lt; scale;</p>
      <p> 11420 bp = get_block(dev, b, NORMAL); /* get double indirect zone */</p>
      <p> 11421 for (iz = &amp;bp-&gt;b_ind[0]; iz &lt; &amp;bp-&gt;b._ind[NR_INDIRECTS]; iz++) {</p>
      <p> 11422 free_zone(dev, *iz);</p>
      <p> 11423 } 11424</p>
      <p> 11425 /♦ Now free the double indirect zone itself. */</p>
      <p> 11426 put_block(bp, INDIRECT_BL0CK);</p>
      <p> 11427 free_zone(dev, z);</p>
      <p> 11428 } 11429</p>
      <p> 11430 /* The inode being truncated might currently be open, so certain fields must</p>
      <p> 11431 * be cleared immediately, even though these fields are also cleared by</p>
      <p> 11432 * alloc_inode(). The function wipe_inode() does the dirty work in both cases</p>
      <p> 11433 #/</p>
      <p> 11434 wipe_inode(rip);</p>
      <p> 11435 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/stadir.c</p>
      <p> 663</p>
      <p> 11450 /* This file contains the code for performing four system calls relating to</p>
      <p> 11451 # status and directories.</p>
      <p> 11452 *</p>
      <p> 11453 * The entry points into this file are</p>
      <p> 11454 *    do_chdir:   perform the CHDIR system call</p>
      <p> 11455 *     do_chroot: perform the CHROOT system call</p>
      <p> 11456 *    do_stat:     perform the STAT system call</p>
      <p> 11457 *     do_fstat:   perform the FSTAT system call</p>
      <p> 11458 »/ 11459</p>
      <p> 11460 ^include "../h/const.h"</p>
      <p> 11461 ^include "../h/type.h"</p>
      <p> 11462 //include "../h/error.h"</p>
      <p> 11463 //include "../h/stat.h"</p>
      <p> 11464 //include "const.h"</p>
      <p> 11465 //include "type.h"</p>
      <p> 11466 //include "file.h"</p>
      <p> 11467 /(include "fproc.h"</p>
      <p> 11468 ^include "glo.h"</p>
      <p> 11469 //include "inode.h"</p>
      <p> 11470 //include "param.h" 11471</p>
      <p> 11472 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = == = = = = = = = = = = = ;: = = = = = = = = = = = = = *</p>
      <p> 11473 * do_chdir *</p>
      <p> 11475 PUBLIC int do_chdlr()</p>
      <p> 11476 {</p>
      <p> 11477 /* Change directory.   This function is   also called by MM to simulate a chdir</p>
      <p> 11478 * in order to do EXEC, etc.</p>
      <p> 11479 */ 11480</p>
      <p> 11481 register struct fproc *rfp; 11482</p>
      <p> 11483 if (who == MM_PR0C_NR) {</p>
      <p> 11484 rfp = &amp;fproc[slotl];</p>
      <p> 11485 put_inode(fp-&gt;fp_workdir);</p>
      <p> 11486 fp-&gt;fp_workdir = (cd_flag ? fp-&gt;fp_rootdir : rfp-&gt;fp_workdir);</p>
      <p> 11487 dup_inode(fp-&gt;fp_workdir);</p>
      <p> 11488 fp-&gt;fp_effuid = (cd_flag ? SUPER_USER : rfp-&gt;fp_effuid);</p>
      <p> 11489 return(OK);</p>
      <p> 11490 } 11491</p>
      <p> 11492 /* Perform the chdir(name) system call. */</p>
      <p> 11493 return change(&amp;fp-&gt;fp_workdir, name, name_length);</p>
      <p> 11494 }</p>
      <p> 11497 7* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = :: = = ^ = = = = = = = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 11498 * do_chroot *</p>
      <p> 11499 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = z = = = = = = = = = = - = - = =  =   =  =  =  ;- = z  =  = = = = r = = = = = */</p>
      <p> File: fs/stadir.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 11500 PUBLIC int do_chroot()</p>
      <p> 11501 {</p>
      <p> 11502 /* Perform the chroot(name) system call. */ 11503</p>
      <p> 11504 register int r;</p>
      <p> 11505</p>
      <p> 11506 if (! super_user) return(EPERM); /♦ only su may chrootO */</p>
      <p> 11507 r = change(&amp;fp-&gt;fp_rootdir, name, name_length);</p>
      <p> 11508 return(r);</p>
      <p> 11509 }</p>
      <p> 11512 11513 11514 11515 11516 11517 11518 11519 11520 11521 11522 11523 11524 11525 11526 11527 11528 11529 11530 11531 11532 11533 11534 11535 11536 11537 11538 11539 11540 11541 11542 11543 11544 11545 11546</p>
      <p> /»=====:::=:===========::::::==============:::::=:===========:==============:*</p>
      <p> * change *</p>
      <p> PRIVATE int changedip, name_ptr, len)</p>
      <p> struct inode **iip; /* pointer to the inode pointer for the dir */</p>
      <p> char *name_ptr; /* pointer to the directory name to change to */</p>
      <p> int len; /# length of the directory name string ♦/ {</p>
      <p> I*  Do the actual work for chdirO and chrootO. */</p>
      <p> struct inode *rip; register int r;</p>
      <p> extern struct inode #eat_path();</p>
      <p> /* Try to open the new directory. */</p>
      <p> if (fetch_name(name_ptr, len, M3)  \-  OK) return(err_code);</p>
      <p> if ( (rip = eat_path(user_path)) == Nil INODE) return(err_code);</p>
      <p> /* It must be a directory and also be searchable. */ if ( (rip-&gt;i_mode &amp; I_TYPE) != I_DIRECT0RY) r = EN0TDIR;</p>
      <p> else</p>
      <p> r = forbidden(rip, X_BIT, 0);     /* check if dir is searchable */</p>
      <p> /* If error, return inode. */ if (r != OK) {</p>
      <p> put_inode(rip);</p>
      <p> return(r);</p>
      <p> }</p>
      <p> /* Everything is OK. put_inode(*iip); *iip = rip; return(OK);</p>
      <p> Make the change. */</p>
      <p> /* release the old directory */ /* acquire the new one */</p>
      <p> MINIX SOURCE CODE File: fs/stadir.c 665</p>
      <p> 11550 /*r========================zr===== = -z===:==== = ===========================:====*</p>
      <p> 11551 * do_stat *</p>
      <p> 11553 PUBLIC int do_stat()</p>
      <p> 11554 {</p>
      <p> 11555 /* Perform the stat(name, buf) system call. */ 11556</p>
      <p> 11557 register struct inode *rip;</p>
      <p> 11558 register int r;</p>
      <p> 11559 extern struct inode »eat_path(); 11560</p>
      <p> 11561 /# Both statO and fstatO use the sane routine to do the real work. That</p>
      <p> 11562 * routine expects an inode, so acquire it temporarily.</p>
      <p> 11563 */</p>
      <p> 11564 if (fetch_name(namel, namel_length, Ml) != OK) return(err_code);</p>
      <p> 11565 if ( (rip = eat_path(user_path)) == Nil INODE) return(err_code);</p>
      <p> 11566 r = stat_inode(rip, Nil FILP, name2); /* actually do the work.*/</p>
      <p> 11567 put_inode(rip); /* release the inode #/</p>
      <p> 11568 return(r);</p>
      <p> 11569 }</p>
      <p> 11572 /»::::::: = = = = = ::::: = = :: = =:: = :::: = " = -: = "=::=:=:: = = = : = =: = = = = = = = = = = = = =: = = = = = =»</p>
      <p> 11573 * do_fstat *</p>
      <p> 11574 * = = = = = =  =  -  =   =   =   =  -=: = = r = r = = = = = = = = = = =  =  =: = = = = = = = =  =  r =  =  = r = = = = = = = = = = = = = r = = = = = = = =  : : = =: = = = = */</p>
      <p> 11575 PUBLIC int do_fstat()</p>
      <p> 11576 {</p>
      <p> 11577 /* Perform the fstat(fd, buf) system call. */ 11578</p>
      <p> 11579 register struct filp *rfilp;</p>
      <p> 11580 extern struct filp *get_filp(); 11581</p>
      <p> 11582 /* Is the file descriptor valid? */</p>
      <p> 11583 if ( (rfilp = get_filp(fd)) == NIL_FILP) return(err_code); 11584</p>
      <p> 11585 return(stat_inode(rfilp-&gt;filp_ino, rfilp, buffer));</p>
      <p> 11586 }</p>
      <p> 11589 /« : = =  ::: :: ::::: " : : =  : :""":": :: : :::::  = = = : = = === = : = = :==== =  :: =::: = = = :::": :  = »</p>
      <p> 11590 * stat_inode *</p>
      <p> 11591 «=:::::::::::::::"::::::":::::==:::::::=:: = = = === = = = :: = ::=" ==:== = = = = = = = = ==»/</p>
      <p> 11592 PRIVATE int stat_inode(rip, fil_ptr, user_addr)</p>
      <p> 11593 register struct inode *rip; /* pointer to inode to stat */</p>
      <p> 11594 struct filp *fil_ptr; /* filp pointer, supplied by 'fstat' #/</p>
      <p> 11595 char *user_addr; /# user space address where stat buf go'</p>
      <p> 11596 {</p>
      <p> 11597 /* Common code for stat and fstat system calls. */ 11598</p>
      <p> 11599 register struct stat #stp;</p>
      <p> 666 File: fs/stsdir c MINIX SOURCE CODE</p>
      <p> 11600 struct stat statbuf;</p>
      <p> 11601 int r;</p>
      <p> 11602 vir_bytes v; 11603</p>
      <p> 11604 /* Fill in the statbuf struct. */</p>
      <p> 11605 stp = &amp;statbuf; /* set up pointer to the buffer */</p>
      <p> 11606 stp-&gt;st_dev = (int) rip-&gt;i_dev;</p>
      <p> 11607 stp-&gt;st_ino = rip-&gt;i_num;</p>
      <p> 11608 stp-&gt;st_mode = rip-&gt;i_mode;</p>
      <p> 11609 stp-&gt;st_nlink = rip-&gt;i_nlinks &amp; BYTE;</p>
      <p> 11610 stp-&gt;st_uid = rip-&gt;i_uid;</p>
      <p> 11611 stp-&gt;st_gid = rip-&gt;i_gid &amp; BYTE;</p>
      <p> 11612 stp-&gt;st_rdev = rip-&gt;i_zone[0];</p>
      <p> 11613 stp-&gt;st_size = rip-&gt;i_size;</p>
      <p> 11614 if (   (rip-&gt;i_pipe == I_PIPE) &amp;&amp; /* IF" it is a pipe */</p>
      <p> 11615 (fil_ptr != NIL_FILP) &amp;&amp; /* AND it was fstat */</p>
      <p> 11616 (fil_ptr-&gt;filp_mode == FL.BIT))   /* on the reading end, */</p>
      <p> 11617 stp-&gt;st_size -= fil_ptr-&gt;filp_pos;  /*  adjust the visible size. */</p>
      <p> 11618 stp-&gt;st_atime = rip-&gt;i_modtime;</p>
      <p> 11619 stp-&gt;st_mtime = rip-&gt;i_modtime;</p>
      <p> 11620 stp-&gt;st_ctime = rip-&gt;i_modtime; 11621</p>
      <p> 11622  /*  Copy the struct to user space. */</p>
      <p> 11623 v = (vir_bytes) user_addr;</p>
      <p> 11624 r = rw_user(D, who, v, (vir_bytes) sizeof statbuf, (char ») stp, T0_USER);</p>
      <p> 11625 return(r);</p>
      <p> 11626 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/protect.c</p>
      <p> 667</p>
      <p> 11650 /* This file deals with protection in the file system.    It contains the code</p>
      <p> 11651 * for four system calls that relate to protection.</p>
      <p> 11652 *</p>
      <p> 11653 * The entry points into this file are</p>
      <p> 11654 »     do_chmod:   perform the CHMOD system call</p>
      <p> 11655 #     do_chown:   perform the CHOWN system call</p>
      <p> 11656 *     do_umask:   perform the UMASK system call</p>
      <p> 11657 #    do_access: perform the ACCESS system call</p>
      <p> 11658 *     forbidden: check to see if a given access is allowed on a given inode</p>
      <p> 11659 */ 11660</p>
      <p> 11661 //include ". ./h/const.h"</p>
      <p> 11662 //include ". ./h/type. h"</p>
      <p> 11663 //include ". ./h/error.h"</p>
      <p> 11664 //include "const.h"</p>
      <p> 11665 /(include "type.h"</p>
      <p> 11666 //include "buf.h"</p>
      <p> 11667 //include "file.h"</p>
      <p> 11668 //include "fproc.h"</p>
      <p> 11669 //include "glo.h"</p>
      <p> 11670 //include "inode.h"</p>
      <p> 11671 //include "param.h"</p>
      <p> 11672 //include "super.h" 11673</p>
      <p> 11674 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = -:  =  = = r = = = = = = = = = = =: = = = = = = = = = = :</p>
      <p> 11675 * do_chmod</p>
      <p> 11676  = = = = = = = = = = = = = = = = = = = = = = —        = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   = .</p>
      <p> 11677 PUBLIC int do_chmod()</p>
      <p> 11678 [</p>
      <p> 11679 /* Perform the chmod(name, mode) system call. */ 11680</p>
      <p> 11681 register struct inode *rip;</p>
      <p> 11682 register int r;</p>
      <p> 11683 extern struct inode *eat_path()j 11684</p>
      <p> 11685 /* Temporarily open the file. */</p>
      <p> 11686 if (fetch_name(name, name_length, M3) != OK) return(err_code)j</p>
      <p> 11687 if ( (rip = eat_path(user_path)) == Nil INODE) return(err_code);</p>
      <p> 11688</p>
      <p> 11689 /* Only the owner or the super_user may change the mode of a file.</p>
      <p> 11690 * No one may change the mode of a file on a read-only file system.</p>
      <p> 11691 #/</p>
      <p> 11692 if (rip-&gt;i_uid != fp-&gt;fp_effuid 44 !super_user)</p>
      <p> 11693 r = EPERM;</p>
      <p> 11694 else</p>
      <p> 11695 r = read_only(rip); 11696</p>
      <p> 11697 /* If error, return inode. */</p>
      <p> 11698 if (r != OK) {</p>
      <p> 11699 put_inode(rip);</p>
      <p> 668 File: fs/protect.c MINIX SOURCE CODE</p>
      <p> 11700 return(r);</p>
      <p> 11701 } 11702</p>
      <p> 11703 /* Now make the change. */</p>
      <p> 11704 rip-&gt;i_mode = (rip-&gt;i_mode &amp; ~ALI MODES) |  (mode &amp; ALI MODES);</p>
      <p> 11705 rip-&gt;i_dirt = DIRTY; 11706</p>
      <p> 11707 put_inode(rip);</p>
      <p> 11708 return(OK);</p>
      <p> 11709 }</p>
      <p> 11712 /*====================r====:==================================================*</p>
      <p> 11713 * do_chown *</p>
      <p> 11714 *===========================================================================*/</p>
      <p> 11715 PUBLIC int do_chown()</p>
      <p> 11716 {</p>
      <p> 11717 /* Perform the chown(name, owner, group) system call. */ 11718</p>
      <p> 11719 register struct inode *rip;</p>
      <p> 11720 register int r;</p>
      <p> 11721 extern struct inode *eat_path(); 11722</p>
      <p> 11723 /* Only the super_user may perform the chown() call. */</p>
      <p> 11724 if (!super_user) return(EPERM) j 11725</p>
      <p> 11726 /* Temporarily open the file. */</p>
      <p> 11727 if (fetch_name(namel, namel_length, Ml) != OK) return(err_code);</p>
      <p> 11728 if ( (rip = eat_path(user_path)) == NIL_IN0DE) return(err_code); 11729</p>
      <p> 11730 /♦ Not permitted to change the owner of a file on a read-only file sys. */</p>
      <p> 11731 r = read_only(rip);</p>
      <p> 11732 if (r == OK) {</p>
      <p> 11733 rip-&gt;i_uid = owner;</p>
      <p> 11734 rip-&gt;i_gid = group;</p>
      <p> 11735 rip-&gt;i_dirt = DIRTY;</p>
      <p> 11736 } 11737</p>
      <p> 11738 put_inode(rip);</p>
      <p> 11739 return(r);</p>
      <p> 11740 }</p>
      <p> 11743 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = =  =  = = = = = = = = = r = = = = =  =   =   =   =   =   ::   =   =   = :-*</p>
      <p> 11744 * do_umask *</p>
      <p> 11746 PUBLIC int do_umask()</p>
      <p> 11747 {</p>
      <p> 11748 /* Perform the umask(co_mode) system call. */</p>
      <p> 11749 register mask_bits r;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/protect.c</p>
      <p> 669</p>
      <p> 11750</p>
      <p> 11751 r = ~fp-&gt;fp_umask; /* set 'r'  to complement of old mask */</p>
      <p> 11752 fp-&gt;fp_umask = ~(co_mode &amp; RWX_M0DES);</p>
      <p> 11753 return(r); /# return complement of old mask */</p>
      <p> 11754 }</p>
      <p> 11757 /*=================================== = = = ================ ==== == =============== *</p>
      <p> 11758 * do_access *</p>
      <p> 11759 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = =  =  =  =   =   =   =   =   = :  =   =   =  =  =   =:   =   =   =   =   =   =   =   =   =   =   =   =   =  */</p>
      <p> 11760 PUBLIC int do_access()</p>
      <p> 11761 {</p>
      <p> 11762 /* Perform the access(name, mode) system call.  +/ 11763</p>
      <p> 11764 struct inode *rip;</p>
      <p> 11765 register int r;</p>
      <p> 11766 extern struct inode *eat_path(); 11767</p>
      <p> 11768 /* Temporarily open the file whose access is to be checked. */</p>
      <p> 11769 if (fetch_name(name, name_length, M3)  != OK) return(err_code);</p>
      <p> 11770 if ( (rip = eat_path(user_path))  --  Nil INODE) return(err_code);</p>
      <p> 11771</p>
      <p> 11772 /* Now check the permissions. */</p>
      <p> 11773 r = forbidden(rip,  (mask_bits) mode, 1);</p>
      <p> 11774 put_inode(rip);</p>
      <p> 11775 return(r);</p>
      <p> 11776 }</p>
      <p> 11779 /*======================== = r============= ==================================== *</p>
      <p> 11780 * forbidden *</p>
      <p> 11781  * = — = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = — = — = = = = = = = = = = = = = = = = = = = = = = = = — */</p>
      <p> 11782 PUBLIC int forbidden(rip, access_desired, real_uid)</p>
      <p> 11783 register struct inode *rip; /* pointer to inode to be checked */</p>
      <p> 11784 mask_bits access_desired; /# RWX bits */</p>
      <p> 11785 int real_uid; /* set iff real uid to be tested */</p>
      <p> 11786 {</p>
      <p> 11787 /* Given a pointer to an inode,  'rip', and the access desired, determine</p>
      <p> 11788 * if the access is allowed, and if not why not.    The routine looks up the</p>
      <p> 11789 * caller's uid in the 'fproc' table.    If the access is allowed, OK is returned</p>
      <p> 11790 * if it is forbidden, EACCES is returned.</p>
      <p> 11791 */ 11792</p>
      <p> 11793 register mask_bits bits, perm_bits, xmask;</p>
      <p> 11794 int r, shift, test_uid, test_gid; 11795</p>
      <p> 11796 /* Isolate the relevant rwx bits from the mode. */</p>
      <p> 11797 bits = rip-&gt;i_mode;</p>
      <p> 11798 test_uid = (real_uid ? fp-&gt;fp_realuid : fp-&gt;fp_effuid);</p>
      <p> 11799 test_gid = (real_uid ? fp-&gt;fp_realgid :  fp-&gt;fp_effgid);</p>
      <p> 670 File: fs/protect.c MINIX SOURCE CODE</p>
      <p> 11800 if (super_user) {</p>
      <p> 11801 perm_bits = 07;</p>
      <p> 11802 } else {</p>
      <p> 11803 if (test_uid == rip-&gt;i_uid) shift = 6; /* owner #/</p>
      <p> 11804 else if (test_gid == rip-&gt;i_gid ) shift = 3;      /♦ group */</p>
      <p> 11805 else shift r 0; /* other */</p>
      <p> 11806 perm_bits = (bits » shift) &amp; 07;</p>
      <p> 11807 } 11808</p>
      <p> 11809 /* If access desired is not a subset of what is allowed, it is refused. */</p>
      <p> 11810 r = OK;</p>
      <p> 11811 if ((perm_bits | access_desired) != perm_bits) r = EACCES; 11812</p>
      <p> 11813 /* If none of the X bits are on, not even the super-user can execute it. */</p>
      <p> 11814 xmask = (X_BIT « 6) |  (X_BIT « 3) | X_BIT;   /* all 3 X bits */</p>
      <p> 11815 if ( (access_desired &amp; X_BIT) &amp;&amp; (bits &amp; xmask) == 0) r = EACCES; 11816</p>
      <p> 11817 /* Check to see if someone is trying to write on a file system that is</p>
      <p> 11818 * mounted read-only.</p>
      <p> 11819 */</p>
      <p> 11820 if (r == OK)</p>
      <p> 11821 if (access_desired 4 W_BIT) r = read_only(rip); 11822</p>
      <p> 11823 return(r);</p>
      <p> 11824 }</p>
      <p> 11827 /*===========================================================================*</p>
      <p> 11828 * read_only *</p>
      <p> 11829 * = = = = = = = = = = = = = = = = = = = = = = = = = = = :: = = = = = = = = = = = = = = = := = = = = = = = = = = -- = = = = = = = = = = = = = = = = = = = */</p>
      <p> 11830 PRIVATE int read_only(ip)</p>
      <p> 11831 struct inode #ip; /# ptr to inode whose file sys is to be eked */</p>
      <p> 11832 {</p>
      <p> 11833 /» Check to see if the file system on which the inode 'ip' resides is mounted</p>
      <p> 11834 * read only.    If so, return ER0FS, else return OK.</p>
      <p> 11835 */ 11836</p>
      <p> 11837 register struct super_block »sp;</p>
      <p> 11838 extern struct super_block *get_super(); 11839</p>
      <p> 11840 sp = get_super(ip-&gt;i_dev);</p>
      <p> 11841 return(sp-&gt;s_rd_only ? ER0FS : OK);</p>
      <p> 11842 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/time.c</p>
      <p> 671</p>
      <p> 11850 /♦ This file takes care of those system calls that deal with time.</p>
      <p> 11851 #</p>
      <p> 11852 * The entry points into this file are</p>
      <p> 11853 *     do_utime:   perform the UTIME system call</p>
      <p> 11854 *     do_time:     perform the TIME system call</p>
      <p> 11855 *     do_stime:   perform the STIME system call</p>
      <p> 11856 *    do_tims:     perform the TIMES system call</p>
      <p> 11857 */ 11858</p>
      <p> 11859 ^include "../h/const.h"</p>
      <p> 11860 ^include "../h/type.h"</p>
      <p> 11861 ^include "../h/callnr.h"</p>
      <p> 11862 ^include "../h/com.h"</p>
      <p> 11863 ^include "../h/error.h"</p>
      <p> 11864 ^include "const.h"</p>
      <p> 11865 ^include "type.h"</p>
      <p> 11866 ^include "file.h"</p>
      <p> 11867 ^include "fproc.h"</p>
      <p> 11868 ^include "glo.h"</p>
      <p> 11869 ^include "inode.h"</p>
      <p> 11870 ^include "param.h" 11871</p>
      <p> 11872 PRIVATE message clock_mess; 11873</p>
      <p> 11875 * do_utime</p>
      <p> 11877 PUBLIC int do_utime()</p>
      <p> 11878 {</p>
      <p> 11879 /* Perform the utime(name, timep) system call. */ 11880</p>
      <p> 11881 register struct inode *rip;</p>
      <p> 11882 register int r;</p>
      <p> 11883 extern struct inode *eat_path(); 11884</p>
      <p> 11885 /* Temporarily open the file. */</p>
      <p> 11886 if (fetch_name(utime_file, utime_length, Ml) != OK) return(err_code);</p>
      <p> 11887 if ( (rip = eat_path(user_path)) == Nil INODE) return(err_code);</p>
      <p> 11888</p>
      <p> 11889 /* Only the owner of a file or the super_user can change its time. */</p>
      <p> 11890 r = OK;</p>
      <p> 11891 if (rip-&gt;i_uid != fp-&gt;fp_effuid &amp;&amp; !super_user) r = EPERM;</p>
      <p> 11892 if (r == OK) {</p>
      <p> 11893 rip-&gt;i_modtime = update_time;</p>
      <p> 11894 rip-&gt;i_dirt = DIRTY;</p>
      <p> 11895 } 11896</p>
      <p> 11897 put_inode(rip);</p>
      <p> 11898 return(r);</p>
      <p> 11899 }</p>
      <p> 11902 11903 11904 11905 11906 11907 11908 11909 11910 11911 11912 11913 11914</p>
      <p> 11917 11918 11919 11920 11921 11922 11923 11924 11925 11926 11927 11928 11929 11930 11931</p>
      <p> 11934 11935 11936 11937 11938 11939 11940 11941 11942 11943 11944 11945 11946 11947 11948 11949</p>
      <p> File: fs/time.c MINIX SOURCE CODE</p>
      <p> /»===========================================================================*</p>
      <p> * do_time *</p>
      <p> *====================r=====r================================================#/</p>
      <p> PUBLIC int do_time()</p>
      <p> {</p>
      <p> /* Perform the time(tp) system call. */ extern real_time clock_time();</p>
      <p> reply_ll = clock_time(); /* return time in seconds #/</p>
      <p> return(OK);</p>
      <p> }</p>
      <p> /#===========================================================================*</p>
      <p> * do_stime *</p>
      <p> #===========================================================================#/</p>
      <p> PUBLIC int do_stime()</p>
      <p> {</p>
      <p> /» Perform the stime(tp) system call. */</p>
      <p> register int k;</p>
      <p> if (!super_user) return(EPERM); clock_mess.m_type = SET_TIME; clock_mess.NEW_TIME = (long) tp;</p>
      <p> if ( (k = sendrec(CL0CK, &amp;clock_mess)) != OK) panic("do_stime error", k); return (OK);</p>
      <p> }</p>
      <p> /♦===========================================================================*</p>
      <p> * do_tims *</p>
      <p> *===================================================================:========♦/</p>
      <p> PUBLIC int do_tims()</p>
      <p> {</p>
      <p> /* Perform the times(buffer) system call. */</p>
      <p> real-time t[4];</p>
      <p> sys_times(who, t); reply_tl = t[0]; reply_t2 = t[1]; reply_t3 = t[2]; reply_t4 = t[3]; return(OK);</p>
      <p> }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/misc.c</p>
      <p> 673</p>
      <p> 11950 /* This file contains a collection of miscellaneous procedures.   Some of them</p>
      <p> 11951 # perform simple system calls.   Some others do a little part of system calls</p>
      <p> 11952 * that are mostly performed by the Memory Manager.</p>
      <p> 11953 *</p>
      <p> 11954 * The entry points into this file are</p>
      <p> 11955 *     do_dup:       perform the DUP system call</p>
      <p> 11956 *     do_sync:     perform the SYNC system call</p>
      <p> 11957 *     do_fork:     adjust the tables after MM has performed a FORK system call</p>
      <p> 11958 *     do_exit:     a process has exited; note that in the tables</p>
      <p> 11959 *    do_set:      set uid or gid for some process</p>
      <p> 11960 *     do_revive: revive a process that was waiting for something (e.g. TTY)</p>
      <p> 11961 */ 11962</p>
      <p> 11963 /(include ". ./h/const.h"</p>
      <p> 11964 //include ". ./h/type. h"</p>
      <p> 11965 //include ". ./h/callnr. h"</p>
      <p> 11966 //include "../h/com.h"</p>
      <p> 11967 //include ". ./h/error.h"</p>
      <p> 11968 //include "const.h"</p>
      <p> 11969 //include "type.h"</p>
      <p> 11970 //include "buf.h"</p>
      <p> 11971 //include "file.h"</p>
      <p> 11972 #include "fproc.h"</p>
      <p> 11973 ^include "glo.h"</p>
      <p> 11974 //include "inode.h"</p>
      <p> 11975 //include "param.h"</p>
      <p> 11976 //include "super.h" 11977</p>
      <p> 11978 /»==================================== = ======== = ==== ==========</p>
      <p> 11979 * do_dup</p>
      <p> 11980 * = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = r=: = = = = =  =  r = = = = =  =   =   =   =   =   =   : : : :  =</p>
      <p> 11981 PUBLIC int do_dup()</p>
      <p> 11982 {</p>
      <p> 11983 /* Perform the dup(fd) or dup(fd,fd2) system call. */ 11984</p>
      <p> 11985 register int rfd;</p>
      <p> 11986 register struct fproc *rfp;</p>
      <p> 11987 struct filp *dummy;</p>
      <p> 11988 int r;</p>
      <p> 11989 extern struct filp *get_filp(); 11990</p>
      <p> 11991 /* Is the file descriptor valid? #/</p>
      <p> 11992 rfd = fd &amp; ~DUP_MASK;  I*  kill off dup2 bit, if on */</p>
      <p> 11993 rfp = fp;</p>
      <p> 11994 if (get_filp(rfd) == NIL_FILP) return(err_code); 11995</p>
      <p> 11996 /* Distinguish between dup and dup2. */</p>
      <p> 11997 if (fd == rfd) { /# bit not on */</p>
      <p> 11998 /* dup(fd) */</p>
      <p> 11999 if ( (r = get_fd(0, &amp;fd2, &amp;dummy)) != OK) return(r);</p>
      <p> File: fs/misc.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 12000 } else {</p>
      <p> 12001 /* dup2(fd, fd2) */</p>
      <p> 12002 if (fd2 &lt; 0 || fd2 &gt;= NR_FDS) return(EBADF);</p>
      <p> 12003 if (rfd == fd2) return(fd2);      /* ignore the call: dup2(x, x) */</p>
      <p> 12004 fd = fd2; /* prepare to close fd2 +/</p>
      <p> 12005 do_close(); /* cannot fail */</p>
      <p> 12006 } 12007</p>
      <p> 12008 /* Success. Set up new file descriptors. */</p>
      <p> 12009 rfp-&gt;fp_filp[fd2] = rfp-&gt;fp_filp[rfd];</p>
      <p> 12010 rfp-&gt;fp_filp[fd2]-&gt;filp_count++;</p>
      <p> 12011 return(fd2);</p>
      <p> 12012 }</p>
      <p> 12015 /*===========================================================================*</p>
      <p> 12016 * do_sync *</p>
      <p> 12017 ♦===========================================================================*</p>
      <p> 12018 PUBLIC int do_sync()</p>
      <p> 12019 {</p>
      <p> 12020 /* Perform the syncO system call.    Flush all the tables. */ 12021</p>
      <p> 12022 register struct inode *rip;</p>
      <p> 12023 register struct buf *bp;</p>
      <p> 12024 register struct super_block #sp;</p>
      <p> 12025 extern real_time clock_time();</p>
      <p> 12026 extern struct super_block *get_super(); 12027</p>
      <p> 12028 /* The order in which the various tables are flushed is critical. The</p>
      <p> 12029 * blocks must be flushed last, since rw_inode() and rw_super() leave their</p>
      <p> 12030 * results in the block cache.</p>
      <p> 12031 »/ 12032</p>
      <p> 12033 /# Update the time in the root super_block. */</p>
      <p> 12034 sp = get_super(R00T_0EV);</p>
      <p> 12035 sp-&gt;s_time = clock_time();</p>
      <p> 12036 sp-&gt;s_dirt = DIRTY; 12037</p>
      <p> 12038 /* Write all the dirty inodes to the disk. */</p>
      <p> 12039 for (rip = 4inode[0]; rip &lt; &amp;inode[NR_IN0DES]; rip++)</p>
      <p> 12040 if (rip-&gt;i_count &gt; 0 &amp;&amp; rip-&gt;i_dirt == DIRTY) rw_inode(rip, WRITING); 12041</p>
      <p> 12042 /* Write all the dirty super_blocks to the disk. */</p>
      <p> 12043 for (sp = 4super_block[0]; sp &lt; &amp;super_block[NR_SUPERS]; sp++)</p>
      <p> 12044 if (sp-&gt;s_dev != N0J3EV 44 sp-&gt;s_dirt == DIRTY) rw_super(sp, WRITING); 12045</p>
      <p> 12046 /* Write all the dirty blocks to the disk. */</p>
      <p> 12047 for (bp = 4buf[0]; bp &lt; 4buf[NR_BUFS]; bp++)</p>
      <p> 12048 if (bp-&gt;b_dev != N0_DEV 44 bp-&gt;b_dirt == DIRTY) rw_block(bp, WRITING); 12049</p>
      <p> MINIX SOURCE CODE                File: fs/misc.c 675</p>
      <p> 12050 return(OK); /* syncO can't fail */</p>
      <p> 12051 }</p>
      <p> 12054 /*=============================================== = = ==========================</p>
      <p> 12055 * do_fork</p>
      <p> 12056 *=========================================-- -==== -== = .__ == ___. == _______ = _</p>
      <p> 12057 PUBLIC int do_fork()</p>
      <p> 12058 {</p>
      <p> 12059 /* Perform those aspects of the forkO system call that relate to files.</p>
      <p> 12060 * In particular, let the child inherit its parent's file descriptors.</p>
      <p> 12061 * The parent and child parameters tell who forked off whom. The file</p>
      <p> 12062 * system uses the same slot numbers as the kernel.    Only MM makes this call</p>
      <p> 12063 */ 12064</p>
      <p> 12065 register struct fproc *cp;</p>
      <p> 12066 register char *sptr, *dptr;</p>
      <p> 12067 int i; 12068</p>
      <p> ^.2069 /# Only MM may make this call directly. */</p>
      <p> :.2070 if (who != MM_PR0C_NR) return(ERROR) ; 12071</p>
      <p> 12072 /* Copy the parent's fproc struct to the child. */</p>
      <p> 12073 sptr = (char *) &amp;fproc[parent]; /* pointer to parent's 'fproc' struct</p>
      <p> 12074 dptr = (char *) &amp;fproc[child]; /* pointer to child's 'fproc' struct</p>
      <p> 12075 i = sizeof(struct fproc); /* how many bytes to copy */</p>
      <p> 12076 while (i—) *dptr++ = *sptr++; /* fproc[child] = fproc[parent] */ 12077</p>
      <p> 12078 /* Increase the counters in the 'filp' table. */</p>
      <p> 12079 cp = &amp;fproc[child];</p>
      <p> 12080 for (i = 0; i &lt; NR_f r DS; i++)</p>
      <p> 12081  if (cp-&gt;fp_filp[i]   != NIL_FILP) cp-&gt;fp_filp[i]-&gt;filp_count++; 12082</p>
      <p> 12083 /* Record the fact that both root and working dir have another user. */</p>
      <p> 12084 dup_inode(cp-&gt;fp_rootdir);</p>
      <p> 12085 dup_inode(cp-&gt;fp_workdir);</p>
      <p> 12086 return(OK);</p>
      <p> 12087 }</p>
      <p> 12090 /*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = =  =  = = = = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   ::   =   =   =   =  -</p>
      <p> 12091 * do_exit</p>
      <p> 12092 *= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  =  = = = =  =   : :  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =  .</p>
      <p> 12093 PUBLIC int do_exit()</p>
      <p> 12094 {</p>
      <p> 12095 /* Perform the file system portion of the exit(status) system call. */ 12096</p>
      <p> 12097 register int i; 12098</p>
      <p> 12099 /* Only MM may do the EXIT call directly. */</p>
      <p> 676 File: fs/misc.c MINIX SOURCE CODE</p>
      <p> 12100 if (who != MM_PR0C_NR) return(ERROR); 12101</p>
      <p> 12102 /* Nevertheless, pretend that the call came from the user. */</p>
      <p> 12103 fp = &amp;fproc[slotl]; /* get_filp() needs 'fp' */ 12104</p>
      <p> 12105 /# Loop on file descriptors, closing any that are open. +/</p>
      <p> 12106 for (i=0; i &lt; NR_FDS; i++) {</p>
      <p> 12107 fd = i;</p>
      <p> 12108 do_close()j</p>
      <p> 12109 } 12110</p>
      <p> 12111 /# Release root and working directories. #/</p>
      <p> 12112 put_inode(fp-&gt;fp_rootdir);</p>
      <p> 12113 put_inode(fp-&gt;fp_workdir); 12114</p>
      <p> 12115 if (fp-&gt;fp_suspended == SUSPENDED &amp;&amp; fp-&gt;fp_task == XPIPE) susp_count--;</p>
      <p> 12116 fp-&gt;fp_suspended = N0T_SUSPENDED;</p>
      <p> 12117 return(OK);</p>
      <p> 12118 }</p>
      <p> 12121 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = ^ = = = = = = = = = r = = = =: = = = = = = = = = = *</p>
      <p> 12122 # do_set *</p>
      <p> 12123 *===========================================================================*/</p>
      <p> 12124 PUBLIC int do_set()</p>
      <p> 12125 {</p>
      <p> 12126 /# Set uid or gid field. */ 12127</p>
      <p> 12128 register struct fproc *tfp;</p>
      <p> 12129</p>
      <p> 12130 /* Only MM may make this call directly. */</p>
      <p> 12131 if (who != MM_PR0C_NR) return(ERROR); 12132</p>
      <p> 12133 tfp = 4fproc[slotl];</p>
      <p> 12134 if (fs_call == SETUID) {</p>
      <p> 12135 tfp-&gt;fp_realuid = (uid) real_user_id;</p>
      <p> 12136 tfp-&gt;fp_effuid =   (uid) eff_user_id;</p>
      <p> 12137 }</p>
      <p> 12138 if (fs_call == SETGID) {</p>
      <p> 12139 tfp-&gt;fp_effgid =   (gid) eff_grp_id;</p>
      <p> 12140 tfp-&gt;fp_realgid = (gid) real_grp_id;</p>
      <p> 12141 }</p>
      <p> 12142 return(OK);</p>
      <p> 12143 }</p>
      <p> 12146 /♦:: = : = :==:: = = :== = == : ::=== = = : = = :: = : = = = r = == = ": = = "==:"r""""" = " =  ;  = = =="*</p>
      <p> 12147 * do_revive * 12149      PUBLIC int do_revive()</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/misc.c</p>
      <p> 677</p>
      <p> 12150 {</p>
      <p> 12151 /* A task, typically TTY, has now gotten the characters that were needed for a</p>
      <p> 12152 * previous read.   The process did not get a reply when it made the call.</p>
      <p> 12153 * Instead it was suspended.    Now we can send the reply to wake it up. This</p>
      <p> 12154 * business has to be done carefully, since the incoming message is from</p>
      <p> 12155 * a task (to which no reply can be sent), and the reply must go to a process</p>
      <p> 12156 * that blocked earlier.   The reply to the caller is inhibited by setting the</p>
      <p> 12157 * 'dont_reply' flag, and the reply to the blocked process is done explicitly</p>
      <p> 12158 * in reviveO.</p>
      <p> 12159 #/ 12160</p>
      <p> 12161 if (who &gt; 0) return(EPERM);</p>
      <p> 12162 revive(m.REP_PROC_NR, m.REP_STATUS);</p>
      <p> 12163 dont_reply = TRUE; /* don't reply to the TTY task */</p>
      <p> 12164 return(OK);</p>
      <p> 12165 }</p>
      <p> 678 File: fs/device.c MINIX SOURCE CODE</p>
      <p> 12200 /* When a needed block is not in the cache, it must be fetched from the disk.</p>
      <p> 12201 * Special character files also require I/O.   The routines for these are here.</p>
      <p> 12202 *</p>
      <p> 12203 * The entry points in this file are:</p>
      <p> 12204 *    dev_open:     called when a special file is opened</p>
      <p> 12205 *     dev_close:   called when a special file is closed</p>
      <p> 12206 #    dev_io:        perform a read or write on a block or character device</p>
      <p> 12207 *    do_ioctl:     perform the I0CTL system call</p>
      <p> 12208 *     rw_dev:        procedure that actually calls the kernel tasks</p>
      <p> 12209 *     rw_dev2:       procedure that actually calls task for /dev/tty</p>
      <p> 12210 *    no_call:      dummy procedure (e.g., used when device need not be opened)</p>
      <p> 12211 */ 12212</p>
      <p> 12213 ^include "../h/const.h"</p>
      <p> 12214 ^include "../h/type.h"</p>
      <p> 12215 ^include "../h/com.h"</p>
      <p> 12216 ^include "../h/error.h"</p>
      <p> 12217 ^include "const.h"</p>
      <p> 12218 ^include "type.h"</p>
      <p> 12219 ^include "dev.h"</p>
      <p> 12220 ^include "file.h"</p>
      <p> 12221 ^include "fproc.h"</p>
      <p> 12222 ^include "glo.h"</p>
      <p> 12223 ^include "inode.h"</p>
      <p> 12224 ^include "param.h" 12225</p>
      <p> 12226 PRIVATE message dev_mess;</p>
      <p> 12227 PRIVATE major, minor, task;</p>
      <p> 12228 extern max_major; 12229</p>
      <p> 12230 /*= : : ::: == = = = = = = :"= = : :  = =  : : ::: : :: : ::::::::: : :::::::::::::=::;::::::::::::::::f</p>
      <p> 12231 * dev_open ♦</p>
      <p> 12232 *==== === = = === = = = = r = = = = = === ==== === = = = = === = = = ===== === = = =  =  === = = = = == =  =  ===   =   === -  == */</p>
      <p> 12233 PUBLIC int dev_open(de», mod)</p>
      <p> 12234 dev_nr dev; /* which device to open ♦/</p>
      <p> 12235 int mod; /* how to open it */</p>
      <p> 12236 {</p>
      <p> 12237 /* Special files may need special processing upon open. */ 12238</p>
      <p> 12239 find_dev(dev);</p>
      <p> 12240 (*dmap[major],dmap_open)(task, &amp;dev_mess);</p>
      <p> 12241 return(dev_mess.REP_STATUS);</p>
      <p> 12242 }</p>
      <p> 12245 /»= = = = = = = = === = = = = = = = ==== === === ===== === ====:== === = = = = =  =   =   =   =   =   =   =   =   =   =   =   ===r   ===   =   =   =   =   =   =   =  *</p>
      <p> 12246 * dev_close *</p>
      <p> 12248 PUBLIC dev_close(dev)  * /</p>
      <p> 12249 dev_nr dev; /♦ which device to close */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/device.c</p>
      <p> 679</p>
      <p> 12250 {</p>
      <p> 12251 /* This procedure can be used when a special file needs to be closed. */ 12252</p>
      <p> 12253 find_dev(dev)j</p>
      <p> 12254 (*dmap[major].dmap_close)(task, &amp;dev_mess);</p>
      <p> 12255 }</p>
      <p> 12259 * dev_io</p>
      <p> 12261 PUBLIC int dev_io(rw_flag, dev, pos, bytes, proc, buff)</p>
      <p> 12262 int rw_flag; /* READING or WRITING */</p>
      <p> 12263 dev_nr dev; /♦ major-minor device number */</p>
      <p> 12264 long pos; /* byte position */</p>
      <p> 12265 int bytes; /* how many bytes to transfer */</p>
      <p> 12266 int proc; /# in whose address space is buff? */</p>
      <p> 12267 char *buff; /* virtual address of the buffer */</p>
      <p> 12268 {</p>
      <p> 12269 /* Read or write from a device.   The parameter 'dev' tells which one. */ 12270</p>
      <p> 12271 find_dev(dev); 12272</p>
      <p> 12273 /* Set up the message passed to task. */</p>
      <p> 12274 dev_mess.m_type     = (rw_flag == READING ? DISK_READ : DISK_WRITE);</p>
      <p> 12275 dev_mess.DEVICE     = (dev » MINOR) 4 BYTE;</p>
      <p> 12276 dev_mess.POSITION = pos;</p>
      <p> 12277 dev_mess.PROC_NR   = proc;</p>
      <p> 12278 dev_mess.ADDRESS   = buff;</p>
      <p> 12279 dev_mess.COUNT      = bytes; 12280</p>
      <p> 12281 /* Call the task. */</p>
      <p> 12282 (*dmap[major].dmap_rw)(task, &amp;dev_mess); 12283</p>
      <p> 12284 /# Task has completed.    See if call completed. */</p>
      <p> 12285 if (dev_mess.REP_STATUS == SUSPEND) suspend(task); /* suspend user */ 12286</p>
      <p> 12287 return(dev_mess.REP_STATUS);</p>
      <p> 12288 }</p>
      <p> 12291 /*= = = = = === === = === = === = === = = === = === = = = =  =  = = = = = = =  ===   =   =   =   ::   =   =   =   =  -  =   =   =   =   =   =   =   =   =   =   =   =   =   =</p>
      <p> 12292 ♦ do_ioctl</p>
      <p> 12293 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = === = = = = = = = = = = = =  =   =   =   =   ===   ===   ====i=::=   =   =   =   =</p>
      <p> 12294 PUBLIC do_ioctl()</p>
      <p> 12295 {</p>
      <p> 122 g 6 /* Perform the ioctl(ls_fd, request, argx) system call (uses m2 fmt). */ L21 • '</p>
      <p> 12298 struct filp *f;</p>
      <p> 12299 register struct inode *rip;</p>
      <p> 680 File: fs/device.c MINIX SOURCE CODE</p>
      <p> 12300 extern struct filp *get_filp(); 12301</p>
      <p> 12302 if ( (f = get_filp(ls_fd)) == NIL_FILP) return(err_code);</p>
      <p> 12303 rip = f-&gt;filp_ino; /* get inode pointer */</p>
      <p> 12304 if ( (rip-&gt;i_mode 4 I_TYPE) != I_CHAR_SPECIAL) return(EN0TTY);</p>
      <p> 12305 find_dev(rip-&gt;i_zone[0]); 12306</p>
      <p> 12307 dev_mess.m_type   = TTY_I0CTL;</p>
      <p> 12308 dev_mess.PR0C_NR = who;</p>
      <p> 12309 dev_mess.TTY_LINE = minor;</p>
      <p> 12310 dev_mess.TTY_REQUEST = m.TTY_REQUEST;</p>
      <p> 12311 dev_mess.TTY_SPEK = m.TTY_SPEK;</p>
      <p> 12312 dev_mess.TTY_FLAGS = m.TTY_FLAGS; 12313</p>
      <p> 12314 /* Call the task. */</p>
      <p> 12315 (*dmap[major].dmap_rw)(task, &amp;dev_mess); 12316</p>
      <p> 12317 /* Task has completed.   See if call completed. */</p>
      <p> 12318 if (dev_mess.m_type == SUSPEND) suspend(task);   /* User must be suspended. */</p>
      <p> 12319 ml.TTY_SPEK = devjness.TTY_SPEK; /* erase and kill */</p>
      <p> 12320 ml.TTY_FLAGS = dev_mess.TTY_FLAGS;       /# flags */</p>
      <p> 12321 return(dev_mess.REP_STATUS);</p>
      <p> 12322 }</p>
      <p> 12325 /»=::::=:= = ::::: = = ==: = = :: = ::::: = = = : ======= = ::===== = = = = = ==;::: = = = = = = = = == = = = = = = )(</p>
      <p> 12326  *  find_dev  *</p>
      <p> 12327 * = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = = = = = = = = = = = = =  =  = = = r = = = = = = = = = = = =  =  = = = = = = = */</p>
      <p> 12328 PRIVATE find_dev(dev)</p>
      <p> 12329 dev_nr dev; /* device */</p>
      <p> 12330 {</p>
      <p> 12331 /* Extract the major and minor device number from the parameter. */ 12332</p>
      <p> 12333 major = (dev &gt;&gt; MAJOR) &amp; BYTE; /♦ major device number #/</p>
      <p> 12334 minor = (dev » MINOR) &amp; BYTE; /* minor device number */</p>
      <p> 12335 if (major == 0 || major &gt;= max_major) panic("bad major dev", major);</p>
      <p> 12336 task = dmap[major].dmap_task; /* which task services the device */</p>
      <p> 12337 dev_mess.DEVICE = minor;</p>
      <p> 12338 }</p>
      <p> 12341 / t ==:=:===== : ========== ; ======:=== ;: ======== ; =======:== :::: == ; ====== ::: : : == ; =t</p>
      <p> 12342 # rw_dev *</p>
      <p> 12343 # = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  : : = = = = = r: = = =: = = = =: = = = = = = = = = = = = = = = = = = = = =: = = */</p>
      <p> 12344 PUBLIC rw_dev(task_nr, mess_ptr)</p>
      <p> 12345 int task_nr; /* which task to call */</p>
      <p> 12346 message *mess_ptr; /* pointer to message for task ♦/</p>
      <p> 12347 {</p>
      <p> 12348 /» All file system 1/0 ultimately comes down to I/O on major/minor device</p>
      <p> 12349 ♦ pairs.    These lead to calls on the following routines via the dmap table.</p>
      <p> (</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: fs/device.c</p>
      <p> 681</p>
      <p> 12350 12351 12352 12353 12354 12355 12356 12357 12358 12359 12360 12361 12362 12363 12364</p>
      <p> */</p>
      <p> int proc_nr;</p>
      <p> proc_nr = mess_ptr-&gt;PROC_NR;</p>
      <p> if (sendrec(task_nr, mess_ptr) != OK) panic("rw_dev: can't send", N0_NUM); while (mess_ptr-&gt;REP_PROC_NR != proc_nr) {</p>
      <p> /* Instead of the reply to this request, we got a message for an</p>
      <p> * earlier request.    Handle it and go receive again.</p>
      <p> */</p>
      <p> revive(mess_ptr-&gt;REP_PROC_NR, mess_ptr-&gt;REP_STATUS); receive(task_nr, mess_ptr);</p>
      <p> 12367 12368 12369 12370 12371 12372 12373 12374 12375 12376 12377 12378 12379 12380 12381 12382 12383 12384 12385</p>
      <p> /* = =</p>
      <p> rw_dev2</p>
      <p> not used - for compatibility with rw_dev() */ pointer to message for task */</p>
      <p> PUBLIC rw_dev2(dummy, mess_ptr) int dummy; /* message *mess_ptr; /* {</p>
      <p> /* This routine is only called for one device, namely /dev/tty.    Its job</p>
      <p> * is to change the message to use the controlling terminal, instead of the</p>
      <p> * major/minor pair for /dev/tty itself. */</p>
      <p> int task_nr, major_device;</p>
      <p> major_device = (fp-&gt;fs_tty &gt;&gt; MAJOR) &amp; BYTE;</p>
      <p> task_nr = dmaptmajor_device].dmap_task; /* task for controlling tty */</p>
      <p> mess_ptr-&gt;DEVICE = (fp-&gt;fs_tty » MINOR) &amp; BYTE; rw_dev(task_nr, mess_ptr);</p>
      <p> 12388 12389 12390 12391 12392 12393 12394 12395 12396 12397 12398</p>
      <p> no_call</p>
      <p> PUBLIC int no_call(task_nr, m_ptr)</p>
      <p> int task_nr; /* which task */</p>
      <p> message *m_ptr; /* message pointer */</p>
      <p> /# Null operation always succeeds. */</p>
      <p> m_ptr-&gt;REP_STATUS = OK;</p>
      <p> ========»/</p>
      <p> 682 File: fs/utility.c MINIX SOURCE CODE</p>
      <p> 12424</p>
      <p> 12425 PRIVATE int panicking; /* inhibits recursive panics during sync */</p>
      <p> 12426 PRIVATE message clock_mess;</p>
      <p> 12427</p>
      <p> 12428 /* = = = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = =  =   =   =   =   =   =  r =   =   =   =   =  *</p>
      <p> 12429 * clock_time #</p>
      <p> 12430 »= : :::::: ::: : :: : : : : : : ::: ::::: : :: ::= : = ::: : : ::: : = :: ; ::: ::::: ::=::::::: : : : :: :: : ,/</p>
      <p> 12431 PUBLIC real_time clock_time()</p>
      <p> 12432 {</p>
      <p> 12433 /* This routine returns the time in seconds since 1.1.1970. */ 12434</p>
      <p> 12435 register int k;</p>
      <p> 12436 register struct super_block *sp;</p>
      <p> 12437 extern struct super_block *get_super(); 12438</p>
      <p> 12439 clock_mess.m_type = GET_TIME;</p>
      <p> 12440 if ( (k = sendrec(CL0CK, &amp;clock_mess)) != OK) panic("clock_time err", k); 12441</p>
      <p> 12442 /* Since we now have the time, update the super block.    It is almost free. #/</p>
      <p> 12443 sp = get_super(R00T_DEV);</p>
      <p> 12444 sp-&gt;s_time = clock_mess.NEW_TIME; /* update super block time */</p>
      <p> 12445 sp-&gt;s_dirt = DIRTY; 12446</p>
      <p> 12447 return (real_time) clock_mess.NEW_TIME;</p>
      <p> 12448 }</p>
      <p> MINIX SOURCE CODE File: fs/utility.c 683</p>
      <p> 12451 = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  = = = =   = = =     = = = = = = - = = = = = = = = = = = = = ;</p>
      <p> 12452 * cmp_string</p>
      <p> 12453 *= = = = « = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 12454 PUBLIC int cmp_string(rspl, rsp2, n)</p>
      <p> 12455 register char *rspl, *rsp2; /* pointers to the two strings */</p>
      <p> 12456 register int n; /* string length */</p>
      <p> 12457 {</p>
      <p> 12458 /* Compare two strings of length 'n'.    If they are the same, return 1.</p>
      <p> 12459 * If they differ, return 0.</p>
      <p> 12460 */ 12461</p>
      <p> 12462 do {</p>
      <p> 12463 if (*rspl++ != »rsp2++) return(O);</p>
      <p> 12464 } while (— n); 12465</p>
      <p> 12466 /* The strings are identical. */</p>
      <p> 12467 return(l);</p>
      <p> 12468 }</p>
      <p> 12472 /#r = = =  =  = =  =   =  = r: = = = = = = r = = = = z = = = = =  : : = r = = = = = r =  =   =  = z = = r: = = r = = = = - = = =  =  = = = = =  =  - = -r = = =: = : = #</p>
      <p> 12473 * copy *</p>
      <p> 12474 »:::::::== = :::-::::"::::::;:::::::::::::::;::;::::::::::::"::--;;:-;;;«/</p>
      <p> 12475 PUBLIC copy(dest, source, bytes)</p>
      <p> 12476 char *dest; /# destination pointer #/</p>
      <p> 12477 char *source; /# source pointer */</p>
      <p> 12478 int bytes; /# how much data to move */</p>
      <p> 12479 {</p>
      <p> 12480 /♦ Copy a byte string of length 'bytes' from 'source' to 'dest'.</p>
      <p> 12481 * If all three parameters are exactly divisible by the integer size, copy them</p>
      <p> 12482 * an integer at a time.   Otherwise copy character-by-character.</p>
      <p> 12483 */ 12484</p>
      <p> 12485 if (bytes &lt;= 0) return; /* makes test-at-the-end possible */</p>
      <p> 12486</p>
      <p> 12487 if (bytes  %  sizeof(int) — 0 &amp;&amp; (int) dest  %  sizeof(int) == 0 &amp;&amp;</p>
      <p> 12488 (int) source  %  sizeof(int) == 0) {</p>
      <p> 12489 /♦ Copy the string an integer at a time. */</p>
      <p> 12490 register int n = bytes/sizeof(int);</p>
      <p> 12491 register int *dpi = (int *) dest;</p>
      <p> 12492 register int *spi  -  (int *) source; 12493</p>
      <p> 12494 do { *dpi++ = *spi++; } while (—n); 12495</p>
      <p> 12496 } else { 12497</p>
      <p> 12498 /* Copy the string character-by-character. */</p>
      <p> 12499 register int n = bytes;</p>
      <p> File: fs/utility.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 12500 register char *dpc = (char *) dest;</p>
      <p> 12501 register char *spc = (char *) source 12502</p>
      <p> 12503 do { *dpc++ = *spc++; } while (—n);</p>
      <p> 12504</p>
      <p> 12505 }</p>
      <p> 12506 }</p>
      <p> 12509 /»::====:=: = :::::::=: = ::==== = = ==":::::""="::::::: = - = = :::::== = =::::::=:::»</p>
      <p> 12510 * fetch_name *</p>
      <p> 12511 *==========================================:=================================♦/</p>
      <p> 12512 PUBLIC int fetch_name(path, len, flag)</p>
      <p> 12513 char *path; /♦ pointer to the path in user space #/</p>
      <p> 12514 int len; /* path length, including 0 byte */</p>
      <p> 12515 int flag; /* M3 means path may be in message */</p>
      <p> 12516 {</p>
      <p> 12517 /# Go get path and put it in 'user_path'.</p>
      <p> 12518 * If 'flag' = M3 and 'len' &lt;= M3_STRING, the path is present in 'message'.</p>
      <p> 12519 * If it is not, go copy it from user space.</p>
      <p> 12520 */ 12521</p>
      <p> 12522 register char *rpu, *rpm;</p>
      <p> 12523 vir_bytes vpath; 12524</p>
      <p> 12525 if (flag == M3 &amp;&amp; len &lt;= M3_STRING) {</p>
      <p> 12526 /* Oust copy the path from the message to 'user_path'. */</p>
      <p> 12527 rpu = &amp;user_path[0];</p>
      <p> 12528 rpm = pathname; /* contained in input message */</p>
      <p> 12529 do { *rpu++ = *rpm++; } while (—len);</p>
      <p> 12530 return(OK);</p>
      <p> 12531 } 12532</p>
      <p> 12533 /* String is not contained in the message.   Go get it from user space. */</p>
      <p> 12534 if (len &gt; MAX_PATH) {</p>
      <p> 12535 err_code = E_L0NG_STRING;</p>
      <p> 12536 return(ERROR);</p>
      <p> 12537 }</p>
      <p> 12538 vpath = (vir_bytes) path;</p>
      <p> 12539 err_code = rw_user(D, who, vpath, (vir_bytes) len, user_path, FR0M_USER);</p>
      <p> 12540 return(err_code);</p>
      <p> 12541 }</p>
      <p> 12544 /*===========================================================================♦</p>
      <p> 12545 * no_sys *</p>
      <p> 12546 *===========================================:================================*/</p>
      <p> 12547 PUBLIC int no_sys()</p>
      <p> 12548 {</p>
      <p> 12549      /* Somebody has used an illegal system call number */</p>
      <p> MINIX SOURCE CODE                 File: fs/utility.c 685</p>
      <p> 12550</p>
      <p> 12551 return(EINVAL);</p>
      <p> 12552 }</p>
      <p> 12555 /*===========================================================================</p>
      <p> 12556 * panic</p>
      <p> 12557 *= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = z = = = = = = = = = z = = :  = =: = = = = = = = = = = : = r = = = = = = = r = = = =</p>
      <p> 12558 PUBLIC panic(format, num)</p>
      <p> 12559 char *format; /* format string +/</p>
      <p> 12560 int num; /* number to go with format string */</p>
      <p> 12561 {</p>
      <p> 12562 /# Something awful has happened.   Panics are caused when an internal</p>
      <p> 12563 # inconsistency is detected, e.g., a programming error or illegal value of a</p>
      <p> 12564 # defined constant.</p>
      <p> 12565 */ 12566</p>
      <p> 12567 if (panicking) return; /* do not panic during a sync */</p>
      <p> 12568 panicking = TRUE; /* prevent another panic during the sync */</p>
      <p> 12569 printfC'File system panic:  %s ",  format);</p>
      <p> 12570 if (num != N0_NUM) printf OW.num);</p>
      <p> 12571 printf("\n");</p>
      <p> 12572 do_sync(); /# flush everything to the disk */</p>
      <p> 12573 sys_abort();</p>
      <p> 12574 }</p>
      <p> 686 File: fs/putc.c MINIX SOURCE CODE</p>
      <p> 12600 /# F5 must occasionally print some message.    It uses the standard library</p>
      <p> 12601 * routine printfO, which calls putc() and flushO. Library</p>
      <p> 12602 * versions of these routines do printing by sending messages to FS. Here</p>
      <p> 12603 + we obviously can't do that, so FS calls the TTY task directly.</p>
      <p> 12604 */ 12605</p>
      <p> 12606 ^include "../h/const.h"</p>
      <p> 12607 ^include "../h/type.h"</p>
      <p> 12608 ^include "../h/com.h" 12609</p>
      <p> 12610 //define STD0UTPUT 1      /* file descriptor for standard output */</p>
      <p> 12611 ^define BUFSIZE 100      /* print buffer size */ 12612</p>
      <p> 12613 PRIVATE int bufcount; /* # characters in the buffer */</p>
      <p> 12614 PRIVATE char printbuf [BUFSIZE]; /* output is buffered here */</p>
      <p> 12615 PRIVATE message putchmsgj            /+ used for message to TTY task */ 12616</p>
      <p> 12618 * putc *</p>
      <p> 12619 *= = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = = = ; = = = = = = = = = = :: = = = = = = = = = = = = = = = = = = = = = = »/</p>
      <p> 12620 PUBLIC putc(c)</p>
      <p> 12621 char c;</p>
      <p> 12622 { 12623</p>
      <p> 12624 if (c == 0) {</p>
      <p> 12625 flushO;</p>
      <p> 12626 return;</p>
      <p> 12627 }</p>
      <p> 12628 printbuf[bufcount++] = c;</p>
      <p> 12629 if (bufcount == BUFSIZE) flushO;</p>
      <p> 12630 if (c == '\n') flushO;</p>
      <p> 12631 }</p>
      <p> 12635 * flush *</p>
      <p> 12636 *=== = === = = === === === = ==== ======== = = = = === === === === = === === === === = = = === = = = = = = = ==♦/</p>
      <p> 12637 PRIVATE flushO</p>
      <p> 12638 {</p>
      <p> 12639 /* Flush the print buffer. */ 12640</p>
      <p> 12641 if (bufcount == 0) return;</p>
      <p> 12642 putchmsg.m_type = TTY_WRITE;</p>
      <p> 12643 putchmsg.PR0C_NR   = 1;</p>
      <p> 12644 putchmsg.TTY_LINE = 0;</p>
      <p> 12645 putchmsg.ADDRESS   = printbuf;</p>
      <p> 12646 putchmsg.COUNT = bufcount;</p>
      <p> 12647 sendrec(TTY, &amp;putchmsg);</p>
      <p> 12648 bufcount = O;</p>
      <p> 12649 }</p>
      <p> MINIX CROSS</p>
      <p> REFERENCE</p>
      <p> LISTING</p>
      <p> This appendix lists the principal procedure names, global variables, defined constants, and other macros present in the listing of Appendix E. Local variables and structure members are not listed, as this would have increased the length of this appendix substantially. The boldface entries show the lines on which the symbols are defined.</p>
      <p> ABS 0049 4941 4946 5716 6171</p>
      <p> ACCESS 0130</p>
      <p> ADDRESS 0211 2362 2597 3542 3550 3800 3918 4166 7391 12278 12645</p>
      <p> ALARM 0126</p>
      <p> ALARM_ON 5284 5799 6616 6617 6709 6711</p>
      <p> ALL_MODES 0072 9495 9549 11704</p>
      <p> ANY 0154 1946 2002 2053 2078 2311 2551 3121 3509 4634 5001</p>
      <p> 5475 9042</p>
      <p> AT_SIGN 3373 3724</p>
      <p> BAD_CYL 2462 2822</p>
      <p> BAD-SECTOR 2461 2822</p>
      <p> BASE 0874 0903 0973</p>
      <p> BEEP-FREQ 4068 4244</p>
      <p> BIT_MAP_SHIFT 8626 8704 8705 8725 8756 8757</p>
      <p> BLANK 4070 1697 1699 1744 4485</p>
      <p> BLOCK_SIZE 0018 2387 2590 2599 2644 7540 7542 7543 7544 7546 7566 8310 8311 9097 9098 9138 9190 9216 9220 9862 9863 9864</p>
      <p> 687</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> APPENDIX F</p>
      <p> 9904 9941 9962 9968 9974 10000 10156 10244 10246 10305 10306</p>
      <p> 10895 11405 BOOT_BLOCK 7532 BOOT_DEV 0062 9184 9214</p>
      <p> BOTH 0153 1179 1950</p>
      <p> BRK 0117 BRK2 0147 9196</p>
      <p> BSSB 5928 6076</p>
      <p> BUFSIZE 12611 12614 12629</p>
      <p> BUF_SIZE 7360 7363 7375</p>
      <p> BUSY 3439</p>
      <p> BYTE 0044 2673 2674 2675 2676 2677 2685 2857 2970 3279 3280</p>
      <p> 3719 3956 3957 3963 3964 3965 3966 3967 3972 3973 3980 3981 3982 3983 3984 4418 4420 4440 4441 6088 8260 8261 8315 8431 8466 8467 9029 9030 9811 9812 10524 10594 11291 11609 11611 12275 12333 12334 12381 12383</p>
      <p> BYTE-AVAIL 4095</p>
      <p> B-TIME 4069 4444</p>
      <p> CALIBRATED       2523 2936</p>
      <p> CANCEL 0246 3516 10596</p>
      <p> CBREAK 0374 3564 3597 3605 3829</p>
      <p> CHANGE 2464 2971</p>
      <p> CHDIR 0112 5965 5967 6790 6806 6840</p>
      <p> CHILD-STIME      0236 4860</p>
      <p> CHILD-UTIME     0235 4859</p>
      <p> CHMOD 0115</p>
      <p> CHOWN 0116</p>
      <p> CHROOT 0142</p>
      <p> CLEAN 7529 8319 8572 8847</p>
      <p> CLICK-SHIFT 0035 0903 1054 1996 1997 2302 2303 5038 5048 5051 5053 5710 5714 5715 5971 5996 6081 6082 6083 6124 6125 6126 6127 6161 6164 6165 6236 6302 6335 6399 6400 6401 6812 6823 6824 9136 9207</p>
      <p> 0034 5426 5564 5971 6083 6124 6125 6126 6127 6302 9190 5426 5563 5564 5565</p>
      <p> 0170 1220 1222 1896 2733 2996 6714 11929 12440 0203 2993 3156 0172 1219 3128 3134 0671 0967 0107</p>
      <p> 4060 4475</p>
      <p> 4075 4144 4145 4147 4161 0375 3605 3607 0230 4938 7291 10073 4617</p>
      <p> 0777 6480 6805</p>
      <p> 0209 2351 2357 2387 2596 3801 3919 7392 9208 12279 12646 0109</p>
      <p> CLICK_SIZE</p>
      <p> CLICK_TO_K</p>
      <p> CLOCK</p>
      <p> CLOCK_PROC_NR CLOCK-TICK CLOCK-VECTOR CLOSE</p>
      <p> COLOR-BASE</p>
      <p> CONSOLE</p>
      <p> COOKED</p>
      <p> COPY-BYTES</p>
      <p> COPY-UNIT</p>
      <p> CORE-MODE</p>
      <p> COUNT</p>
      <p> CREAT</p>
      <p> APPENDIX F</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> 689</p>
      <p> CRMOD CS_REG</p>
      <p> CTL_ACCEPTING</p>
      <p> CTL-BUSY</p>
      <p> CTRL_S</p>
      <p> CURSOR</p>
      <p> CUR_SIZE</p>
      <p> C6845</p>
      <p> C_RETRACE</p>
      <p> C_VID_MASK</p>
      <p> D</p>
      <p> DATA DATAB</p>
      <p> DATA-CHANGED</p>
      <p> DELETE</p>
      <p> DELTA_TICKS</p>
      <p> DELUXE</p>
      <p> DEL_CODE</p>
      <p> DEVICE</p>
      <p> DIRECTION</p>
      <p> DIRECTOR Y_BLO</p>
      <p> DIRTY</p>
      <p> DIR_ENTRY_SIZE</p>
      <p> DISKINT</p>
      <p> DISK_IOCTL</p>
      <p> DISK-READ</p>
      <p> DISICWRITE</p>
      <p> DIVISOR</p>
      <p> DMA-ADDR</p>
      <p> DMA-COUNT</p>
      <p> DMA-INIT</p>
      <p> DMA-MI</p>
      <p> DMA_M2</p>
      <p> DMA-READ</p>
      <p> DMA_TOP</p>
      <p> DMA-WRITE</p>
      <p> DOR</p>
      <p> DST_BUFFER DST_PROC_NR DST-SPACE DS_REG</p>
      <p> 0372 3655 4264 4462</p>
      <p> 0664 0941 4730</p>
      <p> 2452 2889</p>
      <p> 2451 2860</p>
      <p> 4073 4146</p>
      <p> 4091 4336 4355</p>
      <p> 4089 4487</p>
      <p> 4086 4477</p>
      <p> 4064 4478</p>
      <p> 4062 4476</p>
      <p> 0028 0924 0925 0934 0935 0937 0942 0943 0944 0960 1005 1994 1998 2004 2005 2055 2056 2362 2672 3467 3489 3834 3835 3927 4722 4724 4731 4732 4733 4907 5042 5045 5580 5581 5608 5609 5610 5705 5708 5733 5734 5735 5963 5981 5999 6004 6151 6152 6153 6154 6156 6171 6329 6361 6362 6431 6662 6829 9817 10057 10068 11624 12539 4088 4418 4420 5927 6068 6277 6348 6369 7527 10910 11371 0200 2994 3157 6707 4097</p>
      <p> 3372 4154</p>
      <p> 0207 2349 2384 2585 9205 12275 12337 12383</p>
      <p> 2450 2855 2888</p>
      <p> 7604 10916 10929 10950</p>
      <p> 7530 8139 8224 8439 8516 8568 8732 8764 8844 9217 9599</p>
      <p> 9892 9973 10153 10199 10213 10330 10912 10949 10952 11329 11375</p>
      <p> 11705 11735 11894 12036 12040 12044 12048 12445</p>
      <p> 7539 7542 10892 10954</p>
      <p> 0185 1205 0188 2321 9204</p>
      <p> 0186 2319 2351 2366 2559 2669 2804 12274</p>
      <p> 0187 2320 2560 12274 2503 2810</p>
      <p> 2431 2692 2693</p>
      <p> 2433 2695 2696 2436 2698 2435 2691</p>
      <p> 2434 2690</p>
      <p> 2475 2669</p>
      <p> 2432 2694</p>
      <p> 2476 2669</p>
      <p> 2428 2725 2748 2959 2960 0229 4937 4947 7289 10062 10070 0228 4933 7288 10061 10069 0227 4935 7287 10060 10068 0663 0942 4731</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> APPENDIX F</p>
      <p> DTL</p>
      <p> DUMPED</p>
      <p> DUMP_SIZE</p>
      <p> DUP</p>
      <p> DUP_MASK</p>
      <p> E2BIG</p>
      <p> EACCES</p>
      <p> EAGAIN</p>
      <p> EBADF</p>
      <p> EBUSY</p>
      <p> ECHILD</p>
      <p> ECHO</p>
      <p> EDOM</p>
      <p> EEXIST</p>
      <p> EFAULT</p>
      <p> EFBIG</p>
      <p> EINTR</p>
      <p> EINVAL</p>
      <p> EIO</p>
      <p> EISDIR</p>
      <p> EMFILE</p>
      <p> EMLINK</p>
      <p> ENABLE</p>
      <p> ENABLE_INT</p>
      <p> ENFILE</p>
      <p> ENODEV</p>
      <p> ENOENT</p>
      <p> ENOEXEC</p>
      <p> ENOMEM</p>
      <p> ENOSPC</p>
      <p> ENOTBLK</p>
      <p> ENOTDIR</p>
      <p> ENOTTY</p>
      <p> ENOUGH</p>
      <p> ENTER</p>
      <p> ENXIO</p>
      <p> EOT_CHAR</p>
      <p> EPERM</p>
      <p> EPIPE</p>
      <p> ERANGE</p>
      <p> ERASE_CHAR</p>
      <p> EROFS</p>
      <p> ERROR</p>
      <p> ERR_DRIVE</p>
      <p> ERR_RECALIBRA</p>
      <p> ERR^SEEK</p>
      <p> 2483 2813 6481 6808 6479 6780 6828 0133</p>
      <p> 7523 11992 0263</p>
      <p> 0269 5968 5984 7245 7260 11811 11815</p>
      <p> 0267 5701 5702 5711 6135</p>
      <p> 0265 8921 9825 12002</p>
      <p> 0272 11050 11077 11150</p>
      <p> 0266 5842 0373 3752 4462 0289</p>
      <p> 0273 9498 9504 9608 11314</p>
      <p> 0270 4951</p>
      <p> 0283 9847 10187 10940</p>
      <p> 0260 3661 4025 6753 6760 10602</p>
      <p> 0278 2322 2561 2590 2599 3519 3990 5958 6496 6592 7302 9637 9740 9742 9822 9827 11062 11160 12551</p>
      <p> 0261 2586 2644 0277 9512 9655</p>
      <p> 0280 8896</p>
      <p> 0287 11291</p>
      <p> 0680 1888 4134 4148 4170 2454 2641 2722 2960</p>
      <p> 0279 8404 8465 8909 11051 11091 0275</p>
      <p> 0258 6803 9579 10933 11311 0264 5975 6062 6063 6078 6084</p>
      <p> 0268 5957 6129 6336 6342 6375 6404 6406 6409</p>
      <p> 0284 8259</p>
      <p> 0271 11196</p>
      <p> 0276 10886 11081 11104 11532</p>
      <p> 0281 12304 5425</p>
      <p> 7526 9596 10904 10907 10921 10933 11324</p>
      <p> 0262 2350 2354 2385 3370 4470</p>
      <p> 0257 5550 6544 6895 6904 9547 10584 11037 11138 11295 11369 11506 11693 11724 11891 11926 12161</p>
      <p> 0288 10469 0290</p>
      <p> 3364 4464 0286 11841</p>
      <p> 0256 8644 12070 12100 12131 12536 2496</p>
      <p> 2494 2933</p>
      <p> 2491 2768 2775 2781 2782 2784 2921</p>
      <p> APPENDIX F</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> APPENDIX F</p>
      <p> FULL_DATA_BLO 7609 9191 9974 10257 FUNC 0244 4895</p>
      <p> FUNC_TO_CALL 0201 2995 3158 F_Lu_s_h 7383 7375 7376</p>
      <p> GAP 2482 2812</p>
      <p> GETGID 0137 6883</p>
      <p> GETPID 0120 6888</p>
      <p> GETUID 0124 6878</p>
      <p> GET_TIME 0173 3126 12439</p>
      <p> GET_TYPE 4098 GO_BACKWARD  4077 4392 GO-FORW ARD     4076 4266 4310 4312</p>
      <p> HANGING 5282 5497 5796 5828 5881 5892 6548 6607 6632</p>
      <p> HARDWARE        0157 0948 0949 0950 0951 0960 0975 1893 1914 2010 2114</p>
      <p> 2776 2817 2922 2962 5010 5477 6544 HDR_SIZE 5166 6044 6062 6089</p>
      <p> HIGHEST_ZONE 0516</p>
      <p> HZ 0017 1114 2487 2488 3090 3160 3180 3192 3278 6707</p>
      <p> IBM_FREQ 3095 3278</p>
      <p> IDLE 0687 1289 1921 2113</p>
      <p> INACTIVE 3438</p>
      <p> INDEX 4087 4417 4419</p>
      <p> INDIRECT_BLOCK7605 10024 10033 10201 10205 10214 11426 INFO 8975 9175 9179 9180 9181</p>
      <p> INIT_PROC_NR    0040 5141 5523 5577 5676 5742 5887 5891 6602</p>
      <p> INIT_PSW 0655 0916</p>
      <p> INIT_SP 0656 0910 0912</p>
      <p> INODES_PER_BL 7540 7569 8558 8561</p>
      <p> INODE_BLOCK     7603 8571</p>
      <p> INODE_SIZE        7541 7540 8565 8567 9098</p>
      <p> INTR_CHAR 3366 4466</p>
      <p> INTS_PER_BLOCK 7544 7570 8717 10326</p>
      <p> INT_BITS 8625 8706 8722 8724 8758 8759</p>
      <p> INT_CTL 0678 1888 4134 4148 4170</p>
      <p> INT_CTLMASK     0679 0979</p>
      <p> IN_USE 5280 5497 5521 5522 5523 5721 5826 5883 6548 6603 6632</p>
      <p> 6655</p>
      <p> IOCTL 0139 ISEEK 7887 9744</p>
      <p> LBLOCK_SPECIA 0067 9516 9665 9696 9697 9844 9888 9939 11081 11195 I_CHAR_SPECIAL 0069 9515 9659 9696 9836 9888 11081 12304 LDIRECTORY      0068 9249 9511 9652 9905 10886 11103 11104 11295 11368 11531</p>
      <p> I_MAP_BLOCK     7606 8680 9218 9219</p>
      <p> LMAP_SLOTS      7506 7982 8645</p>
      <p> L.MOUNT 7885 10841 11115</p>
      <p> I_NOT_ALLOC      0077 8434</p>
      <p> L.PIPE 7883 9733 10419 11406 11614</p>
      <p> APPENDIX F</p>
      <p> MINIX CROSS REFERENCE LISTING</p>
      <p> 693</p>
      <p> L.REGULAR 0066 7243 9495 9507 9905 9909 10411</p>
      <p> L.SET_GID_BIT 0071 6012</p>
      <p> L.SET_UID_BIT 0070 6008</p>
      <p> L.TYPE 0065 7242 9249 9506 9549 9651 9695 9833 9939 10886 11080</p>
      <p> 11103 11104 11195 11295 11368 11531 12304</p>
      <p> KBIT 4082 4123</p>
      <p> KB.BUSY 4096</p>
      <p> KB_STATUS 4094</p>
      <p> KEYBD 4080 4121</p>
      <p> KEYBOARD.VEC 0672 0968</p>
      <p> KILL 0132</p>
      <p> KILL_CHAR 3365 4465</p>
      <p> KMEM_DEV 0180 2302 2303</p>
      <p> KSIG 0145 5006 10465</p>
      <p> STACK—BYTES 0684 0717 0949 1164 1278</p>
      <p> L AST_FEW 5674 5702</p>
      <p> LINE_WIDTH 4071 4292 4310 4313 4318 4351 4354 4382</p>
      <p> LINK 0110</p>
      <p> LOOK_UP 7525 10812 10887</p>
      <p> LOW_USER 0041 0907 0953 1950 1987 2110 2137 2163 3261 3663 4896</p>
      <p> LSEEK 0119</p>
      <p> Ml 0542 9548 11040 11066 11286 11304 11564 11727 11886</p>
      <p> M3 0543 9491 9638 11141 11353 11527 11686 11769 12525</p>
      <p> M3_STRING 0545 0549 12525</p>
      <p> M4 0544</p>
      <p> M64K 8974 9139</p>
      <p> MAGIC 5924 6063</p>
      <p> MAJOR 0021 8260 8315 8466 12333 12381</p>
      <p> MARKER 3371 3639 3682 3753 3854 3856</p>
      <p> MASTER 2449 2853 2888</p>
      <p> MAX 0501</p>
      <p> MAX_BLOCK_NR 0508</p>
      <p> MAX_ERRORS 2500 2604 2611</p>
      <p> MAX_FDC_RETR 2504 2883</p>
      <p> MAX_FILE_POS 0531</p>
      <p> MAX_INODE_NR 0512</p>
      <p> MAX_ISTACK_BY 00585156 5158 5943 5957 6184 6200</p>
      <p> MAXJLINKS 0527 11291</p>
      <p> MAX_OVERRUN 3362 3445 3446 4486</p>
      <p> MAX_PAGES 5165 6404 6406</p>
    </div>
  </body>
</html>
