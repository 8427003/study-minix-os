<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>part0007</title>
    <meta content="abbyy to epub tool, v0.2" name="generator"/>
    <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
    <meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
    <div class="body">
      <p> Once all the object files have been assembled, the order must be determined based on who calls whom. The command</p>
      <p> ar t /usr/lib/libc.a &gt;listing</p>
      <p> gives the order of the MINIX library, which is a good starting point for other compilers. With UNIX the library,  /usr/lib/libc.a,  is built using the archiver,  ar.</p>
      <p> One last note. Most compilers produce  .o  files as the final compilation step. The MINIX C compiler produces only  .s  (assembly code) files, which are then put in the library. The MINIX assembler-loader expects .5 files rather than  .0  files. When using the MINIX compiler, for example, to recompile library procedures that have been modified, the -LIB and -c flags are required in order to get the proper  .define  pseudoinstructions into the output files.</p>
      <p> D.3. MAKING NEW FILE SYSTEMS</p>
      <p> MINIX uses several file systems: the root file system,  lusr,  and possibly  /user. All of these are constructed the same way. The following sections describe how to make new file systems for MINIX.</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> D.3.1. Concepts</p>
      <p> There are no hard and fast rules about which programs should go on the root file system diskette and which should go elsewhere, except that  login  and  sh  must go in  I bin  because  init  expects them there. In general, programs that are heavily used should be put in the root file system, because the root file system goes on the RAM disk. At least 50K should be left free so temporary files can be created in  Itmp.</p>
      <p> An important issue is how large to make the root file system. The larger it is, the less room there is in memory for user programs. For 640K computers, a 240K RAM disk is reasonable. The only difference between the distributions for 256K and 640K PC's is the size of the root file system and its consequences, such as the impossibility of having all the utilities online with only 256K.</p>
      <p> The general strategy for making new file systems is to first compile and link all the programs that are to go on the new file system. If need be, the executable files will have to be converted to MINIX format. Then the  mkfs  program is run to build a new file system, usually on a diskette, but possibly as a hard disk file.</p>
      <p> MINIX supports two memory models: small model and separate instruction and data space model. In the former, a maximum of 64K is allowed for the entire program. In the latter, a maximum of 64K is allowed for the program text, and an additional 64K is allowed for the data and stack combined. No other models are supported, to encourage programmers to write small, modular programs. The current assembler-loader does not generate separate I and D space programs, but when large programs are set up with separate I and D space by another compiler (e.g., on PC-IX), the operating system can handle them.</p>
      <p> Any C compiler can be used to compile the commands, but it is essential that they be linked only with the MINIX library, as discussed in the previous section. Accidentally linking in a library procedure that makes a foreign system call will almost certainly lead to an unexpected kernel trap.</p>
      <p> When MINIX executes a program, it loads the program into memory and then transfers control to address 0. Address 0 must contain the C run-time start-off procedure,  crtso.  This procedure arranges for  argc, argv,  and  envp  to be pushed onto the stack using the standard C calling sequence so that  main  can access them. Because  crtso  is the first procedure that the linker sees, it must contain directives to define the various segments used. These differ from compiler to compiler so several versions are provided.</p>
      <p> All executable programs must be in MINIX format, as described in Appendix C. If an MS-DOS compiler is used, the resulting  .EXE  file will not be in MINIX format and thus cannot be executed by MINIX. A program,  dos2out  is provided in the  tools  directory to read a  .EXE  file and write a new file in MINIX format.</p>
      <p> This conversion is not entirely trivial. The header format used for  .EXE  files does not include the text size, which MINIX needs. In order to force this information into the  .EXE  header, the  crtso  file used for MS-DOS (C86 compiler) forces the symbol  DGROUP  to be relocatable, thus getting its origin into the</p>
      <p> SEC. D.3</p>
      <p> MAKING NEW FILE SYSTEMS</p>
      <p> 423</p>
      <p> header. Since  DGROUP  is at the start of the data, its value is the size of the text. The utility  dos2out  expects  DGROUP  to be the only relocatable symbol.</p>
      <p> It is normal in the UNIX world for C compilers to gather all the uninitialized variables, structures, and arrays together into the bss part of the data segment, following the initialized data. This scheme results in an executable program file whose size is equal to the sum of the sizes of the header, text, and initialized data. For example, a program with 3K text, IK initialized data, and an uninitialized 50K array will have an executable file of about 4K. The bss area is set to zero by MINIX when the program is executed.</p>
      <p> Unfortunately, some MS-DOS compilers do not distinguish between initialized and uninitialized data. They treat all variables as initialized data. If the above program were compiled with one of these compilers, the executable program would occupy about 54K of space on the disk, rather than 4K. Use of such a compiler will greatly limit the number of programs that can be kept in  I bin  and lusrlbin.  If your compiler has this property, you are advised to replace it with one that does not.</p>
      <p> The general strategy for making a new file system is to first compile all the commands that are to be put on it. These may well be spread over several diskettes. When all the compilations have been completed, and all the files converted to MINIX format, if need be, the resulting executable MINIX files should be gathered together in a single directory, conventionally  commands I bin.  On a system without a hard disk, a new diskette should be formatted and the directory commands!bin  made on it. Then all the executable files should be copied there. A directory  tools  should also be put on the diskette, and loaded with  mkfs  and the prototype file.</p>
      <p> A file system is made by running  mkfs.  If you are working on PC-IX, MS-DOS, or some other system, be sure to run the MINIX version of  mkfs  compiled for that system, not the version compiled for MINIX, and certainly not the  mkfs that came with the development system.  Mkfs  takes a prototype file as described in Appendix C, and builds the new file system. The new file system is normally generated on a diskette, but when using a hard disk, it can also be written onto a file, and copied to a diskette later.</p>
      <p> The above process should be repeated for each file system to be made. Once all the file systems have been constructed, MINIX can be run, and several file systems merged by copying the files. This last step may be required in order to make a file system that is full down to the last block because a diskette containing executable programs and  mkfs  cannot hold a full 360K worth of programs— mkfs  also takes up some space.</p>
      <p> D.3.2. Step-by-Step Instructions</p>
      <p> The first step is to make the library, as described in D.2. Next, the programs to be compiled should be gathered together in the directory  commands.  On a system without a hard disk, the programs will have to be spread over several</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> diskettes in order to leave enough room on each for the  h  and  include  directories, as well as space for the compiler and linker temporary files.</p>
      <p> When using MINIX as the development system, a program can be compiled by typing</p>
      <p> cc -I/usr/lib/include prog.c</p>
      <p> (assuming the include files are located in  Iusrlliblinclude,  where they normally are). The proper run-time start-off routine and libraries are automatically used.</p>
      <p> When using PC-IX or another UNIX system for building the file system, the procedure is slightly different, in order to use the MINIX run-time start-off routine and the MINIX library instead of the native one. Compile, but do not link each program in  commands,  by typing</p>
      <p> cc -c -0 prog.c</p>
      <p> To link  commands!prog.o  from inside the  commands  directory and put the resulting executable file on  bin/prog,  type</p>
      <p> Id -s -o bin/prog .,/lib/crtso.o prog.o ../lib/libc.a ../lib/end.o</p>
      <p> The -s flag strips off the symbol table to make the binary file smaller. Alternatively, the flag can be omitted and  strip  used to get rid of the symbol table. An -i flag may be used to specify separate I and D space.</p>
      <p> On PC-IX,  chmem  can now be used to reduce the dynamic allocation size. For many nonrecursive programs that have no local arrays and do not use the BRK system call, directly or indirectly, IK is adequate for the stack. The command</p>
      <p> chmem =1024 bin/prog</p>
      <p> sets it to IK. Using  chmem  does not affect the amount of disk space occupied by the program, but does change the amount of memory' occupied when the program is executed. Smaller programs mean that more background processes can be running simultaneously. If a program crashes or acts strange, try giving it more stack space with  chmem.</p>
      <p> With MS-DOS, the exact command used to compile the program depends on the compiler being used. After compilation, linking can be typically performed by the command</p>
      <p> link ..\lib\crtso.obj+prog.obj,prog,listing,..\lib\lib.a</p>
      <p> After the  .EXE  file has been built, it must be converted to MINIX form by the command</p>
      <p> dos2out -d prog</p>
      <p> which reads  PROG.EXE  and writes the output on  PROG.OUT.  The flag -d, which is optional, specifies that  PROG.EXE  is to be deleted after  PROG. OUT  has been made.</p>
      <p> SEC. D.3</p>
      <p> MAKING NEW FILE SYSTEMS</p>
      <p> 425</p>
      <p> The subdirectories in  commands  contain the files  makefile  and  make.bat  for use with  make  and MS-DOS, respectively. To compile and link  prog.c  on UNIX or MINIX, the call to make is</p>
      <p> make f=prog</p>
      <p> The macro / used in  makefile  is assumed to contain the name of the program, without the  .c  suffix. Unlike the  make  version, the MS-DOS batch file can handle several compilations on a single call, for example</p>
      <p> make progl prog2 prog3</p>
      <p> When all the programs that will go on the new file system have been compiled and linked, they should be gathered together in a single directory, for example,  commands/bin.  On a system with only floppy disks, this directory will normally be on a fresh diskette, not the ones containing the sources. An executable version of the program  mkfs  should also be present.</p>
      <p> The directory must also contain the prototype file, as described in Appendix C under the listing for  mkfs.  This file tells how big the new file system is to be (e.g., 360 blocks for PC diskettes), and how many i-nodes it is to have. Since 32 i-nodes fit in a IK block, and i-node 0 is not used but occupies space, the number of i-nodes should be one less than a multiple of 32. Typical values are 63, 95, or 127. Examples of prototype files can be found in the distribution as tools/proto.ram  (root file system),  tools/proto.usr (lusr),  and  tools/proto.user (/user).</p>
      <p> The final step in making a file system is straightforward: just type mkfs -L  special proto  &gt;logf ile</p>
      <p> where  special  is a special file, such as  IdevlfdO  and  proto  is the prototype file. The -L flag causes a description of the new file system to be produced on standard output.</p>
      <p> After the file system has been made, but before it is put into production, it is a good idea to run MINIX and use  chmem  to reduce the dynamic allocation area of programs, if this step has not already been taken prior to making the file system.</p>
      <p> Not all compilers produce equally good code. Before replacing all the binary programs that come with MINIX, determine whether your compiler produces smaller or larger code by compiling a few programs. If your compiler produces smaller code, it may be worthwhile to recompile all programs to replace the originals. However, if your compiler produces larger code, only recompile programs that you have modified.</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> D.4. RECOMPILING MINIX</p>
      <p> Recompiling the operating system itself is not technically difficult, but its relatively large size requires some care when using a system having only two 360K floppy disks and no hard disk. Before modifying the system, it is strongly recommended that you try recompiling the system as distributed, to learn how to do it. Using a floppy disk based MINIX system, it takes two to three hours to compile and build the entire operating system from scratch.</p>
      <p> The bootable image is composed of six parts: the kernel, memory manager, file system, initializer, boot block, and file system checker. You need only recompile those parts you have modified. The binaries of the other parts are already present in  tools,  and can be used as is. The instructions below tell how to recompile all the parts. Normally only some of them will have to be recompiled.</p>
      <p> D.4.1. Concepts</p>
      <p> The operating system is contained in three directories:  kernel, mm,  and  fs.  In addition, the directory  h  contains header files used by all three of these. The directory  kernel  contains the lowest two layers of the system, which do interrupt handling, process management, message passing, and I/O. All the files in this directory are linked into a single executable, binary program,  kernel.</p>
      <p> Although nearly all of the kernel is written in C, two assembly language files are also needed. They are  mpx88.s,  which contains the interrupt handlers (i.e., process multiplexing) and  klib88.s,  which holds several small library routines used only in the kernel.</p>
      <p> As mentioned earlier, some compilers truncate long names different from their own assemblers, so if your linker complains about undefined symbols, it may be necessary to edit  mpx88.s  and  klib88.s  to truncate all the long names by hand.</p>
      <p> If you are using an assembler that does not accept any of the assembly language versions provided, pick the closest one and modify it as need be. Most of the pseudoinstructions are present in all assemblers, sometimes with a different name however. The only one that may not be available everywhere is  .ASCIZ, which generates a string terminated by a zero byte. In this case, the zero byte should be made explicit in the argument.</p>
      <p> D.4.2. Step-by-Step Instructions</p>
      <p> By now you should already have moved  mpx88.s  and  klib88.s  from one of the subdirectories to  kernel  and removed the subdirectories. When using a system with only 360K floppy disks, remove all other directories except  kernel  and h  from the diskette, to provide room for the object files and compiler temporary files.</p>
      <p> SEC. D.4</p>
      <p> RECOMPILING MINIX</p>
      <p> 427</p>
      <p> Now compile or assemble each of the files. On a PC with two diskette drives, the standard  lusr  file system should be in drive 0 and the kernel diskette should be in drive 1 (mounted on  I user).  When using MINIX as the development system, the easiest way is just to type</p>
      <p> make</p>
      <p> Alternatively the compilations can be done "by hand" by typing cc -c -Di8088 -w *.c</p>
      <p> The -w flag suppresses some irrelevant warning messages that occur because the source code is a compromise between what various compilers expect. This route is somewhat faster because the presence of  make  itself in memory means that there is not enough space left for both  cpp  and  cem  simultaneously. Consequently, the  makefile  uses the -F and -T. flags to direct the preprocessor output to disk instead of piping it into  cem.</p>
      <p> With MS-DOS, the  make.bat  file can also be used, but it should be checked first to see if it is appropriate for the configuration and compiler being used.</p>
      <p> If the compilations have been done "by hand," link all the object files into a single executable binary program by just typing</p>
      <p> make</p>
      <p> For this step, the library described in Sec. D.2 will be needed, but the source files will not be. The assembler-linker,  asld,  is smaller than  cem,  so there is no shortage of memory here. However, it produces a large temporary file, so the makefile  removes  lliblcem  to make room for it. It can be restored later by mounting the root file system and copying the file from it to  I lib.</p>
      <p> If the development system is MS-DOS, the kernel binary must now be converted to MINIX format by running  dos2out,  which can be found in the  tools directory of the distribution. The executable kernel file should be named simply kernel.</p>
      <p> In a similar manner, compile and link the memory manager. It has no assembly code files, just C files. If  lliblcem  has been removed, restore it manually before starting. Then mount the diskette with the  mm  directory on  /user.  Copy the  h  directory there if it is not already present and use the  makefile  or  make.bat file to compile and link the memory manager. Alternatively, do it by hand with the command</p>
      <p> cc -c -Di8088 -w *.c</p>
      <p> Again, link and convert the final output to MINIX format, if necessary, and call it mm.</p>
      <p> Repeat the above process for the file system. Then compile, link, and convert  toolslinit,  putting the result on the file  init.  At this point you will have four independently compiled and linked files:  kernel, mm, fs,  and  init.  Ultimately, these four files will form the operating system.</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> However, before the boot diskette can be built, two more programs,  fsck  and bootblok  must be prepared. Both are located in  tools. Fsck  has two files, a C file,  fsck.c,  and an assembly language file,  fsckl.s. Bootblok  is entirely contained in the assembly code file  bootblok.s.  (The MS-DOS versions of the assembly language files have extension  .asm  rather than  .s).</p>
      <p> To compile  fsck.c,  you need the include files  hlconst.h, hitype.h, fslconst.h, and  fsltype.h.  Furthermore,  fsck.c  is the largest single file in MINIX, and its compilation strains the system space resources to the utmost. Be sure that  lliblcem has enough stack space (about 5IK) and that there are no unnecessary files anywhere taking up precious disk blocks. The command</p>
      <p> cc -c -T. fsck.c</p>
      <p> compiles  fsck.c  using the current directory for the (large) intermediate files. Link  fsck  with the command</p>
      <p> asld -T. fsckl.s fsck.s /usr/lib/libc.a /usr/lib/end.s Alternatively, just type make fsck</p>
      <p> Normally it will not be necessary to reassemble  bootblok  since changes to the operating system rarely require changes to the boot block. However, if the boot block must be changed, after assembling and linking it remove the header, for example, using  dd,  so that the first byte of the file is the first instruction. See tools I makefile  for the command sequence.</p>
      <p> D.5. BUILDING THE BOOT DISKETTE</p>
      <p> In this section we will describe how the six independently compiled and linked programs,  bootblok, kernel, mm, fs, init,  and  fsck  are forged together to make the boot diskette. The first time you try making a new operating system, use the six binaries provided in  tools,  rather than making new ones.</p>
      <p> D.5.1. Concepts</p>
      <p> The boot diskette contains the six programs mentioned above, in the order given.  The boot block occupies the first 512 bytes on the disk.  When the com puter is turned on, the ROM gets control and tries to read the boot block from drive 0 into memory at address 0x7C00.  If this read succeeds, the ROM jumps to address 0x7C00 to start the boot program.</p>
      <p> The MINIX boot program first copies itself to an address just below 192K, to get itself out of the way. Then it calls the BIOS repeatedly to load 16 cylinders full of data into memory starting at address 0x600 (1536). This data is the core image of the operating system, followed directly by  fsck.   When the loading is</p>
      <p> SEC. D.5</p>
      <p> BUILDING THE BOOT DISKETTE</p>
      <p> 429</p>
      <p> finished, the boot program jumps to the start of  fsck,  which then displays the initial menu. If the user types an equal sign,  fsck  jumps to 1536 to start MINIX.</p>
      <p> The boot diskette is generated by  tools/build.  It takes the six programs listed above and concatenates them in a special way. The first 512 bytes of the boot diskette come from  bootblok.  If need be, some zero bytes are added to pad bootblok  out to 512.  Bootblok  does not have a header, and neither does the boot diskette because when the ROM loads the boot block to address 0x7C00, it expects the first byte to be the start of the first instruction.</p>
      <p> At position 512, the boot diskette contains the kernel, again without a header. Byte 512 of the boot diskette will be placed at memory address 1536 by the boot program, and will be executed as the first MINIX instruction when  fsck  terminates. After the kernel comes  mm, fs, init,  and  fsck,  each padded out to a multiple of 16 bytes so that the next one begins at a click boundary.</p>
      <p> Each of the programs may be compiled either with or without separate I and D space. The two models are different, but  build  explicitly checks to see which model each program uses and handles it. In short, what  build  does is read six files, stripping the headers off the last five of them, and concatenate them onto the output, rounding the first one up to 512 bytes and the rest up to a multiple of 16 bytes.</p>
      <p> After having completed the concatenation of the six files,  build  makes three patches to the output.</p>
      <p> 1. The last 4 words of the boot block are set to the number of cylinders to load and the DS, PC, and CS values to use for running  fsck.  The boot program needs this information so that it can jump to  fsck  after it has finished loading. Without this information, the boot program would not know where to jump.</p>
      <p> 2.  Build  loads the first 8 words of the kernel's data segment with the CS and DS segment register values for  kernel, mm,fs,  and  init.  Without this information, the kernel could not run these programs when the time came: it would not know where they were. It also sets word 4 of the kernel's text segment to the DS value needed to run the kernel.</p>
      <p> 3. The ongin and size of  init  are inserted at address 4 of the file system's data space. The file system needs this information to know where to put the RAM disk, which begins just after the end of  init, exactly overwriting the start of  fsck.</p>
      <p> D.5.2. Step-by-Step Instructions</p>
      <p> First, compile, link, and if need be, convert to MINIX format  bootblok, kernel, mm, fs, init,  and  fsck  as described above, or better yet, use the ones provided where possible. The file  bootblok  provided in the distribution has already</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> been stripped of its header and is ready to use. If for any reason you need to reassemble it, do not forget to strip off the header, as is done in  makefile.</p>
      <p> If you have not already done so, compile  build  to run on the development system (see  makefile  and  make.bat).  If you are using a computer without a hard disk, collect the six parts of the operating system and  build  in  tools  in drive 1.</p>
      <p> Next unmount  lusr  and insert a blank diskette in drive 0. This will be the boot diskette. Now type</p>
      <p> build bootblok kernel mm fs init fsck /dev/fdO</p>
      <p> On a hard disk system, the command given from  tools  will probably be</p>
      <p> build bootblok ../kernel/kernel ../mm/mm ../fs/fs init fsck /dev/fdO</p>
      <p> When  build  finishes running, the boot diskette will be ready in drive 0 and a printout of the sizes will appear on standard output. Alternatively, you can just type</p>
      <p> make image</p>
      <p> to produce a bootable operating system on  IdevlfdO.  At the time you give the command, you need  lusr  in drive 0 so  make  itself can be loaded. Just before build  is called,  IdevlfdO  is unmounted and you are asked to insert a blank (formatted) diskette in drive 0. It pauses until you hit the return key.</p>
      <p> If you wish to use  make,  you will have to create dummy  files fsck. s  and  init.s to prevent  make  from trying to reconstruct  fsck  and  init.  Before running it for real, give the command</p>
      <p> make -n image</p>
      <p> to see what  make  intends to do. If need be, use  touch  to trick  make  into doing what  you  want, rather than what  it  wants.</p>
      <p> D.6. TESTING MINIX</p>
      <p> After having built a new version of MINIX, it is a good idea to test it. To aid in this testing, a collection of test programs have been provided on the  /user diskette. To use the test programs, bring up the system, except that when it asks you to insert  lusr  in drive 0, insert  I user  instead. Now change to  /user/test  and list the files there. You should find a shell script called  run,  and a series of executable files called  testO, testl,  and so on, as well as a few other files used by the test programs. You can run any of the tests individually, or type</p>
      <p> run</p>
      <p> to run them all. If any errors are encountered, they will be reported. You will have to refer to the source code to see what each error means. The tests are quite comprehensive, and take more than 10 minutes to finish.</p>
      <p> SEC. D.7</p>
      <p> INSTALLING NEW DEVICE DRIVERS</p>
      <p> 431</p>
      <p> D.7. INSTALLING NEW DEVICE DRIVERS</p>
      <p> Once you have successfully reached this point, you will now be able to modify MINIX. In general, if a modification only affects, say, the file system, you will not have to recompile the memory manager or kernel. If a modification affects any of the files in  h,  you should recompile the entire system, just to be safe.</p>
      <p> One common modification is adding new I/O devices and drivers. To add a new I/O device to MINIX, it is necessary to write a driver for it. The new driver should use the same message interface as the existing ones. The driver should be put in the directory  kernel  and  makefile  or  make.bat  updated, if they are used. In addition, the entry point of the new task must be added to the list contained in the array  task  in  kernel!table.c.  If  dmp.c  is still in use, an entry also has to be made for it in  nayme.</p>
      <p> Two changes are also required in the  h  directory. In  hiconst.h,  the constant NR-TASKS  has to be increased by 1, and the new task has to be given a name in hlcom.h.</p>
      <p> A new special file will have to be created for the driver. This can be done by adding a line to the directory  Idev  in  toolslproto.ram.</p>
      <p> To tell the file system which task is handling the new special file, a line has to be added to the array  dmap m fsi table, c.</p>
      <p> D.8. TROUBLESHOOTING</p>
      <p> If you modify the system, there is always the possibility that you will introduce an error. In this section, we will discuss some of the more common problems and how to track them down.</p>
      <p> To start with, if something is acting strange, turn the computer off and reboot from scratch. This gets everything into a known state. Rebooting with CTRL-ALT-DEL may leave the system in a peculiar state, which may be the cause of the trouble.</p>
      <p> If the message</p>
      <p> Booting MINIX 1.1</p>
      <p> does not appear on the screen after the power-on self-tests have completed, something is wrong with the boot block. The boot block prints this message by calling the BIOS. Make a dump of the first block of the boot diskette and examine it by hand to see if it contains the proper program.</p>
      <p> If the above message appears, but the initial menu does not, it is likely that fsck  is not being started, since the first thing  fsck  does is print the menu. Check the last 6 bytes of the boot block to see if the segment and offset put there by build  correspond to the address at which  fsck  is located (right after  init).</p>
      <p> If the menu appears, but the system does not respond to the equal sign,</p>
      <p> MINIX IMPLEMENTERS GUIDE</p>
      <p> APPENDIX D</p>
      <p> MINIX is probably being started, but crashing during initialization. One possible cause is the introduction of print statements into the kernel. However, it is not permitted to display anything until after the terminal task has run to initialize itself. Be careful about where you put the print statements.</p>
      <p> If the screen has been cleared and the message giving the sizes has appeared, the kernel has initialized itself, the memory manager has run and blocked waiting for a message, and the file system has started running. This message is printed as soon as the file system has read the super-block of the root file system.</p>
      <p> If the system appears to hang before or after reading the root file system, some help can be obtained by hitting the Fl or F2 function keys (unless the dump routines have been removed). By hitting Fl twice a few seconds apart and noting the times in the display, it may be possible to see which processes are running. If, for example,  init  is unable to fork, for whatever reason, or cannot open letclttys,  or cannot execute  Ibinlsh  or  /bin/login,  the system will hang, but process  2 (init)  may continue to use CPU cycles. If the Fl display shows that process 2 is constantly running, it is a good bet that  init  is unable to make a system call or open a file that is essential. The problem can usually be localized by putting statements in the main loops of the file system and memory manager to print a line describing each incoming message and each outgoing reply. Recompile and test the system using the new output as a guide.</p>
      <p> E</p>
      <p> MINIX</p>
      <p> SOURCE CODE LISTING</p>
      <p> File: h/const.h</p>
      <p> MINIX SOURCE CODE</p>
      <p> 0000 0001 0002 0003 0004 0005 0006 0007 0008 0009 0010 0011 0012 0013 0014 0015 0016 0017 0018 0019 0020 0021 0022 0023 0024 0025 0026 0027 0028 0029 0030 0031 0032 0033 0034 0035 0036 0037 0038 0039 0040 0041 0042 0043 0044 0045 0046 0047 0048 0049</p>
      <p> /* Copyright (C) 1987 by Prentice-Hall, Inc.    The author and publisher</p>
      <p> * of this software make no warranty of any kind, express or implied,</p>
      <p> * with regard to this software or its documentation.    Nor shall they</p>
      <p> * be liable for incidental or consequential damages in connection</p>
      <p> * with the furnishing, performance, or use of this   software or</p>
      <p> * documentation.    Permission is granted to make a limited number of</p>
      <p> * copies of this software for educational or research purposes only. */</p>
      <p> A Process numbers of some important processes #/</p>
      <p> ^define MM_PR0C_NR 0</p>
      <p> tfdefine FS_PR0C_NR 1</p>
      <p> ^define INIT_PR0C_NR 2</p>
      <p> ^define L0W_USER 2</p>
      <p> /* Miscellaneous */</p>
      <p> tfdefine BYTE 0377</p>
      <p> ^define T0_USER 0</p>
      <p> ^define FR0M_USER 1</p>
      <p> #define READING 0</p>
      <p> ^define WRITING 1</p>
      <p> #define ABS -999</p>
      <p> A process number of memory manager */ A process number of file system */ A init — the process that goes multiuser */ A first user not part of operating system */</p>
      <p> A mask for 8 bits */</p>
      <p> /* flag telling to copy from fs to user */</p>
      <p> A flag telling to copy from user to fs »/</p>
      <p> A copy data to user */</p>
      <p> A copy data from user */</p>
      <p> /* this process means absolute memory */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: h/const.h</p>
      <p> 435</p>
      <p> 0050</p>
      <p> 0051 ^define W0RD_SIZE 2 /* number of bytes per word */</p>
      <p> 0052</p>
      <p> 0053 #define Nil PTR     (char *) 0      /* generally useful expression */</p>
      <p> 0054</p>
      <p> 0055 d/define N0_NUM 0x8000 /» used as numerical argument to panicO */</p>
      <p> 0056 ^define MAX_PATH 128 /* max length of path names */</p>
      <p> 0057 #define SIG_PUSH_BYTES 8 /* how many bytes pushed by signal */</p>
      <p> 0058 ^define MAX_ISTACK_BYTES     1024 /* maximum initial stack size for EXEC */ 0059</p>
      <p> 0060 /* Device numbers of root (RAM) and boot (fdO) devices. */</p>
      <p> 0061  #define  R00T_DEV (dev_nr)     256 /* major-minor device number of root dev */</p>
      <p> 0062 #define B00T_DEV (dev_nr) 512 /* major-minor device number of boot diskette 0063</p>
      <p> 0064 /# Flag bits for i_mode in the inode. #/</p>
      <p> 0065 ^define I_TYPE 0170000 /* this field gives inode type */</p>
      <p> 0066 ^define I_REGULAR 0100000 /* regular file, not dir or special */</p>
      <p> 0067 ^define I_BL0CK_SPECIAL 0060000 /* block special file */</p>
      <p> 0068 ^define I-DIRECTORY        0040000 /* file is a directory */</p>
      <p> 0069 /((define I_CHAR_SPECIAL   0020000 /# character special file */</p>
      <p> 0070 ^define I_SET_UID_BIT     0004000 /♦ set effective uid on exec */</p>
      <p> 0071 iCdefine I_SET_GID_BIT     0002000 /* set effective gid on exec */</p>
      <p> 0072 #define AL I MODES 0006777 /* all bits for user, group and others */</p>
      <p> 0073 ^define RWX_M0DES 0000777 /* mode bits for RWX only */</p>
      <p> 0074 ^define R_BIT 0000004 /* Rwx protection bit #/</p>
      <p> 0075 ^define W_BIT 0000002  I*  rWx protection bit */</p>
      <p> 0076 ^define X_BIT 0000001 /* rwX protection bit */</p>
      <p> 0077 ^define I_N0T_ALL0C       0000000 /* this inode is free */</p>
      <p> 436 File: h/callnr.h MINIX SOURCE CODE</p>
      <p> 0100 //define NCALLS 69      /* number of system calls allowed */ 0101</p>
      <p> 0102 //define EXIT 1</p>
      <p> 0103 ^define FORK 2</p>
      <p> 0104 if/define READ 3</p>
      <p> 0105 ^define WRITE 4</p>
      <p> 0106 if/define OPEN 5</p>
      <p> 0107 //define CLOSE 6</p>
      <p> 0108 ^define WAIT 7</p>
      <p> 0109 if/define CREAT 8</p>
      <p> 0110 it/define LINK 9</p>
      <p> 0111 ^define UNLINK 10</p>
      <p> 0112 tfdefine CHDIR 12</p>
      <p> 0113 //define TIME 13</p>
      <p> 0114 //define MKNOD 14</p>
      <p> 0115 ^define CHMOD 15</p>
      <p> 0116 iCdefine CHOWN 16</p>
      <p> 0117 //define BRK 17</p>
      <p> 0118 li/define STAT 18</p>
      <p> 0119 //define LSEEK 19</p>
      <p> 0120 ^define GETPID 20</p>
      <p> 0121 //define MOUNT 21</p>
      <p> 0122 if/define UMOUNT 22</p>
      <p> 0123 ^define SETUID 23</p>
      <p> 0124 //define GETUID 24</p>
      <p> 0125 //define STIME 25</p>
      <p> 0126 /(define ALARM 27</p>
      <p> 0127 ^define FSTAT 28</p>
      <p> 0128 //define PAUSE 29</p>
      <p> 0129 ^define UTIME 30</p>
      <p> 0130 //define ACCESS 33</p>
      <p> 0131 //define SYNC 36</p>
      <p> 0132 //define KILL 37</p>
      <p> 0133 ^define DUP 41</p>
      <p> 0134 //define PIPE 42</p>
      <p> 0135 //define TIMES 43</p>
      <p> 0136 //define SETGID 46</p>
      <p> 0137 #define GETGID 47</p>
      <p> 0138 //define SIGNAL 48</p>
      <p> 0139 ^define IOCTL 54</p>
      <p> 0140 //define EXEC 59</p>
      <p> 0141 ^define UMASK 60</p>
      <p> 0142 //define CHROOT 61 0143</p>
      <p> 0144 /# The following are not system calls, but are processed like them. */</p>
      <p> 0145 //define KSIG 64      /* kernel detected a signal */</p>
      <p> 0146 //define UNPAUSE 65      /# to MM or FS: check for EINTR */</p>
      <p> 0147 //define BRK2 66      /* to MM: used to say how big FS &amp; INIT are */</p>
      <p> 0148 //define REVIVE 67       /* to FS: revive a sleeping process */</p>
      <p> 0149 //define TASK.REPLY 68      /» to FS: reply code from tty task */</p>
      <p> MINIX SOURCE CODE File: h/com.h 437</p>
      <p> 438 File: h/com.h MINIX SOURCE CODE</p>
      <p> 0200 ^define DELTA_TICKS m6_ll /* alarm interval in clock ticks */</p>
      <p> 0201 ^define FUNC_T0_CALL     m6_fl /* pointer to function to call */</p>
      <p> 0202 ^define NEW_TIME m6_ll /* value to set clock to (5ET_TIME) */</p>
      <p> 0203 ^define CL0CK_PR0C_NR   m6_il /* which proc (or task) wants the alarm? */</p>
      <p> 0204 ^define SECONDS_LEFT     m6_ll /* how many seconds were remaining #/ 0205</p>
      <p> 0206 /* Names of message fields used for messages to block and character tasks. */</p>
      <p> 0207 ^define DEVICE m2_il /* major-minor de vice */</p>
      <p> 0208 tfdefine PR0C_NR m2_i2 /# which (proc) wants 1/0? */</p>
      <p> 0209 ^define COUNT m2_i3 /* how many bytes to transfer */</p>
      <p> 0210 ^define POSITION m2_ll /* file offset ♦/</p>
      <p> 0211 ^define ADDRESS m2_pl /* core buffer address */ 0212</p>
      <p> 0213 /* Names of message fields for messages to TTY task. */</p>
      <p> 0214 ^define TTY_LINE m2_il /# message parameter: terminal line */</p>
      <p> 0215 ^define TTY_REQUEST m2_i3  /*  message parameter:  ioctl request code */</p>
      <p> 0216 #define TTY_SPEK m2_ll /* message parameter: ioctl speed, erasing */</p>
      <p> 0217 ^define TTY_FLAGS m2_12 /# messa^s parameter: ioctl tty mode */ 0218</p>
      <p> 0219 /* Names of message fields used in reply messages from tasks. */</p>
      <p> 0220 ^define REP_PR0C_NR m2_il /#  #  of proc on whose behalf 1/0 was done */</p>
      <p> 0221 ^define REP_STATUS m2_i2 /* bytes transferred or error number */ 0222</p>
      <p> 0223 /# Names of fields for copy message to SYSTASK. #/</p>
      <p> 0224 #define SRC_SPACE m5_cl /* T or D space (stack is also D) */</p>
      <p> 0225 ^define SRC_PR0C_NR m5_il /* process to copy from */</p>
      <p> 0226 ^define SRC_BUFFER m5_ll /* virtual address where data come from */</p>
      <p> 0227 ^define DST_SPACE m5_c2 /* T or D space (stack is also D) */</p>
      <p> 0228 ^define DST_PR0C_NR m5_i2 /# process to copy to */</p>
      <p> 0229 ^define DST_BUEFER m5_12 /* virtual address where data go to */</p>
      <p> 0230 ^define C0PY_BYTES m5_13 /* number of bytes to copy */ 0231</p>
      <p> 0232 /* Field names for accounting, SYSTASK and miscellaneous. */</p>
      <p> 0233 ^define USER_TIME m4_ll  I*  user time consumed by process */</p>
      <p> 0234 ^define SYSTEM_TIME m4_12  I*  system time consumed by process */</p>
      <p> 0235 ^define CHILD_UTIME m4_13 /* user time consumed by process' children */</p>
      <p> 0236 ^define CHILD_STIME m4_14 /* systime consumed by process' children */ 0237</p>
      <p> 0238 ^define PR0C1 ml_il /* indicates a process */</p>
      <p> 0239 ^define PR0C2 ml_i2 /* indicates a process */</p>
      <p> 0240 ^define PID ml_i3 /* process id passed from MM to kernel */</p>
      <p> 0241 ^define STACK_PTR ml_pl /* used for stack ptr in sys_exec, sys_getsp */</p>
      <p> 0242 ^define PR m6_il /* process number for sys_sig  */</p>
      <p> 0243 ^define SIGNUM m6_i2 /* signal number for sys_sig */</p>
      <p> 0244 ^define FUNC m6_fl /* function pointer for sys_sig */</p>
      <p> 0245 ^define MEM_PTR ml_pl /* tells where memory map is for sys_newmap */</p>
      <p> 0246 ^define CANCEL 0 /* general request to force a task to cancel  */</p>
      <p> 0247 ^define SIG_MAP ml_i2 /* used by kernel for passing signal bit map #/</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: h/error.h</p>
      <p> 439</p>
      <p> 0250 /* Error codes.    They are negative since a few system calls, such as READ, can</p>
      <p> 0251 # either return a positive number indicating success, or an error code.</p>
      <p> 0252 */ 0253</p>
      <p> 0254 ^define NERR0R 34</p>
      <p> 0255 #define OK 0</p>
      <p> 0256 ^define ERROR -1</p>
      <p> 0257 ^define EPERM -1</p>
      <p> 0258 tfdefine EN0ENT -2</p>
      <p> 0259 ^define ESRCH -3</p>
      <p> 0260 ^define EINTR -4</p>
      <p> 0261 ^define EID -5</p>
      <p> 0262 ^define ENXI0 -6</p>
      <p> 0263 ^define E2BIG -7</p>
      <p> 0264 #define EN0EXEC -8</p>
      <p> 0265 #define EBADF -9</p>
      <p> 0266 #define ECHILD -10</p>
      <p> 0267 ^define EAGAIN -11</p>
      <p> 0268 ^define EN0MEM -12</p>
      <p> 0269 tfdefine EACCES -13</p>
      <p> 0270 ^define EFAULT -14</p>
      <p> 0271 ^define EN0TBLK -15</p>
      <p> 0272 ^define EBU5Y -16</p>
      <p> 0273 ^define EEXIST -17</p>
      <p> 0274 ^define EXDEV -18</p>
      <p> 0275 tfdefine ENODEV -19</p>
      <p> 0276 ^define ENOTDIR -20</p>
      <p> 0277 ^define EI5DIR -21</p>
      <p> 0278 tfdefine EINVAL -22</p>
      <p> 0279 ^define ENFILE -23</p>
      <p> 0280 ^define EMFILE -24</p>
      <p> 0281 ^define ENOTTY -25</p>
      <p> 0282 ^define ETXTBSY -26</p>
      <p> 0283 ^define EFBIG -27</p>
      <p> 0284 ^define ENOSPC -28</p>
      <p> 0285 tfdefine ESPIPE -29</p>
      <p> 0286 #define EROFS -30</p>
      <p> 0287 #define EMLINK -31</p>
      <p> 0288 ^define EPIPE -32</p>
      <p> 0289 ^define EDOM -33</p>
      <p> 0290 ^define ERANGE -34 0291</p>
      <p> 0292 ^define E_L0CKED -101</p>
      <p> 0293 fldefine E_BAD_CALL -102</p>
      <p> 0294 ^define E_LONG_STRING -103 0295</p>
      <p> 0296 /# The following error codes are generated by the kernel itself. */</p>
      <p> 0297 ^define E_BAD_DEST -1      /* destination address illegal */</p>
      <p> 0298 #define E_BAD_SRC -2       /*  source address illegal */</p>
      <p> 0299 tfdefine E_TRY_AGAIN -3      /* can't send-- tables full */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: h/sgtty.h</p>
      <p> 441</p>
      <p> input speed (not used at present) */ output speed (not used at present) */ erase character */ kill character ■*/ mode flags */</p>
      <p> character that generates SIGINT */ character that generates SIGQUIT */ start output (initially CTRL-Q) */ stop output (initially CTRL-5) */ end-of-file (initially CTRL-D) */ input delimiter (like nl) */</p>
      <p> set to cause tab expansion */</p>
      <p> set to enable raw mode */</p>
      <p> set to map If to cr + If */</p>
      <p> set to enable echoing of typed input */</p>
      <p> set to enable cbreak mode  #/</p>
      <p> neither CBREAK nor RAW */</p>
      <p> File: h/signal.h</p>
      <p> MINIX SOURCE CODE</p>
      <p> /* number of signals used */</p>
      <p> illegal instruction (not reset when caught)*</p>
      <p> EMT instruction */ floating point exception */ kill (cannot be caught or ic bus error */</p>
      <p> */</p>
      <p> /* used by kernel to signal stack fault */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: h/stat.h</p>
      <p> 443</p>
      <p> 0500 /* Macros */</p>
      <p> 0501 ^define MAX(a,b) (a &gt; b ? a : b)</p>
      <p> 0502 ^define MIN(a,b) (a &lt; b ? a : b) 0503</p>
      <p> 0504 /* Type definitions */</p>
      <p> 0505 typedef unsigned short unshort; /* must be 16-bit unsigned */</p>
      <p> 0506 typedef unshort block_nr; /* block number */</p>
      <p> 0507 ^define NCLBL0CK (block_nr) 0     /* indicates the absence of a block number */</p>
      <p> 0508 ^define MAX_BL0CK_NR (block_nr) 0177777 0509</p>
      <p> 0510 typedef unshort inode_nr; /* inode number */</p>
      <p> 0511 ^define N0_ENTRY (inode_nr) 0     /* indicates the absence of a dir entry */</p>
      <p> 0512 ^define MAX_IN0DE_NR (inode_nr) 0177777 0513</p>
      <p> 0514 typedef unshort zone_nr; /* zone number #/</p>
      <p> 0515 ^define N0_Z0NE     (zone_nr) 0     /# indicates the absence of a zone number */</p>
      <p> 0516 ^define HIGHEST_Z0NE (zone_nr) 0177777 0517</p>
      <p> 0518 typedef unshort bit_nr; /* if inode_nr &amp; zone_nr both unshort,</p>
      <p> 0519 then also unshort, else long */ 0520</p>
      <p> 0521 typedef long zone_type; /* zone size */</p>
      <p> 0522 typedef unshort mask_bits; /* mode bits  */</p>
      <p> 0523 typedef unshort dev_nr; /* major | minor device number */</p>
      <p> 0524 ^define N0_DEV       (dev_nr) ~0     /* indicates absence of a device number */ 0525</p>
      <p> 0526 typedef char links; /* number of links to an inode #/</p>
      <p> 0527 #define MAX_LINKS 0177 0528</p>
      <p> 0529 typedef long real_time; /* real time in seconds since Jan 1, 1970 */</p>
      <p> 0530 typedef long file_pos; /* position in, or length of, a file */</p>
      <p> 0531 ^define MAX_FILE_P0S 017777777777L</p>
      <p> 0532 typedef short int uid; /* user id */</p>
      <p> 0533 typedef char gid; /* group id #/ 0534</p>
      <p> 0535 typedef unsigned vir_bytes;        /* virtual addrecL.es and lengths in bytes */</p>
      <p> 0536 typedef unsigned vir_clicks;       /* virtual addresses and lengths in clicks */</p>
      <p> 0537 typedef long phys_bytes; /* physical addresses and lengths in bytes */</p>
      <p> 0538 typedef unsigned phys_clicks;     /* physical addresses and lengths in clicks */</p>
      <p> 0539 typedef int signed_clicks; /* same length as phys_clicks, but signed */ 0540</p>
      <p> 0541  /*  Types relating to messages. */</p>
      <p> 0542 #define Ml 1</p>
      <p> 0543 ^define M3 3</p>
      <p> 0544 #define M4 4</p>
      <p> 0545 ^define M3_STRING 14 0546</p>
      <p> 0547 typedef struct {int mlil, mli2, mli3; char *mlpl, #mlp2, *mlp3;} mess_l;</p>
      <p> 0548 typedef struct {int m2il, m2i2, m2i3;  long m211, m212; char #m2pl;} mess_2;</p>
      <p> 0549 typedef struct {int m3il, m3i2; char *m3pl; char m3cal[M3_STRING];} mess_3;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File- h/type.h</p>
      <p> 445</p>
      <p> 0550 typedef struct {long m411, m412, m413, m414;} mess_4;</p>
      <p> 0551 typedef struct {char m5cl, m5c2; int ra5il, m5i2; long m511, m512, m513;} mes</p>
      <p> 0552 typedef struct {int m6il, m6i2, m6i3; long m611; int (*m6fl)();} mess_6; 0553</p>
      <p> 0554 typedef struct {</p>
      <p> 0555 int m_source; /* who sent the message #/</p>
      <p> 0556 int m_type; /* what kind of message is it */</p>
      <p> 0557 union {</p>
      <p> 0558 mess_l m_ml;</p>
      <p> 0559 mess_2 m_m2;</p>
      <p> 0560 mess_3 m_m3;</p>
      <p> 0561 mess_4 m_m4;</p>
      <p> 0562 mess_5 m_m5;</p>
      <p> 0563 mess_6 m_m6;</p>
      <p> 0564 } m_u;</p>
      <p> 0565 } message; 0566</p>
      <p> 0567 //define MESS_SIZE (sizeof(message))</p>
      <p> 0568 //define NIL_MESS (message *) 0 0569</p>
      <p> 0570 /* The following defines provide names for useful members. */</p>
      <p> 0571 //define ml_il m_u.m_ml.mlil</p>
      <p> 0572 //define ml_i2   m_u.m_ml.mli2</p>
      <p> 0573 /(define ml_i3 m_u.m_ml.mli3</p>
      <p> 0574 /(define ml_pl m_u.m_ml.mlpl</p>
      <p> 0575 //define ml_p2 m_u.m_ml.mlp2</p>
      <p> 0576 //define ml_p3 m_u.m_ml.mlp3 0577</p>
      <p> 0578 ^define m2_il m_u.m_m2.m2il</p>
      <p> 0579 /(define m2_i2 m_u.m_m2.m2i2</p>
      <p> 0580 /(define m2_i3 m_u.m_m2.m2i3</p>
      <p> 0581 //define m2_ll m_u.m_m2.m211</p>
      <p> 0582 #define m2_12 m_u.m_m2.m212</p>
      <p> 0583 ^define m2_pl m_u.m_m2.m2pl 0584</p>
      <p> 0585 //define m3_il m_u.m_m3.m3il</p>
      <p> 0586 ^define m3_i2 m_u.m_m3.m3i2</p>
      <p> 0587 //define m3_pl m_u.m_m3.m3pl</p>
      <p> 0588 /(define m3_cal m_u.m_m3.m3cal 0589</p>
      <p> 0590</p>
      <p> 0591 //define m4_ll m_u.m_m4.m411</p>
      <p> 0592 //define m4_12 m_u.m_m4.m412</p>
      <p> 0593 //define m4_13 m_u.m_m4.m413</p>
      <p> 0594 //define m4_14 m_u.m_m4.m414 0595</p>
      <p> 0596 //define m5_cl m_u.m_m5.m5cl</p>
      <p> 0597 //define m5_c2 m_u.m_m5.m5c2</p>
      <p> 0598 //define m5_il m_u.m_m5.m5il</p>
      <p> 0599 ^define m5_i2 m_u.m_m5.m5i2</p>
      <p> 446 File: h/type.h MINIX SOURCE CODE</p>
      <p> 0600 ^define m5_ll   m_u.m_m5.m511</p>
      <p> 0601 ^define m5_12 m_u.m_m5.m512</p>
      <p> 0602 ^define m5_13 m_u.m_m5.m513 0603</p>
      <p> 0604 ^define m6_il m_u.m_m6.m6il</p>
      <p> 0605 ^define m6_i2 m_u.m_m6.m6i2</p>
      <p> 0606 ^define m6_i3 m_u.m_m6.m6i3</p>
      <p> 0607 ^define m6_ll m_u.m_m6.m611</p>
      <p> 0608 ^define m6_fl m_u.m_m6.m6fl 0609</p>
      <p> 0610 struct mem_map {</p>
      <p> 0611 vir_clicks mem_virj /* virtual address */</p>
      <p> 0612 phys_clicks mem_phys; /* physical address */</p>
      <p> 0613 vir_clicks mem_len; /* length */</p>
      <p> 0614 }; 0615</p>
      <p> 0616 struct copy_info { /* used by sys_copy(src, dst, bytes) */</p>
      <p> 0617 int cp_src_proc;</p>
      <p> 0618 int cp_src_space;</p>
      <p> 0619 vir_bytes cp_src_vir;</p>
      <p> 0620 int cp_dst_proc;</p>
      <p> 0621 int cp_dst_space;</p>
      <p> 0622 vir_bytes cp_dst_vir;</p>
      <p> 0623 vir_bytes cp_bytes;</p>
      <p> 0624 };</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/const.h</p>
      <p> 447</p>
      <p> 0650 /# General constants used by the kernel. */ 0651</p>
      <p> 0652 Hfifdef i8088</p>
      <p> 0653 /* p_reg contains: ax, bx, cx, dx, si, di, bp, es, ds, cs, ss in that order. */</p>
      <p> 0654 //define NR_REGS                 11 /* number of general regs in each proc slot */</p>
      <p> 0655 //define INIT_PSW          0x0200 /* initial psw */</p>
      <p> 0656 ^define INIT_SP (int*)0x0010 /* initial sp: 3 words pushed by kernel #/ 0657</p>
      <p> 0658 /* The following values are used in the assembly code.    Do not change the</p>
      <p> 0659 * values of 'E5_REG', 'DS_REG\ 'CS_REG', or 'SS_REG' without making the</p>
      <p> 0660 * corresponding changes in the assembly code.</p>
      <p> 0661 */</p>
      <p> 0662 ^define ES_REG                     7 /* proc[i].p_reg[ESREG] is saved es */</p>
      <p> 0663 ^define DS_REG                      8 /* procfi].p_reg[DSREG] is saved ds ♦/</p>
      <p> 0664 ^define CS_REG                     9 /* procfi].p_reg[CSREG] is saved cs */</p>
      <p> 0665 ^define SS_REG                  10 /* proc[i].p_reg[SSREG] is saved ss #/ 0666</p>
      <p> 0667 jfdefine VECT0R_BYTES        260 /* bytes of interrupt vectors to save */</p>
      <p> 0668 //define MEM_BYTES      655360L /* memory  size  for /dev/mem */ 0669</p>
      <p> 0670 /* Interrupt vectors */</p>
      <p> 0671 //define CL0CK_VECT0R           8 /* clock interrupt vector #/</p>
      <p> 0672 //define KEYB0ARD_VECT0R      9 /* keyboard interrupt vector #/</p>
      <p> 0673 //define FL0PPY_VECT0R        14 /* floppy disk interrupt vector */</p>
      <p> 0674 //define PRINTER_VECT0R      15 /* line printer interrupt vector */</p>
      <p> 0675 //define SYS_VECT0R             32 /* system calls are made with int SYSVEC */ 0676</p>
      <p> 0677 /* The 8259A interrupt controller has to be re-enabled after each interrupt. */</p>
      <p> 0678 //define INT_CTL              0x20 /* 1/0 port for interrupt controller ♦/</p>
      <p> 0679 //define INT_CTLMASK        0x21 /* setting bits in this port disables ints */</p>
      <p> 0680 #define ENABLE                0x20 /# code used to re-enable after an interrupt */</p>
      <p> 0681 #endif 0682</p>
      <p> 0683 ^define TASK_STACK_BYTES 256 /# how many bytes for each task stack */</p>
      <p> 0684 ^define K_STACK_BYTES      256 /* how many bytes for the kernel stack */ 0685</p>
      <p> 0686 #define RET_REG                   0 /* system call return codes go in this reg */</p>
      <p> 0687 //define IDLE -999 /* 'cur_proc' = IDLE means nobody is running */ 0688</p>
      <p> 0689 /* The following items pertain to the 3 scheduling queues. */</p>
      <p> 0690 tfdefine NQ                          3 /*  §  of scheduling queues */</p>
      <p> 0691 ^define TASK_Q                     0 /* ready tasks are scheduled via queue 0 */</p>
      <p> 0692 //define SERVER_Q                  1 /♦ ready servers are scheduled via queue 1 */</p>
      <p> 0693 ^define USER_Q                     2 /# ready users are scheduled via queue 2 */ 0694</p>
      <p> 0695 ^define printf             printk /* the kernel really uses printk, not printf */</p>
      <p> 448 File: kernel/glo.h MINIX SOURCE CODE</p>
      <p> 0700 /* Global variables used in the kernel. */ 0701</p>
      <p> 0702 /* Clocks and timers */</p>
      <p> 0703 EXTERN real_time realtime; /* real time clock */</p>
      <p> 0704 EXTERN int lost_ticks; /* incremented when clock int can't send mess*/ 0705</p>
      <p> 0706  /*  Processes, signals, and messages. */</p>
      <p> 0707 EXTERN int cur_proc; /* current process */</p>
      <p> 0708 EXTERN int prev_proc; /* previous process */</p>
      <p> 0709 EXTERN sig_procs; /* number of procs with p_pending != 0 */</p>
      <p> 0710 EXTERN message int_mess; /* interrupt routines build message here */ 0711</p>
      <p> 0712 /* The kernel and task stacks. */</p>
      <p> 0713 EXTERN struct t_stack {</p>
      <p> 0714 int stk[TASK_STACK_BYTES/sizeof(int)];</p>
      <p> 0715 } t_stack[NR_TASKS -1]; /* task stacks; task = -1 never really runs */ 0716</p>
      <p> 0717 EXTERN char k_stack[K_STACK_BYTES];        /* The kernel stack. */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/proc.h</p>
      <p> 449</p>
      <p> 0750 /* Here is the declaration of the process table.    Three assembly code routines</p>
      <p> 0751 * reference fields in it.   They are restartO, saveO, and csv(). When</p>
      <p> 0752 * changing 'proc', be sure to change the field offsets built into the code.</p>
      <p> 0753 # It contains the process' registers, memory map, accounting, and message</p>
      <p> 0754 * send/receive information.</p>
      <p> 0755 */ 0756</p>
      <p> 0757 EXTERN struct proc {</p>
      <p> 0758 int p_reg[NR_REGSj; /* process' registers ♦/</p>
      <p> 0759 int *p_sp; /* stack pointer */</p>
      <p> 0760 struct pc_psw p_pcpsw; /* pc and psw as pushed by interrupt */</p>
      <p> 0761 int p_flags; /* P_SL0T_FREE, SENDING, RECEIVING, etc. */</p>
      <p> 0762 struct mem_map p_map[NR_SEGS];/* memory map */</p>
      <p> 0763 int #p_splimit; /* lowest legal stack value */</p>
      <p> 0764 int p_pid; /* process id passed in from MM */ 0765</p>
      <p> 0766 real_time user_time; /* user time in ticks */</p>
      <p> 0767 real_time sys_time; /* sys time in ticks */</p>
      <p> 0768 real_time child_utime; /* cumulative user time of children */</p>
      <p> 0769 real_time child_stime; /* cumulative sys time of children */</p>
      <p> 0770 real_time p_alarm; /* time of next alarm in ticks, or 0 */ 0771</p>
      <p> 0772 struct proc *p_callerq; /* head of list of procs wishing to send */</p>
      <p> 0773 struct proc *p_sendlink; /* link to next proc wishing to send */</p>
      <p> 0774 message *p_messbuf; /* pointer to message buffer */</p>
      <p> 0775 int p_getfrom; /* from whom does process want to receive? */ 0776</p>
      <p> 0777 struct proc *p_nextready; /* pointer to next ready process */</p>
      <p> 0778 int p_pending; /* bit map for pending signals 1-16 */</p>
      <p> 0779 } proc[NR_TASKS+NR_PR0CS]; 0780</p>
      <p> 0781 /* Bits for p_flags in proc[].    A process is runnable iff p_flags == 0 */</p>
      <p> 0782 ^define P_SL0T_FREE 001      /* set when slot is not in use */</p>
      <p> 0783 ^define N0_MAP 002      /* keeps unmapped forked child from running */</p>
      <p> 0784 tfdefine SENDING 004      /* set when process blocked trying to send */</p>
      <p> 0785 ^define RECEIVING 010      /* set when process blocked trying to recv */ 0786</p>
      <p> 0787 ^define proc_addr(n) &amp;proc[NR_TASKS + n]</p>
      <p> 0788 ^define NIL_PR0C (struct proc *) 0 0789</p>
      <p> 0790 EXTERN struct proc *proc_ptr;     /* &amp;proc[cur_proc] */</p>
      <p> 0791 EXTERN struct proc *bill_ptr;     /* ptr to process to bill for clock ticks */</p>
      <p> 0792 EXTERN struct proc *rdy_head[NQ]; /* pointers to ready list headers  */</p>
      <p> 0793 EXTERN struct proc *rdy_tail[NQj; /* pointers to ready list tails */ 0794</p>
      <p> 0795 EXTERN unsigned busy_map; /* bit map of busy tasks */</p>
      <p> 0796 EXTERN message *task_mess[NR_TASKS+l];   /* ptrs to messages for busy tasks */</p>
      <p> 0800 /* The 'pc_psw' struct is machine dependent.   It must contain the information</p>
      <p> 0801 * pushed onto the stack by an interrupt, in the same format as the hardware</p>
      <p> 0802 » creates and expects.   It is used for storing the interrupt status after a</p>
      <p> 0803 * trap or interrupt, as well as for causing interrupts for siqnals.</p>
      <p> 0804 */ 0805</p>
      <p> 0806</p>
      <p> 0807 #ifdef i8088</p>
      <p> 0808 struct pc_psw {</p>
      <p> 0809 int (+pc)(); /♦ storage for program counter #/</p>
      <p> 0810 phys.clicks cs; /* code segment register */</p>
      <p> 0811 unsigned psw; /# program status word #/</p>
      <p> 0812 }; 0813</p>
      <p> 0814 /* This struct is used to build data structure pushed by kernel upon signal. */</p>
      <p> 0815 struct sig_info {</p>
      <p> 0816 int signo; /* sig number at end of stack */</p>
      <p> 0817 struct pc_psw sigpcpsw;</p>
      <p> 0818 };</p>
      <p> 0819 il/endif</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/main.c</p>
      <p> 451</p>
      <p> 0850 /* This file contains the main program of MINIX.   The routine mainO</p>
      <p> 0851 * initializes the system and starts the ball rolling by setting up the proc</p>
      <p> 0852 * table, interrupt vectors, and scheduling each task to run to initialize</p>
      <p> 0853 * itself.</p>
      <p> 0854 *</p>
      <p> 0855 * The entries into this file are:</p>
      <p> 0856 *     main: MINIX main program</p>
      <p> 0857 *     unexpected_int:      called when an interrupt to an unused vector &lt; 16 occurs</p>
      <p> 0858 *     trap: called when an unexpected trap to a vector &gt;= 16 occurs</p>
      <p> 0859 *     panic: abort MINIX due to a fatal error</p>
      <p> 0860 */ 0861</p>
      <p> 0862 //include "../h/const.h"</p>
      <p> 0863 (^include ". ./h/type.h"</p>
      <p> 0864 //include ". ./h/callnr.h"</p>
      <p> 0865 ^include "../h/com.h"</p>
      <p> 0866 //include "../h/error.h"</p>
      <p> 0867 //include "const,h"</p>
      <p> 0868 //include "type.h"</p>
      <p> 0869 //include "glo.h"</p>
      <p> 0870 ^include "proc.h" 0871</p>
      <p> 0872 //define SAFETY 8      /* margin of safety for stack overflow (ints)*/</p>
      <p> 0873 ^define VERY_BIG 39328      /* must be bigger than kernel size (clicks) */</p>
      <p> 0874 ^define BASE 1536      /* address where MINIX starts in memory */</p>
      <p> 0875 #define SIZES 8      /* sizes array has 8 entries */ 0876</p>
      <p> 0877 /*-==============================================r=============r===========:=#</p>
      <p> 0878 * main *</p>
      <p> 0879 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = = = =  I  = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = = */</p>
      <p> 0880 PUBLIC mainO</p>
      <p> 0881 {</p>
      <p> 0882 /* Start the ball rolling. */ 0883</p>
      <p> 0884 register struct proc *rp;</p>
      <p> 0885 register int t;</p>
      <p> 0886 vir_clicks size;</p>
      <p> 0887 phys_clicks base_click, mm_base, previous_base;</p>
      <p> 0888 phys_bytes phys_b;</p>
      <p> 0889 extern unsigned sizes[8]j        /* table filled in by build */</p>
      <p> 0890 extern int color, vec_table[], get_chrome(), (*task[])();</p>
      <p> 0891 extern int s_call(), disk_int(), tty_int(), clock_int(), disk_int();</p>
      <p> 0892 extern int lpr_int(), surpriseO, trp();</p>
      <p> 0893 extern phys_bytes umapO; 0894</p>
      <p> 0895 /# Set up proc table entry for user processes.    Be very careful about</p>
      <p> 0896 * sp, since the 3 words prior to it will be clobbered when the kernel pushes</p>
      <p> 0897 * pc, cs, and psw onto the USER'S stack when starting the user the first</p>
      <p> 0898 * time.    This means that with initial sp = 0x10, user programs must leave</p>
      <p> 0899 * the words at OxOOOA, OxOOOC, and OxOOOE free.</p>
      <p> 0900 #/ 0901</p>
      <p> 0902 lock(); /#  W e can't handle interrupts yet */</p>
      <p> 0903 base_click = BASE » CLICK_SHIFT;</p>
      <p> 0904 size = sizes[0] + sizes[l];     /* kernel text + data size in clicks */</p>
      <p> 0905 mm_base = base_click + size;    /* place where MM starts (in clicks) #/ 0906</p>
      <p> 0907 for (rp = &amp;proc[0]; rp &lt;= &amp;proc[NR_TASKS+L0W_USER]; rp++) {</p>
      <p> 0908 for (t=0; t&lt; NR_REGS; t++) rp-&gt;p_reg[t]  =  0100*t; /* DEBUG */</p>
      <p> 0909 t = rp - proc - NR.TASKS; /* task number */</p>
      <p> 0910 rp-&gt;p_sp = (rp &lt; &amp;proc[NR_TASKS] ? t_stack[NR_TASKS+t+l].stk : INIT_SP)</p>
      <p> 0911 rp-&gt;p_splirait = rp-&gt;p_sp;</p>
      <p> 0912 if (rp-&gt;p_splimit !z INIT_SP)</p>
      <p> 0913 rp-&gt;p_splimit -= (TASK_STACKJBYTES - SAFETY)/sizeof(int);</p>
      <p> 0914 rp-&gt;p_pcpsw.pc = taskft + NR_TASKS];</p>
      <p> 0915 if (rp-&gt;p_pcpsw.pc != 0 || t &gt;= 0) ready(rp);</p>
      <p> 0916 rp-&gt;p_pcpsw.psw = INIT_PSW;</p>
      <p> 0917 rp-&gt;p_flags = 0; 0918</p>
      <p> 0919 /* Set up memory map for tasks and MM, FS, INIT. */</p>
      <p> 0920 if (t &lt; 0) {</p>
      <p> 0921 /♦ 1/0 tasks. */</p>
      <p> 0922 rp-&gt;p_map[T].mem_len   = VERY_BIG;</p>
      <p> 0923 rp-&gt;p_map[T].mem_phys = base_click;</p>
      <p> 0924 rp-&gt;p_map[D].mem_len   = VERY_BIG;</p>
      <p> 0925 rp-&gt;p_map[D].mem_phys = base_click + sizes[0];</p>
      <p> 0926 rp-&gt;p_map[S].mem_len   = VERY_BIG;</p>
      <p> 0927 rp-&gt;p_map[S],mem_phys = base_click + sizes[0] + sizes[l];</p>
      <p> 0928 rp-&gt;p_map[S],mem_vir = sizesfO] + sizes[l];</p>
      <p> 0929 } else {</p>
      <p> 0930 /» MM, FS, and INIT. */</p>
      <p> 0931 previous_base = proc[NR_TASKS + t - 1].p_map[S].mera_phys;</p>
      <p> 0932 rp-&gt;p_map[T].mem_len   = sizes[2*t + 2];</p>
      <p> 0933 rp-&gt;p_map[T].mem_phys = (t == 0 ? mm_base : previous_base);</p>
      <p> 0934 rp-&gt;p_map[D].mem_len   = sizes[2*t +3];</p>
      <p> 0935 rp-&gt;p_map[D].menuphys = rp-&gt;p_map[T].menuphys + sizes[2*t +2];</p>
      <p> 0936 rp-&gt;p_map[S].mem_vir   = sizes[2*t + 3];</p>
      <p> 0937 rp-&gt;p_map[S].menuphys = rp-&gt;p_.map[D].menuphys + sizes[2#t + 3];</p>
      <p> 0938 } 0939</p>
      <p> 0940 d/ifdef i8088</p>
      <p> 0941 rp-&gt;p_reg[CS_REG] = rp-&gt;p_map[T].mem_phys;</p>
      <p> 0942 rp-&gt;p_reg[DS_REG] = rp-&gt;p_map[D].menuphys;</p>
      <p> 0943 rp-&gt;p_reg[SS_REG] = rp-&gt;p_map[D].menuphys;</p>
      <p> 0944 rp-&gt;p_reg[ES_REG] = rp-&gt;p_map[D].menuphys;</p>
      <p> 0945 tfendif</p>
      <p> 0946 } 0947</p>
      <p> 0948 proc[NR_TASKS+(HARDWARE)].p_sp = (int *) k_stack;</p>
      <p> 0949 proc[NR_TASKS+(HARDWARE)].p_sp += K_STACK_BYTES/2;</p>
      <p> I</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/main.c</p>
      <p> 453</p>
      <p> 0950 proc[NR_TASKS+(HARDWARE)].p_splimit = (int *) k_stack;</p>
      <p> 0951 proc[NR_TASKS+(HARDWARE)].p_splimit += SAFETY/2; 0952</p>
      <p> 0953 for (rp = proc_addr(LOWJJSER+l); rp &lt; proc_addr(NR_PROCS); rp++)</p>
      <p> 0954 rp-&gt;p_flags = P_SL0T_FREE; 0955</p>
      <p> 0956 /* Determine if display is color or monochrome. */</p>
      <p> 0957 color = get_chrome(); /* 0 = mono, 1 = color */ 0958</p>
      <p> 0959 /* Save the old interrupt vectors. #/</p>
      <p> 0960 phys_b = umap(proc_addr(HARDWARE), D, (vir_bytes) vec_table, VECT0R_BYTES);</p>
      <p> 0961 phys_copy(0L, phys_b, (long) VECT0R_BYTES);     /* save all the vectors */ 0962</p>
      <p> 0963 /* Set up the new interrupt vectors. */</p>
      <p> 0964 for (t = 0; t &lt; 16; t++) set_vec(t, surprise, base_click);</p>
      <p> 0965 for (t = 16; t &lt; 256; t++) set_vec(t, trp, base_click);</p>
      <p> 0966 set_vec(SYS_VECT0R, s_call, base_click);</p>
      <p> 0967 set_vec(CL0CK_VECT0R, clock_int, base_click);</p>
      <p> 0968 set_vec(KEYBOARD_VECT0R, tty_int, base_click);</p>
      <p> 0969 set_vec(FL0PPY_VECT0R, disk_int, base_click);</p>
      <p> 0970 set_vec(PRINTER_VECT0R, lpr.int, base.click); 0971</p>
      <p> 0972 /* Put a ptr to proc table in a known place so it can be found in /dev/mem */</p>
      <p> 0973 set_vec( (BASE - 4)/4, proc, (phys_clicks) 0); 0974</p>
      <p> 0975 bill_ptr = proc_addr(HARDWARE); /* it has to point somewhere #/</p>
      <p> 0976 pick_proc(); 0977</p>
      <p> 0978 /# Now go to the assembly code to start running the current process. */</p>
      <p> 0979 port_out(INT_CTLMASK, 0);        /* do not mask out any interrupts in 8259A */</p>
      <p> 0980 restartO;</p>
      <p> 0981 }</p>
      <p> 0984 /*===========================================================================*</p>
      <p> 0985 * unexpected_int *</p>
      <p> 0986 »=::==::::=:==:::==:::=::::::::::==:::::===:::::=:====:::==::===:::==:===:==»/</p>
      <p> 0987 PUBLIC unexpected_int()</p>
      <p> 0988 {</p>
      <p> 0989 /* A trap or interrupt has occurred that was not expected. */</p>
      <p> 0990 panic("Unexpected trap or interrupt.   cur_proc =", cur_proc);</p>
      <p> 0991 }</p>
      <p> 0994 /*::: = :: == :::=: = ::::: = = ::::: : :::::::::=::::::::: = =::::: = = :==: = ::::::=::=::" = *</p>
      <p> 0995 * trap *</p>
      <p> 0996 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = =: = = = =*/</p>
      <p> 0997 PUBLIC trapO</p>
      <p> 0998 {</p>
      <p> 0999      /* A trap (vector &gt;= 16) has occurred.    It was not expected. */</p>
      <p> 454 File: kernel/main.c MINIX SOURCE CODE</p>
      <p> 1000</p>
      <p> 1001 printf("\nUnexpected trap. ");</p>
      <p> 1002 printf("This may be due to accidentally including in your programW);</p>
      <p> 1003 printf("a non-MINIX library routine that is trying to make a system callAn")</p>
      <p> 1004 printf("pc =  0x%x       size of program = Ox?ix\n",proc_ptr-&gt;p_pcpsw.pc,</p>
      <p> 1005 proc_ptr-&gt;p_map[D].mem_len&lt;&lt;4);</p>
      <p> 1006 }</p>
      <p> 1009 /* = = = = z: = = r = = = = = = = = = r = = = = = = r-  =   =   =  =  =  =  =  = =  =   : :  =  = = = = : z  =   =  = = r = = = = = = = = =: = = = = = = = = = = = = =: = = = *</p>
      <p> 1010 * panic *</p>
      <p> 1011 * : : = = : : == : :: ::::: := :: :: : :::= :: r :::::  = =  ::: :: = = : : :== : :: : : =  : : ::::  = = : ::: :: =;: : = ::,/</p>
      <p> 1012 PUBLIC panic(s.n)</p>
      <p> 1013 char *s;</p>
      <p> 1014 int n;</p>
      <p> 1015 {</p>
      <p> 1016 /* The system has run aground of a fatal error.    Terminate execution.</p>
      <p> 1017 * If the panic originated in MM or FS, the string will be empty and the</p>
      <p> 1018 * file system already syncked.   If the panic originates in the kernel, we are</p>
      <p> 1019 * kind of stuck.</p>
      <p> 1020 */ 1021</p>
      <p> 1022 if (*s != 0) {</p>
      <p> 1023 printf("\nKernel panic: «s",s);</p>
      <p> 1024 if (n != N0_NUM) printf(" Xd", n);</p>
      <p> 1025 printfC'V);</p>
      <p> 1026 }</p>
      <p> 1027 printf("\nType space to reboot\n");</p>
      <p> 1028 wrebootO; 1029</p>
      <p> 1030 }</p>
      <p> 1032 tfifdef i8088</p>
      <p> 1033 /*====================:==r=======r=======r=====r:============================#</p>
      <p> 1034 * set_vec *</p>
      <p> 1035 *z=r=================..z=:==================z======r==== == r:=======z===== =r=#/</p>
      <p> 1036 PRIVATE set_vec(vec_nr, addr, base_click)</p>
      <p> 1037 int vec_nr; /# which vectoir */</p>
      <p> 1038 int (*addr)(); /* where to start  */</p>
      <p> 1039 phys_clicks base_click; /* click where kernel sits in memory ♦/</p>
      <p> 1040 {</p>
      <p> 1041  /*  Set up an interrupt vector. */ 1042</p>
      <p> 1043 unsigned vec[2];</p>
      <p> 1044 unsigned u;</p>
      <p> 1045 phys_bytes phys_b;</p>
      <p> 1046 extern unsigned sizes[8]; 1047</p>
      <p> 1048 /* Build the vector in the array 'vec'. */</p>
      <p> 1049 vec[0] = (unsigned) addr;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/main.c</p>
      <p> 455</p>
      <p> 1050 vec[l] = (unsigned) base_clickj</p>
      <p> 1051 u = (unsigned) vec; 1052</p>
      <p> 1053 /* Copy the vector into place. »/</p>
      <p> 1054 phys_b = ( (phys_bytes) base_click + (phys_bytes) sizes[0]) « CLICK_SHIFT;</p>
      <p> 1055 phys_b += u;</p>
      <p> 1056 phys_copy(phys_b, (phys_bytes) 4*vec_nr, (phys_bytes) 4);</p>
      <p> 1057 }</p>
      <p> 1058 flendif</p>
      <p> File: kernel/mpx88.s</p>
      <p> MINIX SOURCE CODE</p>
      <p> 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149</p>
      <p> This file is part of the lowest layer of the MINIX kernel.   All processing switching and message handling is done here and in file "proc.c".   This file is entered on every transition to the kernel, both for sending/receiving messages and for all interrupts.   In all cases, the trap or interrupt routine first calls saveO to store the machine state in the proc table. Then the stack is switched to k_stack.    Finally, the real trap or interrupt handler (in C) is called.   When it returns, the interrupt routine jumps to restart, to run the process or task whose number is in 'cur_proc'.</p>
      <p> The external entry points into this file are:</p>
      <p> s_call: process or task wants to send or receive a message</p>
      <p> tty_int: interrupt routine for each key depression and release</p>
      <p> lpr_int: interrupt routine for each line printer interrupt</p>
      <p> disk_int: disk interrupt routine</p>
      <p> clock_int: clock interrupt routine (HZ times per second)</p>
      <p> surprise: all other interrupts &lt; 16 are vectored here</p>
      <p> trp: all traps with vector &gt;= 16 are vectored here</p>
      <p> restart: start running a task or process</p>
      <p> ^include "const.h" ^include "../h/const.h" ^include "../h/cora.h"</p>
      <p> The following procedures are defined in this file and called from outside it. globl _tty_int, _lpr_int, _clock_int, _disk_int globl _s_call, _surprise, _trp, ..restart</p>
      <p> The following external procedures are called in this file, globl _main, _sys_call, _interrupt, _keyboard, _panic, _unexpected_int, _trap globl _pr_char</p>
      <p> Variables and data structures, globl _cur_proc, _proc_ptr, _scan_code, globl _sizes</p>
      <p> _int_mess, _k_stack, splimit</p>
      <p> The following constants are offsets into the proc table.</p>
      <p> MINIX SOURCE CODE File: kernel/mpx88.s</p>
      <p> 457</p>
      <p> 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 U85 U86 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199</p>
      <p> MINIX</p>
      <p> MINIX:</p>
      <p> M.0:</p>
      <p> M.l:</p>
      <p> jmp M.0 .word 0,0 cli</p>
      <p> mov ax,cs</p>
      <p> mov ds,ax</p>
      <p> mov ax,4</p>
      <p> mov ds,ax</p>
      <p> mov ss,ax</p>
      <p> mov _scan_code,bx</p>
      <p> mov sp,#_k_stack</p>
      <p> add sp,#K_STACK_BYTES</p>
      <p> call _main jmp M.l</p>
      <p> _s_call:</p>
      <p> call save mov bp,_proc_ptr push 2(bp) push (bp) push _cur_proc push 4(bp) call _sys_call jmp -restart</p>
      <p> _tty_int:</p>
      <p> call save call -keyboard jmp -restart</p>
      <p> _lpr_int:</p>
      <p> call save call _pr_char jmp -restart</p>
      <p> this is the entry point for the MINIX kernel</p>
      <p> skip over the next few bytes</p>
      <p> build puts DS at kernel text address 4</p>
      <p> disable interrupts</p>
      <p> set up segment registers</p>
      <p> set up ds</p>
      <p> build has loaded this word with ds value ds now contains proper value ss now contains proper value save scan code for '=' key from bootstrap set sp to point to the top of the kernel stack</p>
      <p> start the main program of MINIX this should never be executed</p>
      <p> s_call</p>
      <p> System calls are vectored here.</p>
      <p> save the machine state</p>
      <p> use bp to access sys call parameters</p>
      <p> push(pointer to user message) (was bx)</p>
      <p> push(src/dest) (was ax)</p>
      <p> push caller</p>
      <p> push(SEND/RECEIVE/BOTH) (was cx) sys_call(function, caller, src_dest, m_ptr) jump to code to restart proc/task running</p>
      <p> tty_int</p>
      <p> Interrupt routine for terminal input, save the machine state process a keyboard interrupt continue execution</p>
      <p> lpr_int</p>
      <p> Interrupt routine for terminal input, save the machine state process a line printer interrupt continue execution</p>
      <p> File: kernel/mpx88.s</p>
      <p> MINIX SOURCE CODE</p>
      <p> 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249</p>
      <p> * disk_int</p>
      <p> _disk_int:</p>
      <p> call save</p>
      <p> mov _int_mess+2,*0ISKINT mov ax,#_int_mess push ax</p>
      <p> mov ax,*FL0PPY push ax</p>
      <p> call _interrupt jmp _restart</p>
      <p> Interrupt routine for the floppy disk, save the machine state build message for disk task prepare to call interrupt(FL0PPY, iintmess) push second parameter prepare to push first parameter push first parameter this is the call continue execution</p>
      <p> clock_int</p>
      <p> _clock_int:</p>
      <p> call save</p>
      <p> Interrupt routine for the clock, save the machine state</p>
      <p> mov _int_mess+2,*CL0CK_TICK</p>
      <p> mov ax,#_int_mess push ax mov ax,*CL0CK push ax</p>
      <p> call -interrupt jmp _restart</p>
      <p> build message for clock task</p>
      <p> *</p>
      <p> .surprise:</p>
      <p> call save</p>
      <p> call _unexpected_int jmp -restart</p>
      <p> prepare to call interrupt(CL0CK, iintmess)</p>
      <p> push second parameter</p>
      <p> prepare to push first parameter</p>
      <p> push first parameter</p>
      <p> this is the call</p>
      <p> continue execution</p>
      <p> surprise *</p>
      <p> This is where unexpected interrupts come, save the machine state go panic never executed</p>
      <p> trp</p>
      <p> * = = :</p>
      <p> trp;</p>
      <p> call save call -trap jmp -restart</p>
      <p> This is where unexpected traps come.</p>
      <p> save the machine state</p>
      <p> print a message</p>
      <p> this error is not fatal</p>
      <p> save the machine state in the proc table.</p>
      <p> MINIX SOURCE CODE File: kernel/mpx88.s 459</p>
      <p> File: kernel/mpx88.s</p>
      <p> MINIX SOURCE CODE</p>
      <p> 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339</p>
      <p> mov bx,sp</p>
      <p> mov bp,SPLIM-ROFF(bx)</p>
      <p> mov splimit.bp</p>
      <p> mov bp,dsreg-R0FF(bx)</p>
      <p> mov lds_low+2,bp</p>
      <p> pop bp</p>
      <p> pop es</p>
      <p> mov sp,5P-R0FF(bx) mov ss.ssreg-ROFF(bx) push PSW-ROFF(bx) push csreg-ROFF(bx) push PC-ROFF(bx) Ids bx,lds_low iret</p>
      <p> bx points to saved bp register splimit = p_splimit ditto bp = ds</p>
      <p> lds_low+2 contains ds restore bp restore es restore sp</p>
      <p> restore ss using the value of ds push psw push cs push pc</p>
      <p> restore ds and bx in one fell swoop return to user or task</p>
      <p> idle</p>
      <p> idle: L3:</p>
      <p> sti wait jmp L3</p>
      <p> executed when there is no work enable interrupts</p>
      <p> just idle while waiting for interrupt loop until interrupt</p>
      <p> data</p>
      <p> . data _sizes:</p>
      <p> bx_save: ds_save:</p>
      <p> .word 0x526F .zerow 7 .word 0 .word 0</p>
      <p> ret_save:.word 0 lds_low: .word 0,0 ttyomess: .asciz "RS232 interrupt"</p>
      <p> . bss begbss:</p>
      <p> this must be the first data entry (magic #)</p>
      <p> build table uses prev word and this space</p>
      <p> storage for bx</p>
      <p> storage for ds</p>
      <p> storage for return address</p>
      <p> storage used for restoring bx</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/klib88.s</p>
      <p> 461</p>
      <p> File: kernel/klib88.s</p>
      <p> MINIX SOURCE CODE</p>
      <p> 1400</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/klib88.s</p>
      <p> 463</p>
      <p> 464 File: kernel/klib88.s MINIX SOURCE CODE</p>
      <p> MINIX SOURCE CODE File: kemel/klib88.s</p>
      <p> 465</p>
      <p> 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599</p>
      <p> push ax push dx mov dx,4(bx) in</p>
      <p> xorb ah,ah mov bx,6(bx) mov (bx),ax pop dx pop ax pop bx ret</p>
      <p> save ax save dx dx = port input 1 byte clear ah</p>
      <p> fetch address where byte is to go return byte to caller in param restore dx restore ax restore bx return to caller</p>
      <p> lock</p>
      <p> Disable CPU interrupts, lock:</p>
      <p> pushf cli</p>
      <p> pop lockvar ret</p>
      <p> save flags on stack disable interrupts</p>
      <p> save flags for possible restoration later return to caller</p>
      <p> unlock</p>
      <p> Enable CPU interrupts, unlock:</p>
      <p> sti ret</p>
      <p> enable interrupts return to caller</p>
      <p> restore</p>
      <p> Restore enable/disable bit to the value it had before last lock, restore:</p>
      <p> push lockvar</p>
      <p> popf</p>
      <p> ret</p>
      <p> push flags as they were before previous lock restore flags return to caller</p>
      <p> build_sig</p>
      <p> * Build a structure that is pushed onto the stack for signals.    It contains</p>
      <p> * pc, psw, etc., and is machine dependent. The format is the same as generated</p>
      <p> * by hardware interrupts, except that after the "interrupt", the signal number</p>
      <p> * is also pushed.    The signal processing routine within the user space first</p>
      <p> File: kernel/klib88.s</p>
      <p> MINIX SOURCE CODE</p>
      <p> 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649</p>
      <p> * pops the signal number, to see which function to call.    Then it calls the</p>
      <p> * function.   Finally, when the function returns to the low-level signal</p>
      <p> * handling routine, control is passed back to where it was prior to the signal</p>
      <p> * by executing a return-from-interrupt instruction, hence the need for using</p>
      <p> * the hardware generated interrupt format on the stack.   The call is:</p>
      <p> * build_sig(sig_stuff, rp, sig)</p>
      <p> | Offsets within proc table PC      = 24 csreg = 18 PSW     = 28</p>
      <p> _build_sig: push mov push push mov mov mov mov mov mov mov mov mov mov pop pop pop ret</p>
      <p> bp bp.sp bx si</p>
      <p> bx,4(bp) si,6(bp) ax,8(bp) (bx),ax ax,PC(si) 2(bx),ax ax,csreg(si) 4(bx) ,ax ax,PSW(si) 6(bx),ax si bx bp</p>
      <p> save bp</p>
      <p> set bp to sp for accessing params save bx save si</p>
      <p> bx points to sig_stuff</p>
      <p> si points to proc table entry</p>
      <p> ax = signal number</p>
      <p> put signal number in sig_stuff</p>
      <p> ax = signalled process' PC</p>
      <p> put pc in sig_stuff</p>
      <p> ax = signalled process' cs</p>
      <p> put cs in sig_stuff</p>
      <p> ax = signalled process' PSW</p>
      <p> put psw in sig_stuff</p>
      <p> restore si</p>
      <p> restore bx</p>
      <p> restore bp</p>
      <p> return to caller</p>
      <p> csv &amp; cret</p>
      <p> This version of csv replaces the standard one.    It checks for stack overflow within the kernel in a simpler way than is usually done, cret is standard, csv:</p>
      <p> pop bx push bp mov bp,sp push di push si sub sp,ax cmp sp.splimit jbe csv.l jmp (bx)</p>
      <p> bx = return address stack old frame pointer set new frame pointer to sp save di save si</p>
      <p> ax = # bytes of local variables has kernel stack grown too large if sp is too low, panic</p>
      <p> normal return: copy bx to program counter</p>
      <p> csv.1:</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/klib88.s</p>
      <p> 467</p>
      <p> 1700</p>
      <p> 1701 _vid_copy:</p>
      <p> 1702 push bp</p>
      <p> 1703 mov bp,sp</p>
      <p> 1704 push si</p>
      <p> 1705 push di</p>
      <p> 1706 push cx</p>
      <p> 1707 push dx</p>
      <p> 1708 push es</p>
      <p> 1709 mov si,4(bp)</p>
      <p> 1710 mov di,8(bp)</p>
      <p> 1711 mov cx,10(bp)</p>
      <p> 1712 mov dx,#0x3DA 1713</p>
      <p> 1714 test _color,*l</p>
      <p> 1715 jz vid.3 1716</p>
      <p> 1717 vid.l: in</p>
      <p> 1718 test al,*010</p>
      <p> 1719 jnz vid.l</p>
      <p> 1720 vid.2: in</p>
      <p> 1721 testb al,*010</p>
      <p> 1722 jz vid.2 1723</p>
      <p> 1724 vid.3: pushf</p>
      <p> 1725 cli</p>
      <p> 1726 mov es,6(bp) 1727</p>
      <p> 1728 cmp  si JO</p>
      <p> 1729 je vid.5</p>
      <p> 1730 lock</p>
      <p> 1731 nop</p>
      <p> 1732 rep</p>
      <p> 1733 movw 1734</p>
      <p> 1735 vid.4: popf</p>
      <p> 1736 pop es</p>
      <p> 1737 pop dx</p>
      <p> 1738 pop cx</p>
      <p> 1739 pop di</p>
      <p> 1740 pop si</p>
      <p> 1741 pop bp</p>
      <p> 1742 ret 1743</p>
      <p> 1744 vid.5:   mov ax,#BLANK</p>
      <p> 1745 rep</p>
      <p> 1746 stow</p>
      <p> 1747 jmp vid.4 1748</p>
      <p> 1749</p>
      <p> File: kernel/klib88.s MINIX SOURCE CODE</p>
      <p> we need bp to access the parameters</p>
      <p> set bp to sp for indexing</p>
      <p> save the registers</p>
      <p> save di</p>
      <p> save cx</p>
      <p> save dx</p>
      <p> save es</p>
      <p> si = pointer to data to be copied</p>
      <p> di = offset within video ram</p>
      <p> cx = word count for copy loop</p>
      <p> prepare to see if color display is retracing</p>
      <p> skip vertical retrace test if display is monc if monochrome then go to vid.2</p>
      <p> with a color display, you can only copy to the video ram during vertical retrace, so wait for start of retrace period.   Bit 3 of 0x3DA is set during retrace.    First wait until it is off (no retrace), then wait until it comes on (start of retrace)</p>
      <p> copying may now start; save flags interrupts just get in the way: disable them load es now: int routines may ruin it</p>
      <p> si = 0 means blank the screen jump for blanking</p>
      <p> this is a trick for the IBM PC simulator onl; 'lock' indicates a video ram access this is the copy loop ditto</p>
      <p> restore flags restore registers restore dx restore cx restore di restore si restore bp return to caller</p>
      <p> ax = blanking character copy loop blank screen done</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/klib88.s</p>
      <p> 469</p>
      <p> 470 File: kernel/klib88.s MINIX SOURCE CODE</p>
      <p> 1800 xor di.di</p>
      <p> 1801 mov es,di</p>
      <p> 1802 rep</p>
      <p> 1803 movw</p>
      <p> 1804 ret 1805</p>
      <p> 1806 .data</p>
      <p> 1807 lockvar: .word 0 place to store flags for lock()/restore()</p>
      <p> 1808 splimit: .word 0 stack limit for current task (kernel only)</p>
      <p> 1809 stkoverrun:        .asciz "Kernel stack overrun, task = "</p>
      <p> 1810 _vec_table: .zerow 130 | storage for interrupt vectors</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/proc.c</p>
      <p> 471</p>
      <p> 1850 /* This file contains essentially all of the process and message handling.</p>
      <p> 1851 * It has two main entry points from the outside:</p>
      <p> 1852 *</p>
      <p> 1853 *     sys_call:     called when a process or task does SEND, RECEIVE or 5ENDREC</p>
      <p> 1854 *     interrupt: called by interrupt routines to send a message to task</p>
      <p> 1855 *</p>
      <p> 1856 # It also has five minor entry points:</p>
      <p> 1857 *</p>
      <p> 1858 #    ready: put a process on one of the ready queues so it can be run</p>
      <p> 1859 *    unready:     remove a process from the ready queues</p>
      <p> 1860 *     sched: a process has run too long; schedule another one</p>
      <p> 1861 *    mini_send: send a message (used by interrupt signals, etc.)</p>
      <p> 1862 *     pick_proc: pick a process to run (used by system initialization)</p>
      <p> 1863 */ 1864</p>
      <p> 1865 ^include "../h/const.h"</p>
      <p> 1866 ^include "../h/type.h"</p>
      <p> 1867 ^include "../h/callnr.h"</p>
      <p> 1868 ^include "../h/com.h"</p>
      <p> 1869 ^include "../h/error.h"</p>
      <p> 1870 ^include "const.h"</p>
      <p> 1871 ^include "type.h"</p>
      <p> 1872 ^include "glo.h"</p>
      <p> 1873 ^include "proc.h" 1874</p>
      <p> 1875 /* = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = :r = = = = = = = = = = = : = = = = = = = = =: = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =  -  =   =   =  *</p>
      <p> 1876 * interrupt *</p>
      <p> 1877 * = = = = = = = = = = = = = = = = = = = = = = = r = : = = = = = = = = = = = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   ::   =   =   =   =   =   =  -  =   =   =  -*/</p>
      <p> 1878 PUBLIC interruptUask, m_ptr)</p>
      <p> 1879 int task; /♦ number of task to be started */</p>
      <p> 1880 message *m_ptr; /* interrupt message to send to the task */</p>
      <p> 1881 {</p>
      <p> 1882 /* An interrupt has occurred.   Schedule the task that handles it. */ 1883</p>
      <p> 1884 int i, n, old_map, this_bit; 1885</p>
      <p> 1886 tfifdef i8088</p>
      <p> 1887 /* Re-enable the 8259A interrupt controller. */</p>
      <p> 1888 port_out(INT_CTL, ENABLE);       /* this re-enables the 8259A controller chip */</p>
      <p> 1889 #endif 1890</p>
      <p> 1891 /* Try to send the interrupt message to the indicated task. */</p>
      <p> 1892 this_bit = 1 « (-task);</p>
      <p> 1893 if (mini_send(HARDWARE, task, m_ptr) != OK) {</p>
      <p> 1894 /* The message could not be sent to the task; it was not waiting. */</p>
      <p> 1 895  old_map = busy_map; /* save original map of busy tasks */</p>
      <p> 1896 if (task == CLOCK) {</p>
      <p> 1897 lost_ticks++;</p>
      <p> 1898 } else {</p>
      <p> 472 File: kernel/proc.c MINIX SOURCE CODE</p>
      <p> 1900 task_mess[-task] = m_ptr; /* record message pointer */</p>
      <p> 1901 }</p>
      <p> 1902 } else {</p>
      <p> 1903 /* Hardware interrupt was successfully sent as a message. */</p>
      <p> 1904 busy_map &amp;= ~this_bit;   /* turn off the bit in case it was on #/</p>
      <p> 1905 old_map = busy_map;</p>
      <p> 1906 } 1907</p>
      <p> 1908 /* See if any tasks that were previously busy are now listening for msgs. */</p>
      <p> 1909 if (old_map != 0) {</p>
      <p> 1910 for (i = 2; i &lt;= NR_TASKS; i++) {</p>
      <p> 1911 /* Check each task looking for one with a pending interrupt. *</p>
      <p> 1912 if ( (old_map»i) &amp; 1) {</p>
      <p> 1913 /* Task 'i' has a pending interrupt. */</p>
      <p> 1914 n = mini_send(HARDWARE, -i, task._mess[i]);</p>
      <p> 1915 if (n — OK) busy_map &amp;= "(1 &lt;&lt; i);</p>
      <p> 1916 }</p>
      <p> 1917 }</p>
      <p> 1918 } 1919</p>
      <p> 1920 /* If a task has just been readied and a user is running, run the task. */</p>
      <p> 1921 if (rdy_head[TASK_Q]  != NIL_PR0C &amp;&amp; (cur_proc &gt;= 0 || cur_proc == IDLE))</p>
      <p> 1922 pick_proc();</p>
      <p> 1923 }</p>
      <p> 1926 /* = = = = = = = = = = = = = = = = = = :: = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = =:=: = ♦</p>
      <p> 1927 * sys_call *</p>
      <p> 1928 * = = = = = = = = = = = = = = = =   = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 1929 PUBLIC sys_call(function, caller, src_dest, m._ptr)</p>
      <p> 1930 int function; /* SEND, RECEIVE, or BOTH */</p>
      <p> 1931 int caller; /* who is making this call */</p>
      <p> 1932 int src_dest; /* source to receive from or dest to send to *</p>
      <p> 1933 message *m_ptr; /* pointer to message */</p>
      <p> 1934 {</p>
      <p> 1935 /* The only system calls that exist in MINIX are sending and receiving</p>
      <p> 1936 * messages.    These are done by trapping to the kernel with an INT instruction</p>
      <p> 1937 * The trap is caught and sys_call() is called to send or receive a message (o</p>
      <p> 1938 * both).</p>
      <p> 1939 */ 1940</p>
      <p> 1941 register struct proc *rp;</p>
      <p> 1942 int n; 1943</p>
      <p> 1944 /* Check for bad system call parameters. */</p>
      <p> 1945 rp = proc_addr(caller);</p>
      <p> 1946 if (src_dest &lt; -NR_TASKS ||  (src_dest &gt;= NR..PR0CS &amp;&amp; srcdest != ANY) ) {</p>
      <p> 1947 rp-&gt;p_reg[RET_REG] = E_BAD_SRC;</p>
      <p> 1948 return;</p>
      <p> MINIX SOURCE CODE File: kernel/proc.c 473</p>
      <p> 1950 if (function != BOTH &amp;&amp; caller  &gt;-  L0W_USER) {</p>
      <p> 1951 rp-&gt;p_reg[RET_REG] = E_N0_PERM; /* users only do BOTH */</p>
      <p> 1952 return;</p>
      <p> 1953 } 1954</p>
      <p> 1955  /*  The parameters are ok. Do the call. */</p>
      <p> 1956 if (function &amp; SEND) {</p>
      <p> 1957 n = mini_send(caller, src_dest, nuptr); /* func = SEND or BOTH »/</p>
      <p> 1958 if (function == SEND || n != OK) rp-&gt;p_reg[RET_REG] = n;</p>
      <p> 1959 if (n != OK) return;       /* SEND failed */</p>
      <p> 1960 } 1961</p>
      <p> 1962 if (function &amp; RECEIVE) {</p>
      <p> 1963 n = mini_rec(caller, src_dest, m_ptr); /* func = RECEIVE or BOTH */</p>
      <p> 1964 rp-&gt;p_reg[RET_REG] = n;</p>
      <p> 1965 }</p>
      <p> 1966 }</p>
      <p> 1968 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = = = = = : = = = = - = r3rrz: = = - = = = =: = = = = = = = = = = = = =:r = =:»</p>
      <p> 1969 * mini_send #</p>
      <p> 1970 » : : : : :: : :: :::: : :: : : : ::: :: : ::: : :::: : :: :: : ::::::: : :== ;:::::::::::::::=:::::::: ,/</p>
      <p> 1971 PUBLIC int mini_send(caller, dest, m_ptr)</p>
      <p> 1972 int caller; /* who is trying to send a message? */</p>
      <p> 1973 int dest; /* to whom is message being sent? */</p>
      <p> 1974 message *m_ptr; /* pointer to message buffer */</p>
      <p> 1975 {</p>
      <p> 1976 /* Send a message from 'caller' to 'dest'.   If 'dest' is blocked waiting for</p>
      <p> 1977 * this message, copy the message to it and unblock 'dest'.   If 'dest' is not</p>
      <p> 1978 * waiting at all, or is waiting for another source, queue 'caller'.</p>
      <p> 1979 */ 1980</p>
      <p> 1981 register struct proc #caller_ptr, *dest_ptr, *next_ptr;</p>
      <p> 1982 vir_bytes vb; /* message buffer pointer as vir_bytes */</p>
      <p> 1983 vir_clicks vlo, vhi; /* virtual clicks containing message to send */</p>
      <p> 1984 vir_clicks len; /* length of data segment in clicks */ 1985</p>
      <p> 1986 /* User processes are only allowed to send to FS and MM.   Check for this. */</p>
      <p> 1987 if (caller &gt;= L0W_USER &amp;&amp; (dest != FS_PR0C_NR &amp;&amp; dest != MM_PR0C_NR))</p>
      <p> 1988 return(E_BAD_DEST);</p>
      <p> 1989 caller_ptr = proc_addr(caller); /* pointer to source's proc entry */</p>
      <p> 1990 dest_ptr = proc_addr(dest);     /* pointer to destination's proc entry */</p>
      <p> 1991 if (dest_ptr-&gt;p_flags &amp; P_SL0T_FREE) return(E_BAD_DEST); /* dead dest */ 1992</p>
      <p> 1993 /* Check for messages wrapping around top of memory or outside data seg. */</p>
      <p> 1994 len = caller_ptr-&gt;p_map[D].mem_len;</p>
      <p> 1995 vb = (vir_bytes) m_ptr;</p>
      <p> 1996 vlo = vb » CLICK_SHIFT; /* vir click for bottom of message */</p>
      <p> 1997 vhi = (vb + MESS_SIZE - 1) » CLICK_SHIFT;       /* vir click for top of message */</p>
      <p> 1998 if (vhi &lt; vlo || vhi - caller_ptr-&gt;p_map[D].mem_vir &gt;= len)return(E_BAD_ADDR); 1999</p>
      <p> 474 File: kernel/proc.c MINIX SOURCE CODE</p>
      <p> 2000 /* Check to see if 'dest' is blocked waiting for this message. »/</p>
      <p> 2001 if ( (dest_ptr-&gt;p_flags 4 RECEIVING) &amp;&amp;</p>
      <p> 2002 (dest_ptr-&gt;p_getfrom == ANY || dest_ptr-&gt;p_getfrom == caller) )</p>
      <p> 2003 /* Destination is indeed waiting for this message. */</p>
      <p> 2004 cp_mess(caller, caller_ptr-&gt;p_map[D] .miem_phys, m_ptr,</p>
      <p> 2005 dest_ptr-&gt;p_map[D].mem_phys, dest_ptr-&gt;p_messbu</p>
      <p> 2006 dest_ptr-&gt;p_flags &amp;= "RECEIVING; /* deblock destination */</p>
      <p> 2007 if (dest_ptr-&gt;p_flags == 0) ready(dest_ptr);</p>
      <p> 2008 } else {</p>
      <p> 2009 /* Destination is not waiting.    Block and queue caller. */</p>
      <p> 2010 if (caller — HARDWARE) return(E_0VERRUN);</p>
      <p> 2011 caller_ptr-&gt;p_messbuf = m_ptr;</p>
      <p> 2012 caller_ptr-&gt;p_flags |= SENDING;</p>
      <p> 2013 unready(caller_ptr); 2014</p>
      <p> 2015 /* Process is now blocked.    Put in on the destination's queue. */</p>
      <p> 2016 if ( (next_ptr = dest_ptr-&gt;p_callerq)      NIL.PR0C) {</p>
      <p> 2017 dest_ptr-&gt;p_callerq = caller_ptr;</p>
      <p> 2018 } else {</p>
      <p> 2019 while (next_ptr-&gt;p_sendlink != NIL.PR0C)</p>
      <p> 2020 next_ptr = next_ptr-&gt;p_sendlink;</p>
      <p> 2021 next_ptr-&gt;p_sendlink = caller_ptr;</p>
      <p> 2022 }</p>
      <p> 2023 caller_ptr-&gt;p_sendlink = NIL_PR0C;</p>
      <p> 2024 }</p>
      <p> 2025 return(OK);</p>
      <p> 2026 }</p>
      <p> 2029 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  : : = = = = = = = = : = z = = = = = = = = = r=*</p>
      <p> 2030 * mini_rec ♦</p>
      <p> 2031 «:::: = "::::::::==::::::::: = = = "::=== = :::::: = :"=: = : = ::::: = = ::== = = ::=: = = = = =»/</p>
      <p> 2032 PRIVATE int mini_rec(caller, src, m_ptr)</p>
      <p> 2033 int caller; /* process trying to get message */</p>
      <p> 2034 int src; /* which message source is wanted (or ANY) */</p>
      <p> 2035 message *m_ptr; /♦ pointer to message buffer */</p>
      <p> 2036 {</p>
      <p> 2037 /* A process or task wants to get a message.    If one is already queued,</p>
      <p> 2038 * acquire it and deblock the sender.    If no message from the desired source</p>
      <p> 2039 * is available, block the caller.   No need to check parameters for validity.</p>
      <p> 2040 * Users calls are always sendrecO, and mini_send() has checked already.</p>
      <p> 2041 » Calls from the tasks, MM, and FS are trusted.</p>
      <p> 2042 */ 2043</p>
      <p> 2044 register struct proc *caller_ptr, *sender_ptr, *prev_ptr;</p>
      <p> 2045 int sender; 2046</p>
      <p> 2047 caller_ptr = proc_addr(caller); /* pointer to caller's proc structure *</p>
      <p> 2048</p>
      <p> 2049 /* Check to see if a message from desired source is already available. */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/proc.c</p>
      <p> 475</p>
      <p> 2050 sender_ptr = caller_ptr-&gt;p_callerq;</p>
      <p> 2051 while (sender_ptr != NIL_PR0C) {</p>
      <p> 2052 sender = sender_ptr - proc - NFLJASKS;</p>
      <p> 2053 if (src == ANY || src == sender) {</p>
      <p> 2054 /# An acceptable message has been found. */</p>
      <p> 2055 cp_mess(sender, sender_ptr-&gt;p_map[D].mem_phys, sender_ptr-&gt;p_messbuf,</p>
      <p> 2056 caller_ptr-&gt;p_map[D].mem_phys, m_ptr);</p>
      <p> 2057 sender_ptr-&gt;p_flags &amp;= ""SENDING; /* deblock sender */</p>
      <p> 2058 if (sender_ptr-&gt;p_flags == 0) ready(sender_ptr);</p>
      <p> 2059 if (sender_ptr == caller_ptr-&gt;p_callerq)</p>
      <p> 2060 caller_ptr-&gt;p_callerq = sender_ptr-&gt;p_sendlink;</p>
      <p> 2061 else</p>
      <p> 2062 prev_ptr-&gt;p_sendlink = sender_ptr-&gt;p_sendlink;</p>
      <p> 2063 return(OK);</p>
      <p> 2064 }</p>
      <p> 2065 prev_ptr = sender_ptr;</p>
      <p> 2066 sender_ptr = sender_ptr-&gt;p_sendlink;</p>
      <p> 2067 } 2068</p>
      <p> 2069  /*  No suitable message is available.    Block the process trying to receive. #/</p>
      <p> 2070 caller_ptr-&gt;p_getfrom = src;</p>
      <p> 2071 caller_ptr-&gt;p_messbuf = m_ptr;</p>
      <p> 2072 caller_ptr-&gt;p_flags |= RECEIVING;</p>
      <p> 2073 unready(caller_ptr); 2074</p>
      <p> 2075 /* If MM has just blocked and there are kernel signals pending, now is the</p>
      <p> 2076 * time to tell MM about them, since it will be able to accept the message.</p>
      <p> 2077 */</p>
      <p> 2078 if (sig_procs &gt; 0 &amp;&amp; caller == MM_PR0C_NR &amp;&amp; src == ANY) inform(MM_PR0C_NR);</p>
      <p> 2079 return(OK);</p>
      <p> 2080 }</p>
      <p> 2084 #                                                pick_proc * 2085</p>
      <p> 2086 PUBLIC pick_proc()</p>
      <p> 2087 {</p>
      <p> 2088 /* Decide who to run now. */ 2089</p>
      <p> 2090 register int q;                        /* which queue to use */ 2091</p>
      <p> 2092 if (rdy_head[TASK_Q]  != NIL_PR0C) q = TA5K_Q;</p>
      <p> 2093 else if (rdy_head[SERVER_Q]  != NILPROC) q = SERVER_Q;</p>
      <p> 2094 else q = USER_Q; 2095</p>
      <p> 2096 /* Set 'cur_proc' and 'proc_ptr'. If system is idle, set 'cur_proc' to a</p>
      <p> 2097 # special value (IDLE), and set 'proc_ptr' to point to an unused proc table</p>
      <p> 2098 # slot, namely, that of task -1 (HARDWARE), so saveO will have somewhere to</p>
      <p> 2099 * deposit the registers when an interrupt occurs on an idle machine.</p>
      <p> 476 File: kernel/proc.c MINIX SOURCE CODE</p>
      <p> 2100 * Record previous process so that when clock tick happens, the clock task</p>
      <p> 2101 * can find out who was running just before it began to run.    (While the</p>
      <p> 2102 * clock task is running,  'cur_proc' = CLOCKTASK).  In addition, set 'bill_pt</p>
      <p> 2103 * to always point to the process to be billed for CPU time.</p>
      <p> 2104 */</p>
      <p> 2105 prev_proc = cur_proc;</p>
      <p> 2106 if (rdy_head[q]  != NIL_PR0C) {</p>
      <p> 2107 /* Someone is runnable. #/</p>
      <p> 2108 cur_proc = rdy_head[q] - proc - NR_TA5K5;</p>
      <p> 2109 proc_ptr = rdy_head[q];</p>
      <p> 2110 if (cur_proc &gt;= L0W_USER) bill_ptr = proc_ptr;</p>
      <p> 2111 } else {</p>
      <p> 2112 /# No one is runnable. */</p>
      <p> 2113 cur_proc = IDLE;</p>
      <p> 2114 proc_ptr = proc_addr(HARDWARE);</p>
      <p> 2115 bill_ptr = proc_ptr;</p>
      <p> 2116 }</p>
      <p> 2117 }</p>
      <p> 2119 /#===========================================================================*</p>
      <p> 2120 * ready *</p>
      <p> 2121 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = : = = = = = = = = =: = = = = = = = = = *</p>
      <p> 2122 PUBLIC ready(rp)</p>
      <p> 2123 register struct proc *rp; /* this process is now runnable */</p>
      <p> 2124 {</p>
      <p> 2125 /* Add 'rp' to the end of one of the queues of runnable processes. Three</p>
      <p> 2126 * queues are maintained:</p>
      <p> 2127 *     TASK_Q     - (highest priority) for runnable tasks</p>
      <p> 2128 *     SERVER_Q - (middle priority) for MM and FS only</p>
      <p> 2129 *     USER_Q     - (lowest priority) for user processes</p>
      <p> 2130 */ 2131</p>
      <p> 2132 register int q; /* TASK_Q, SERVER_Q, or USER_Q */</p>
      <p> 2133 int r; 2134</p>
      <p> 2135 lockO; /* disable interrupts */</p>
      <p> 2136 r = (rp - proc) - NR_TASKS;     /* task or proc number */</p>
      <p> 2137 q = (r &lt; 0 ? TASK_Q : r &lt; L0W_USER ? SERVER_Q : USER_Q); 2138</p>
      <p> 2139 /* See if the relevant queue is empty. ♦/</p>
      <p> 2140 if (rdy_head[q] == NIL_PR0C)</p>
      <p> 2141 rdy_head[q] = rp; /* add to empty queue */</p>
      <p> 2142 else</p>
      <p> 2143 rdy_tailfq]-&gt;p_nextready = rp;    /* add to tail of nonempty queue */</p>
      <p> 2144 rdy_tail[q] = rp; /* new entry has no successor */</p>
      <p> 2145 rp-&gt;p_nextready = NIL_PR0C;</p>
      <p> 2146 restoreO; /* restore interrupts to previous state */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/proc.c</p>
      <p> 477</p>
      <p> 2150 /* = r = = = = = = = = = = = = r: = = = = = r = : = = r: = -r = = = = = = = r = = = = = = = = = = = = = = = = r = r = = = = = = = = =: = =: = : = = = = *</p>
      <p> 2151 * unready *</p>
      <p> 2152 #====r===r===========r=r====================================================:*/</p>
      <p> 2153 PUBLIC unready(rp)</p>
      <p> 2154 register struct proc *rp; /* this process is no longer runnable */</p>
      <p> 2155 {</p>
      <p> 2156 /* A process has blocked. */</p>
      <p> 2157</p>
      <p> 2158 register struct proc *xp;</p>
      <p> 2159 int r, q; 2160</p>
      <p> 2161 lockO; /* disable interrupts */</p>
      <p> 2162 r = rp - proc - NR_TASKS;</p>
      <p> 2163 q = (r &lt; 0 ? TA5K_Q : r &lt; L0W_USER ? S£RVER_Q : USER_Q);</p>
      <p> 2164 if ( (xp = rdy_head[q]) == NIL_PR0C) return;</p>
      <p> 2165 if (xp =z rp) {</p>
      <p> 2166 /* Remove head of queue */</p>
      <p> 2167 rdy_head[q] = xp-&gt;p_nextready;</p>
      <p> 2168 pick_proc();</p>
      <p> 2169 } else {</p>
      <p> 2170 /* Search body of queue.   A process can be made unready even if it is</p>
      <p> 2171 * not running by being sent a signal that kills it.</p>
      <p> 2172 */</p>
      <p> 2173 while (xp-&gt;p_nextready != rp)</p>
      <p> 2174 if ( (xp = xp-&gt;p_nextready) == NIL_PR0C) return;</p>
      <p> 2175 xp-&gt;p_nextready = xp-&gt;p_nextready-&gt;p_nextready;</p>
      <p> 2176 while (xp-&gt;p_nextready != Nil PROC) xp = xp-&gt;p_nextready;</p>
      <p> 2177 rdy_tail[q] = xp;</p>
      <p> 2178 }</p>
      <p> 2179 restore(); /* restore interrupts to previous state #/</p>
      <p> 2180 }</p>
      <p> 2183 /.:==:::::::::::=:=::====:::::::::::::==;=======:=======:::;=;:=:======::=;==,</p>
      <p> 2184 * sched *</p>
      <p> 2185 *======================r========r======r================== = = = ========== ==== ::*/</p>
      <p> 2186 PUBLIC sched()</p>
      <p> 2187 {</p>
      <p> 2188 /* The current process has run too long.   If another low priority (user)</p>
      <p> 2189 * process is runnable, put the current process on the end of the user queue,</p>
      <p> 2190 # possibly promoting another user to head of the queue.</p>
      <p> 2191 */ 2192</p>
      <p> 2193 lockO;  /*  disable interrupts */</p>
      <p> 2194 if (rdy_head[USER_Q] == NIL_PR0C) {</p>
      <p> 2195 restoreO;  I*  restore interrupts to previous state */</p>
      <p> 2196 return;</p>
      <p> 2197 } 2198</p>
      <p> 2199 /* One or more user processes queued. */</p>
      <p> 478 File: kernel/proc.c MINIX SOURCE CODE</p>
      <p> 2200 rdy_tail[USER_Q]-&gt;p_nextready = rdy_head[U5E:R_Q];</p>
      <p> 2201 rdy_tail[USER_Q] = rdy_head[USER_Q];</p>
      <p> 2202 rdy_head[USER_Q] = rdy_head[USER_Q]-&gt;p_nextready;</p>
      <p> 2203 rdy_tail[USER_Q]-&gt;p_nextready = NIL_PR0C;</p>
      <p> 2204 pick_proc();</p>
      <p> 2205 restoreO; /* restore interrupts to previous state */</p>
      <p> MINIX SOURCE CODE File: kernel/memory.c</p>
      <p> 479</p>
      <p> 2250</p>
      <p> 2251</p>
      <p> 2252</p>
      <p> 2253</p>
      <p> 2254</p>
      <p> 2255</p>
      <p> 2256</p>
      <p> 2257</p>
      <p> 2258</p>
      <p> 2259</p>
      <p> 2260</p>
      <p> 2261</p>
      <p> 2262</p>
      <p> 2263</p>
      <p> 2264</p>
      <p> 2265</p>
      <p> 2266</p>
      <p> 2267</p>
      <p> 2268</p>
      <p> 2269</p>
      <p> 2270</p>
      <p> 2271</p>
      <p> 2272</p>
      <p> 2273</p>
      <p> 2274</p>
      <p> 2275</p>
      <p> 2276</p>
      <p> 2277</p>
      <p> 2278</p>
      <p> 2279</p>
      <p> 2280</p>
      <p> 2281</p>
      <p> 2282</p>
      <p> 2283</p>
      <p> 2284</p>
      <p> 2285</p>
      <p> 2286</p>
      <p> 2287</p>
      <p> 2288</p>
      <p> 2289</p>
      <p> 2290</p>
      <p> 2291</p>
      <p> 2292</p>
      <p> 2293</p>
      <p> 2294</p>
      <p> 2295</p>
      <p> 2296</p>
      <p> 2297</p>
      <p> 2298</p>
      <p> 2299</p>
      <p> /* This file contains the drivers for four special files:</p>
      <p> * /dev/null - null device (data sink)</p>
      <p> * /dev/mem - absolute memory</p>
      <p> * /dev/kmem - kernel virtual memory</p>
      <p> * /dev/ram - RAM disk</p>
      <p> * It accepts three messages, for reading, for writing, and for</p>
      <p> * control. All use message format m2 and with these parameters:</p>
      <p> * The file contains one entry point: *</p>
      <p> * mem_task: main entry when system is brought up */</p>
      <p> #include "../h/const.h" ^include "../h/type.h" ^include "../h/callnr.h" ^include ".,/h/com.h" ^include "../h/error.h" ^include "const.h" ^include "type.h" ^include "proc.h"</p>
      <p> ^define NR_RAM5 PRIVATE message mess;</p>
      <p> /* number of RAM-type devices */</p>
      <p> /* message buffer */ PRIVATE phys_bytes ram_origin[NR_RAMS]; /* origin of each RAM disk */ PRIVATE phys_bytes ram_limit[NR_RAMS];    /*  limit of RAM disk per mino</p>
      <p> * mem_task</p>
      <p> PUBLIC mem_task() {</p>
      <p> /* Main program of the disk driver task.</p>
      <p> int r, caller, proc_nr; extern unsigned sizes[8]; extern phys_clicks get_base();</p>
      <p> r dev. */</p>
      <p> 480 File: kernel/memory.c MINIX SOURCE CODE</p>
      <p> 2300</p>
      <p> 2301 /* Initialize this task. */</p>
      <p> 2302 ram_origin[KMEM_DEV] = (phys_bytes) get_base() « CLICK_SHIFT;</p>
      <p> 2303 ram_limit[KMEM_DEV] = (sizes[0] + sizestl]) « CLICK_SHIFT;</p>
      <p> 2304 ram_limit[MEM_DEV] = MEM_BYTESj 2305</p>
      <p> 2306  /*  Here is the main loop of the memory task.    It waits for a message, carries</p>
      <p> 2307 # it out, and sends a reply.</p>
      <p> 2308 */</p>
      <p> 2309 while (TRUE) {</p>
      <p> 2310 /* First wait for a request to read or write. */</p>
      <p> 2311 receive(ANY, &amp;mess);</p>
      <p> 2312 if (mess.m_source &lt; 0)</p>
      <p> 2313 panicC'mem task got message from ", mess.m_source);</p>
      <p> 2314 caller = mess.m_source;</p>
      <p> 2315 proc_nr = mess.PR0C_NR; 2316</p>
      <p> 2317 /* Now carry out the work.   It depends on the opcode. #/</p>
      <p> 2318 switch(mess.m_type) {</p>
      <p> 2319 case DISK_READ: r = do_mem(&amp;mess); break;</p>
      <p> 2320 case DISK_WRITE:       r = do_mem(&amp;mess); break;</p>
      <p> 2321 case DI5K_I0CTL:       r = do_setup(&amp;mess); break;</p>
      <p> 2322 default: r = EINVAL; break;</p>
      <p> 2323 } 2324</p>
      <p> 2325 /* Finally, prepare and send the reply message. */</p>
      <p> 2326 mess.m_type = TASK_REPLY;</p>
      <p> 2327 mess.REP_PR0C_NR = proc_nr;</p>
      <p> 2328 mess.REP_STATUS = r;</p>
      <p> 2329 send(caller, imess);</p>
      <p> 2330 }</p>
      <p> 2331 }</p>
      <p> 2334 /*=========r============================================r====================*</p>
      <p> 2335 * do_mem *</p>
      <p> 2337 PRIVATE int do_mem(m_ptr)</p>
      <p> 2338 register message *m_ptr; /* pointer to read or write message  */</p>
      <p> 2339 {</p>
      <p> 2340 /* Read or write /dev/null, /dev/mem, /dev/kmem, or /dev/ram. */ 2341</p>
      <p> 2342 int device, count;</p>
      <p> 2343 phys_bytes mem_phys, user_phys;</p>
      <p> 2344 struct proc *rp;</p>
      <p> 2345 extern phys_clicks get_base();</p>
      <p> 2346 extern phys_bytes umapO; 2347</p>
      <p> 2348 /* Get minor device number and check for /dev/null. */</p>
      <p> 2349 device = m_ptr-&gt;DEVICE;</p>
      <p> MINIX SOURCE CODE File: kernel/memory.c</p>
      <p> 481</p>
      <p> 2350 if (device &lt; 0 || device &gt;= NR_RAMS) return(ENXIO);     /* bad minor device */</p>
      <p> 2351 if (device == NULI—DEV) return(m_ptr-&gt;m_type == DISK_READ ? 0 : m_ptr-&gt;COUNT); 2352</p>
      <p> 2353 /# Set up 'mem_phys' for /dev/mem, /dev/kmem, or /dev/ram. */</p>
      <p> 2354 if (m_ptr-&gt;P0SITI0N &lt; 0) return(ENXIO);</p>
      <p> 2355 mem_phys = ram_origin[device] + m_ptr-&gt;P0SITI0N;</p>
      <p> 2356 if (mem_phys &gt; ram_limit[device]) return(O);</p>
      <p> 2357 count = m_ptr-&gt;C0UNT;</p>
      <p> 2358 if(mem_phys + count &gt; ram_limit[device]) count = ram_limit[device] - mem_phys; 2359</p>
      <p> 2360 /* Determine address where data is to go or to come from. */</p>
      <p> 2361 rp = proc_addr(m_ptr-&gt;PROC_NR);</p>
      <p> 2362 user_phys = umap(rp, D, (vir_bytes) m_ptr-&gt;ADDRESS, (vir_bytes) count);</p>
      <p> 2363 if (user_phys == 0) return(E_BAD_ADDR); 2364</p>
      <p> 2365 /* Copy the data. */</p>
      <p> 2366 if (m_ptr-&gt;m_type == DISK_READ)</p>
      <p> 2367 phys_copy(mem_phys, user_phys, (long) count);</p>
      <p> 2368 else</p>
      <p> 2369 phys_copy(user_phys, mem_phys, (long) count);</p>
      <p> 2370 return(count);</p>
      <p> 2371 }</p>
      <p> 2375 * do_setup ♦</p>
      <p> 2376 t=:====== : ::= : ==: ::: ==== : :: ::::::::: : ::==: = ::::::::;:::::::=::::::::: .. ::=:: ,/</p>
      <p> 2377 PRIVATE int do_setup(m_ptr)</p>
      <p> 2378 message *m_ptr; /* pointer to read or write message */</p>
      <p> 2379 {</p>
      <p> 2380 /* Set parameters for one of the disk RAMs. */ 2381</p>
      <p> 2382 int device; 2383</p>
      <p> 2384 device = m_ptr-&gt;DEVICE;</p>
      <p> 2385 if (device &lt; 0 j| device &gt;= NR_RAMS) return(ENXIO);     /♦ bad minor device */</p>
      <p> 2386 ram_origin[device] = m_ptr-&gt;P0SITI0N;</p>
      <p> 2387 ram_limit[device] = m_ptr-&gt;P0SITI0N + (long) m_ptr-&gt;C0UNT # BL0CK_SIZE;</p>
      <p> 2388 return(OK);</p>
      <p> File: kernel/floppy.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 2400</p>
      <p> 2401</p>
      <p> 2402</p>
      <p> 2403</p>
      <p> 2404</p>
      <p> 2405</p>
      <p> 2406</p>
      <p> 2407</p>
      <p> 2408</p>
      <p> 2409</p>
      <p> 2410</p>
      <p> 2411</p>
      <p> 2412</p>
      <p> 2413</p>
      <p> 2414</p>
      <p> 2415</p>
      <p> 2416</p>
      <p> 2417</p>
      <p> 2418</p>
      <p> 2419</p>
      <p> 2420</p>
      <p> 2421</p>
      <p> 2422</p>
      <p> 2423</p>
      <p> 2424</p>
      <p> 2425</p>
      <p> 2426</p>
      <p> 2427</p>
      <p> 2428</p>
      <p> 2429</p>
      <p> 2430</p>
      <p> 2431</p>
      <p> 2432</p>
      <p> 2433</p>
      <p> 2434</p>
      <p> 2435</p>
      <p> 2436</p>
      <p> 2437</p>
      <p> 2438</p>
      <p> 2439</p>
      <p> 2440</p>
      <p> 2441</p>
      <p> 2442</p>
      <p> 2443</p>
      <p> 2444</p>
      <p> 2445</p>
      <p> 2446</p>
      <p> 2447</p>
      <p> 2448</p>
      <p> 2449</p>
      <p> /*</p>
      <p> This file contains a driver for a Floppy Disk Controller (FDC) using the NEC PD765 chip.    The driver supports two operations: read a block and write a block.    It accepts two messages, one for reading and one for writing, both using message format m2 and with the same parameters:</p>
      <p> * *</p>
      <p> # *</p>
      <p> */</p>
      <p> The file contains one entry point:</p>
      <p> floppy_task: main entry when system is brought up</p>
      <p> ^include "../h/const.h" ^include "../h/type.h" ^include "../h/callnr,h" ^include "../h/com.h" ^include "../h/error.h" ^include "const.h" ^include "type.h" ^include "proc.h"</p>
      <p> /* 1/0 Ports used by</p>
      <p> ^define DOR 0x3F2</p>
      <p> ^define FDC_STATUS 0x3F4</p>
      <p> #define FDC_DATA 0x3F5</p>
      <p> ^define DMA_ADDR 0x004</p>
      <p> ^define DMA_T0P 0x081</p>
      <p> ^define DMA_C0UNT 0x005</p>
      <p> ^define DMA_M2 OxOOC</p>
      <p> ^define DMA_M1 OxOOB</p>
      <p> ^define DMA_1NIT OxOOA</p>
      <p> /* Status registers returned</p>
      <p> ^define ST0 0x00</p>
      <p> ^define ST1 0x01</p>
      <p> ^define ST2 0x02</p>
      <p> ^define ST3 0x00</p>
      <p> ^define ST_CYL 0x03</p>
      <p> ^define ST_HEAD 0x04</p>
      <p> ^define ST_SEC 0x05</p>
      <p> ^define ST_PCN 0x01</p>
      <p> floppy disk task. */</p>
      <p> /* motor drive control bits */ /* floppy disk controller status register */ /* floppy disk controller data register */ /* port for low 16 bits of DMA address */ /* port for top 4 bits of 20-bit DMA addr */ /» port for DMA count (count =   bytes - 1) */ /* DMA status port */ /* DMA status port  */ /* DMA init port */</p>
      <p> as result of operation /* /* /* /*</p>
      <p> /</p>
      <p> status register 0 */ status register 1 */ status register 2 */</p>
      <p> status register 3 (return by DRIVE_SENSE) */ slot where controller reports cylinder  #/ slot where controller reports head */ slot where controller reports sector #/ slot where controller reports present cyl */</p>
      <p> /*  Fields within the 1/0 ports. */</p>
      <p> ^define MASTER 0x80       /# used to see who is master */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/floppy.c</p>
      <p> 483</p>
      <p> 2450</p>
      <p> 2451</p>
      <p> 2452</p>
      <p> 2453</p>
      <p> 2454</p>
      <p> 2455</p>
      <p> 2456</p>
      <p> 2457</p>
      <p> 2458</p>
      <p> 2459</p>
      <p> 2460</p>
      <p> 2461</p>
      <p> 2462</p>
      <p> 2463</p>
      <p> 2464</p>
      <p> 2465</p>
      <p> 2466</p>
      <p> 2467</p>
      <p> 2468</p>
      <p> 2469</p>
      <p> 2470</p>
      <p> 2471</p>
      <p> 2472</p>
      <p> 2473</p>
      <p> 2474</p>
      <p> 2475</p>
      <p> 2476</p>
      <p> 2477</p>
      <p> 2478</p>
      <p> 2479</p>
      <p> 2480</p>
      <p> 2481</p>
      <p> 2482</p>
      <p> 2483</p>
      <p> 2484</p>
      <p> 2485</p>
      <p> 2486</p>
      <p> 2487</p>
      <p> 2488</p>
      <p> 2489</p>
      <p> 2490</p>
      <p> 2491</p>
      <p> 2492</p>
      <p> 2493</p>
      <p> 2494</p>
      <p> 2495</p>
      <p> 2496</p>
      <p> 2497</p>
      <p> 2498</p>
      <p> 2499</p>
      <p> //define #define //define §def ine #define //define #define #define #define //define #define //define //define ^define //define</p>
      <p> DIRECTION CTL_BUSY</p>
      <p> CTI ACCEPTING</p>
      <p> M0T0R_MASK</p>
      <p> ENABLE_INT</p>
      <p> ST0_BITS</p>
      <p> ST3_FAULT</p>
      <p> ST3_WR_PR0TECT</p>
      <p> 5T3_READY</p>
      <p> TRANS_ST0</p>
      <p> SEEK_ST0</p>
      <p> BAD_SECT0R</p>
      <p> BAD_CYL</p>
      <p> WRITE_PR0TECT</p>
      <p> CHANGE</p>
      <p> 0x40 0x10 0x80 OxFO OxOC 0xF8 0x80 0x40 0x20 0x00 0x20 0x05 OxlF 0x02 OxCO</p>
      <p> /* is FDC trying to read or write? #/ /# used to see when controller is busy */ /* bit pattern FDC gives when idle */ /* these bits control the motors in DOR */ /* used for setting DOR port */ /*■ check top 5 bits of seek status */ /# if this bit is set, drive is sick */ /* set when diskette is write protected */ /* set when drive is ready #/ /* top 5 bits of STO for READ/WRITE */ /* /*</p>
      <p> top 5 bits of STO for SEEK */ if these bits are set in ST1, recalibrate */ /* if any of these bits are set, recalibrate */ /* bit is set if diskette is write protected */ /* value returned by FDC after reset */</p>
      <p> /# Floppy disk controller command bytes. */</p>
      <p> ^define FDC_SEEK             OxOF /* command the</p>
      <p> //define FDC_READ             0xE6 /* command the</p>
      <p> //define FDC_WRITE           0xC5 /* command the</p>
      <p> ^define FDC_SENSE           0x08 /* command the</p>
      <p> //define FDC_RECALIBRATE 0x07 /* command the</p>
      <p> ifdefine FDC_SPECIFY        0x03 /* command the</p>
      <p> drive to seek */</p>
      <p> drive to read */</p>
      <p> drive to write */</p>
      <p> controller to tell its status</p>
      <p> drive to go to cyl 0 */</p>
      <p> drive to accept params #/</p>
      <p> */</p>
      <p> /* DMA channel commands. */ //define DMA_READ 0x46 //define DMA_WRITE 0x4A</p>
      <p> /* DMA read opcode */ /* DMA write opcode */</p>
      <p> /* Parameters for the disk drive. */</p>
      <p> ^define SECTOR_SIZE</p>
      <p> //define NR_SECTORS</p>
      <p> //define NR_HEADS</p>
      <p> //define GAP</p>
      <p> //define DTL</p>
      <p> //define SPEC1</p>
      <p> //define SPEC2</p>
      <p> //define M0T0R_0FF //define M0T0R_START</p>
      <p> /* Error codes */ ifdefine ERR_SEEK //define ERR.TRANSFER //define ERR_STATUS //define ERR_RECALIBRATE //define ERR_WR_PROTECT ^define £RR_DRIVE</p>
      <p> /# Miscellaneous. */ //define MOTOR.RUNNING</p>
      <p> 512 /* physical sector size in bytes */</p>
      <p> 0x09 /* number of sectors per track */</p>
      <p> 0x02 /* two heads (i.e., two tracks/cylinder) */</p>
      <p> 0x2A /* intersector gap size */</p>
      <p> OxFF /* determines data length (sector size) */</p>
      <p> OxDF /* first parameter to SPECIFY #/</p>
      <p> 0x02 /* second parameter to SPECIFY */</p>
      <p> 3#HZ /* how long to wait before stopping motor */</p>
      <p> HZ/4 /* how long does it take motor to start up? */</p>
      <p> OxFF      /* message type for clock interrupt */</p>
      <p> 2500 ^define MAX_ERR0RS 10 /* how often to try rd/wt before quitting */</p>
      <p> 2501 ^define MAX_RESULTS 8 /* max number of bytes controller returns */</p>
      <p> 2502 ^define NR_DRIVES 2 /* maximum number of drives */</p>
      <p> 2503 ^define DIVISOR 128 /* used for sector size encoding */</p>
      <p> 2504 ^define MAX_FDC_RETRY       100 /* max  §  times to try to output to FDC */</p>
      <p> 2505 ^define NR_BL0CKS 720 /* number of blocks on 9 sector diskette */ 2506</p>
      <p> 2507 /* Variables. #/</p>
      <p> 2508 PRIVATE struct floppy { /* main drive struct, one entry per drive */</p>
      <p> 2509 int fl_opcode; /# DISK_REA0 or DISK_WRITE */</p>
      <p> 2510 int fl_curcyl; /* current cylinder #/</p>
      <p> 2511 int fl_procnr;  /*  which proc wanted this operation? */</p>
      <p> 2512 int fl_drive; /» drive number addressed */</p>
      <p> 2513 int fl_cylinder; /# cylinder number addressed */</p>
      <p> 2514 int fl_sector; /# sector addressed */</p>
      <p> 2515 int fl_head; /* head number addressed */</p>
      <p> 2516 int fl_count; /* byte count */</p>
      <p> 2517 vir_bytes fl_address; /* user virtual address */</p>
      <p> 2518 char fl_results[MAX_RESULTS]; /* the controller can give lots of output */</p>
      <p> 2519 char fl_calibration; /* CALIBRATED or UNCALIBRATED ♦/</p>
      <p> 2520 } floppy[NR_DRIVES]; 2521</p>
      <p> 2522 ^define UNCALIBRATED 0 /* drive needs to be calibrated at next use */</p>
      <p> 2523 ^define CALIBRATED 1 /* no calibration needed */ 2524</p>
      <p> 2525 PRIVATE int motor_status; /* current motor status is in 4 high bits */</p>
      <p> 2526 PRIVATE int motor_goal; /* desired motor status is in 4 high bits */</p>
      <p> 2527 PRIVATE int prev_motor; /* which motor was started last */</p>
      <p> 2528 PRIVATE int need_reset; /* set to 1 when controller must be reset */</p>
      <p> 2529 PRIVATE int initialized; /* set to 1 after first successful transfer #/</p>
      <p> 2530 PRIVATE int steps_per_cyl =1; /*  #  pulses to give stepping motor per cyl */ 2531</p>
      <p> 2532 PRIVATE message mess; /* message buffer for in and out */ 2533</p>
      <p> 2534 PRIVATE char len[] = {-1,0,1,-1,2,-1,-1,3,-1,-1,-1,-1,-1,-1,-1,4};</p>
      <p> 2535 PRIVATE char interleave!] = {1,2,3,4,5,6,7,8,9}; 2536</p>
      <p> 2537 /*===========================================================================*</p>
      <p> 2538 * floppy_task *</p>
      <p> 2539 »:=:======::::=:==:::==:====::::==::=====:=:=:::====:====:======::=====:====»/</p>
      <p> 2540 PUBLIC floppy_task()</p>
      <p> 2541 {</p>
      <p> 2542 /* Main program of the floppy disk driver task. */ 2543</p>
      <p> 2544 int r, caller, proc_nr; 2545</p>
      <p> 2546 /* Here is the main loop of the disk task.    It waits for a message, carries</p>
      <p> 2547 * it out, and sends a reply.</p>
      <p> 2548 ♦/</p>
      <p> 2549 while (TRUE) {</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/floppy.c</p>
      <p> 485</p>
      <p> 2550 /* First wait for a request to read or write a disk block. */</p>
      <p> 2551 receive(ANY, &amp;mess);      /* get a request to do some work ♦/</p>
      <p> 2552 if (mess.m_source &lt; 0)</p>
      <p> 2553 panicC'disk task got message from ", mess.m_source);</p>
      <p> 2554 caller = mess.m_source;</p>
      <p> 2555 proc_nr = mess.PROC_NR; 2556</p>
      <p> 2557 /* Now carry out the work. */</p>
      <p> 2558 switch(mess.m_type) {</p>
      <p> 2559 case DISK_READ: r = do_rdwt(&amp;mess); break;</p>
      <p> 2560 case DISK_WRITE:       r = do_rdwt(&amp;mess); break;</p>
      <p> 2561 default: r = EINVAL; break;</p>
      <p> 2562 } 2563</p>
      <p> 2564 /* Finally, prepare and send the reply message. +/</p>
      <p> 2565 mess.m_type = TASK_REPLY;</p>
      <p> 2566 mess.REP_PROC_NR = proc_nr;</p>
      <p> 2567 mess.REP_STATUS = r;        /* H  of bytes transferred or error code */</p>
      <p> 2568 send(caller, &amp;mess);      /# send reply to caller */</p>
      <p> 2569 }</p>
      <p> 2570 }</p>
      <p> 2573 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = r = = = = r = = = = = = - = r = = = : = =  =   =   =   : :  =  = = = z  =   : : = =  =   =  =</p>
      <p> 2574 * do_rdwt</p>
      <p> 2576 PRIVATE int do_rdwt(m_ptr)</p>
      <p> 2577 message #m_ptr;  /*  pointer to read or write message */</p>
      <p> 2578 {</p>
      <p> 2579 /* Carry out a read or write request from the disk. #/</p>
      <p> 2580 register struct floppy #fp;</p>
      <p> 2581 int r, drive, errors, stop_motor();</p>
      <p> 2582 long block; 2583</p>
      <p> 2584 /* Decode the message parameters. */</p>
      <p> 2585 drive = m_ptr-&gt;0EVICE;</p>
      <p> 2586 if (drive &lt; 0 || drive &gt;= NR_DRIVES) return(EIO);</p>
      <p> 2587 fp = &amp;floppy[drive]; /♦ 'fp' points to entry for this drive */</p>
      <p> 2588 fp-&gt;fl_drive = drive; /* save drive number explicitly */</p>
      <p> 2589 fp-&gt;fl_opcode = m_ptr-&gt;m_type; /# 0ISK_READ or DISK_WRITE */</p>
      <p> 2590 if (m_ptr-&gt;P0SITI0N  %  BL0CK_SIZE != 0) return(EINVAL);</p>
      <p> 2591 block = m_ptr-&gt;P0SITI0N/SECT0R_SIZE;</p>
      <p> 2592 if (block &gt;= NR_BL0CKS) return(O);</p>
      <p> 2593 fp-&gt;fl_cylinder = (int) (block / (NR.HEADS * NR_SECTORS));</p>
      <p> 2594 fp-&gt;fl_sector = (int) interieave[block  %  NR_SECT0RS];</p>
      <p> 2595 fp-&gt;fl_head = (int) (block  %  (NR_HEADS*NR_SECT0RS) )/NR_SECTORS;</p>
      <p> 2596 fp-&gt;fl_count = m_ptr-&gt;C0UNT;</p>
      <p> 2597 fp-&gt;fl_address = (vir_bytes) m_ptr-&gt;ADDRE55;</p>
      <p> 2598 fp-&gt;fl_procnr = m_ptr-&gt;PR0C_NR;</p>
      <p> 2599 if (fp-&gt;fl_count != BL0CK_SIZE) return(EINVAL);</p>
      <p> 486 File: kernel/floppy.c MINIX SOURCE CODE</p>
      <p> 2600</p>
      <p> 2601 errors = 0;</p>
      <p> 2602</p>
      <p> 2603 /* This loop allows a failed operation to be repeated. */</p>
      <p> 2604 while (errors &lt;= MAX.ERR0RS) { 2605</p>
      <p> 2606 /* If a lot of errors occur when 'initialized' is 0, it probably</p>
      <p> 2607 * means that we are trying at the wrong density.    Try another one.</p>
      <p> 2608 * Increment 'errors' here since loop is aborted on error.</p>
      <p> 2609 «/</p>
      <p> 2610 errors++; /* increment count once per loop cycle */</p>
      <p> 2611 if (initialized = = 0 &amp;&amp; errors  =-  MAX_ERR0RS &amp;&amp; fp-&gt;fl_cylinder &gt; 0) {</p>
      <p> 2612 if (steps_per_cyl &gt; 1) {</p>
      <p> 2613 panic("Unreadable diskette (drive density?)", NCLNUM);</p>
      <p> 2614 } else {</p>
      <p> 2615 steps_per_cyl++;</p>
      <p> 2616 errors = 0;</p>
      <p> 2617 }</p>
      <p> 2618 } 2619</p>
      <p> 2620 /* First check to see if a reset is needed. ♦/</p>
      <p> 2621 if (need_reset) reset(); 2622</p>
      <p> 2623 /* Now set up the DMA chip. ♦/</p>
      <p> 2624 dma_setup(fp); 2625</p>
      <p> 2626 /* See if motor is running; if not, turn it on and wait */</p>
      <p> 2627 start_motor(fp); 2628</p>
      <p> 2629 /* If we are going to a new cylinder, perform a seek. */</p>
      <p> 2630 r = seek(fp);</p>
      <p> 2631 if (r != OK) continue;   /* if error, try again */ 2632</p>
      <p> 2633 /* Perform the transfer. */</p>
      <p> 2634 r = transfer(fp);</p>
      <p> 2635 if (r == OK) break;        /* if successful, exit loop */</p>
      <p> 2636 if (r == ERR_WR_PROTECT) break; /* retries won't help */ 2637</p>
      <p> 2638 } 2639</p>
      <p> 2640 /* Start watch_dog timer to turn motor off in a few seconds */</p>
      <p> 2641 motor_goal = ENABLE_INT; /♦ when timer goes off, kill all motors */</p>
      <p> 2642 clock_mess(M0T0R_0FF, stop_motor);</p>
      <p> 2643 if (r == OK &amp;&amp; fp-&gt;fl_cylinder &gt; 0) initialized =1;    /* seek works */</p>
      <p> 2644 return(r == OK ? BL0CK_SIZE : EI0);</p>
      <p> MINK SOURCE CODE</p>
      <p> File: kernel/floppy.c</p>
      <p> 487</p>
      <p> 2650 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   = = = = = = . = = = = = = = = = =   = = = = = = = = =   = = = =   = = = = = = *</p>
      <p> 2651 * dma_setup #</p>
      <p> 2652 * = = = = = = = = = = = - = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =   = = = = = = = = = = = = =   = = = = = = = = = = = - = = = =</p>
      <p> 2653 PRIVATE dma_setup(fp)</p>
      <p> 2654 struct floppy *fp; /# pointer to the drive struct */</p>
      <p> 2655 {</p>
      <p> 2656 /* The IBM PC can perform DMA operations by using the DMA chip.    To use it,</p>
      <p> 2657 * the DMA (Direct Memory Access) chip is loaded with the 20-bit memory address</p>
      <p> 2658 * to be read from or written to, the byte count minus 1, and a read or write</p>
      <p> 2659 # opcode.    This routine sets up the DMA chip.    Note that the chip is not</p>
      <p> 2660 * capable of doing a DMA across a 64K boundary (e.g., you can't read a</p>
      <p> 2661 # 512-byte block starting at physical address 65520).</p>
      <p> 2662 */ 2663</p>
      <p> 2664 int mode, low_addr, high_addr, top_addr, low_ct, high_ct, top_end;</p>
      <p> 2665 vir_bytes vir, ct;</p>
      <p> 2666 phys_bytes user_phys;</p>
      <p> 2667 extern phys_bytes umap(); 2668</p>
      <p> 2669 mode = (fp-&gt;f Lopcode == DISK_REA0 ? DMA_READ : DMA_WRITE);</p>
      <p> 2670 vir = (vir_bytes) fp-&gt;fl_address;</p>
      <p> 2671 ct = (vir_bytes) fp-&gt;fl_count;</p>
      <p> 2672 user_phys = umap(proc_addr(fp-&gt;fl_procnr), D, vir, ct);</p>
      <p> 2673 low_addr   = (int) (user_phys »   0) &amp; BYTE;</p>
      <p> 2674 high_addr = (int) (user_phys »   8) &amp; BYTE;</p>
      <p> 2675 top_addr   = (int) (user_phys » 16) &amp; BYTE;</p>
      <p> 2676 low_ct    = (int) ( (ct - 1) » 0) &amp; BYTE;</p>
      <p> 2677 high_ct = (int) ( (ct - 1) » 8) &amp; BYTE; 2678</p>
      <p> 2679 /* Check to see if the transfer will require the DMA address counter to</p>
      <p> 2680 * go from one 64K segment to another.    If so, do not even start it, since</p>
      <p> 2681 * the hardware does not carry from bit 15 to bit 16 of the DMA address.</p>
      <p> 2682  *  Als ° check for bad buffer address.    These errors mean ES contains a buq.</p>
      <p> 2683 */  y</p>
      <p> 2684 if (user_phys == 0) panic("FS gave floppy disk driver bad addr", (int) vir);</p>
      <p> 2685 top_end = (int) (((user_phys + ct - 1) &gt;&gt; 16) &amp; BYTE);</p>
      <p> 2686 if (top_end != top_addr) panicC'Trying to DMA across 64K boundary", top_adclr); 2687</p>
      <p> 2688 /* Now set up the DMA registers. */</p>
      <p> 2689 lock();</p>
      <p> 2690 port_out(DMA_M2, mode); /* set the DMA mode */</p>
      <p> 2691 port_out(DMA_Ml, mode); /» set it again */</p>
      <p> 2692 port_out(DMA_ADDR, low_addr); /* output low-order 8 bits */</p>
      <p> 2693 port_out(DMA_ADDR, high_addr);/* output next 8 bits #/</p>
      <p> 2694 port_out(DMA_T0P, top_addr);   /* output highest 4 bits */</p>
      <p> 2695 port_out(DMA_C0UNT, low_ct);   /* output low 8 bits of count - 1 */</p>
      <p> 2696 port_out(DMA_C0UNT, high_ct); /♦ output high 8 bits of count - 1 */</p>
      <p> 2697 unlockO;</p>
      <p> 2698 port_out(DMA_INIT, 2); /* initialize DMA */</p>
      <p> File: kernel/floppy.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 2700 /*===========================================================================*</p>
      <p> 2701 * start_motor *</p>
      <p> 2702  ( == = ===::=:= = = = === = === = === = == = == = = = == = = = == = : = : = == = == =  : = = ====^= = === = ==== = = = =»/</p>
      <p> 2703 PRIVATE start_motor(fp)</p>
      <p> 2704 struct floppy *fp;  /*  pointer to the drive struct */</p>
      <p> 2705 {</p>
      <p> 2706 A Control of the floppy disk motors is a big pain.    If a motor is off, you</p>
      <p> 2707 * have to turn it on first, which takes 1/2 second.   You can't leave it on</p>
      <p> 2708 * all the time, since that would wear out the diskette.    However, if you turn</p>
      <p> 2709 * the motor off after each operation, the system performance will be awful.</p>
      <p> 2710 * The compromise used here is to leave it on for a few seconds after each</p>
      <p> 2711 * operation.    If a new operation is started in that interval, it need not be</p>
      <p> 2712 * turned on again.    If no new operation is started, a timer goes off and the</p>
      <p> 2713 * motor is turned off.    1/0 port DOR has bits to control each of 4 drives.</p>
      <p> 2714 * Interrupts must be disabled temporarily to prevent a clock interrupt from</p>
      <p> 2715 * turning off motors while we are testing the bits.</p>
      <p> 2716 #/ 2717</p>
      <p> 2718 int motor_bit, running, send_mess(); 2719</p>
      <p> 2720 lock(); /# no interrupts while checking out motor */</p>
      <p> 2721 motor_bit = 1 &lt;&lt; (fp-&gt;fl_drive +4);    /* bit mask for this drive #/</p>
      <p> 2722 motor_goal = motor_bit | ENABLE_INT | fp-&gt;fl_drive;</p>
      <p> 2723 if (motor_status &amp; prev_motor) motor_goal |= prev_motor;</p>
      <p> 2724 running = motor_status &amp; motor_bit;     /* nonzero if this motor is running */</p>
      <p> 2725 port_out(D0R, motor_goal);</p>
      <p> 2726 motor_status = motor_goal;</p>
      <p> 2727 prev_motor = motor_bit; /# record motor started for next time */</p>
      <p> 2728 unlockO; 2729</p>
      <p> 2730 /# If the motor was already running, we don't have to wait for it. */</p>
      <p> 2731 if (running) return; /* motor was already running */</p>
      <p> 2732 clock_mess(M0T0R_START, send_mess);     /* motor was not running #/</p>
      <p> 2733 receive(CL0CK, &amp;mess); /* wait for clock interrupt */</p>
      <p> 2734 }</p>
      <p> 2737 /# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = = =: = = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 2738 * stop_motor *</p>
      <p> 2739 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =: = = = =: = = =: = = = = = = = = = = = = = = = = = = = */</p>
      <p> 2740 PRIVATE stop_motor()</p>
      <p> 2741 {</p>
      <p> 2742 /* This routine is called by the clock interrupt after several seconds have</p>
      <p> 2743 * elapsed with no floppy disk activity.    It checks to see if any drives are</p>
      <p> 2744 * supposed to be turned off, and if so, turns them off.</p>
      <p> 2745 */ 2746</p>
      <p> 2747 if ( (motor_goal &amp; M0T0R_MASK) != (motor_status &amp; M0T0R_MASK) ) {</p>
      <p> 2748 port_out(D0R, motor_goal);</p>
      <p> 2749 motor_status = motor_goal;</p>
      <p> MINIX SOURCE CODE File: kernel/floppy.c 489</p>
      <p> 2750 }</p>
      <p> 2751 }</p>
      <p> 2755 * seek</p>
      <p> 2756 *= = = = = = = = = = = = = = = = = = : = = = = = = = = r = = = = = = = = r = = = = = = r = = = = = = = =  =   : :  =  r =  =   =   =  =:  =   =   =   =   =  -  =   =   = :  =  -  =   =</p>
      <p> 2757 PRIVATE int seek(fp)</p>
      <p> 2758 struct floppy *fp; /* pointer to the drive struct */</p>
      <p> 2759 {</p>
      <p> 2760 /# Issue a SEEK command on the indicated drive unless the arm is already</p>
      <p> 2761 * positioned on the correct cylinder.</p>
      <p> 2762 */ 2763</p>
      <p> 2764 int r; 2765</p>
      <p> 2766 /* Are we already on the correct cylinder? */</p>
      <p> 2767 if (fp-&gt;fl_calibration == UNCALIBRATED)</p>
      <p> 2768 if (recalibrate(fp) != OK) return(ERR_SEEK);</p>
      <p> 2769 if (fp-&gt;fl_curcyl r = fp-&gt;fl_cylinder) return(OK); 2770</p>
      <p> 2771 /# No.   Wrong cylinder.    Issue a SEEK and wait for interrupt. */</p>
      <p> 2772 fdc_out(EDC_SEEK); /* start issuing the SEEK command */</p>
      <p> 2773 fdc_out( (fp-&gt;fl_head « 2) | fp-&gt;fl_drive);</p>
      <p> 2774 fdc_out(fp-&gt;fl_cylinder * steps_per_cyl);</p>
      <p> 2775 if (need_reset) return(ERR_SEEK); /* if controller is sick, abort seek</p>
      <p> 2776 receive(HARDWARE, imess); 2777</p>
      <p> 2778 /* Interrupt has been received.    Check drive status. */</p>
      <p> 2779 fdc_out(FDC_SENSE); /* probe FDC to make it return status */</p>
      <p> 2780 r = fdc_results(fp); /* get controller status bytes */</p>
      <p> 2781 if ( (fp-&gt;fl_results[STO] &amp; ST0_BITS) != SEEK_ST0) r = ERR_SEEK;</p>
      <p> 2782 if (fp-&gt;fl_results[STl]  != fp-&gt;fl_cylinder * steps_per_cyl) r = ERR_SEEKj</p>
      <p> 2783 if (r != OK)</p>
      <p> 2784 if (recalibrate(fp) != OK) return(ERR_SEEK);</p>
      <p> 2785 return(r);</p>
      <p> 2786 }</p>
      <p> 2789 = = = = = = = = = = = = = = = = = =     =     =     = =     = = = = =     =     = = = = = = =     = = = = = = = = = = = = .</p>
      <p> 2790 * transfer</p>
      <p> 2792 PRIVATE int transfer(fp)</p>
      <p> 2793 register struct floppy *fp; /* pointer to the drive struct */</p>
      <p> 2794 {</p>
      <p> 2795 /* The drive is now on the proper cylinder.   Read or write 1 block. */ 2796</p>
      <p> 2797 int r, s, op; 2798</p>
      <p> 2799 /♦ Never attempt a transfer if the drive is uncalibrated or motor is off. *</p>
      <p> File: kernel/floppy.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 2800 if (fp-&gt;fl_calibration == UNCALIBRATED) return(ERR_TRANSFER);</p>
      <p> 2801 if ( ( (motor_status»(fp-&gt;fl_drive+4)) &amp; 1) == 0) return(ERR_TRANSFER): 2802</p>
      <p> 2803 /* The command is issued by outputting 9 bytes to the controller chip. */</p>
      <p> 2804 op = (fp-&gt;fl_opcode       DISK_READ ? FDC_READ : FDC_WRITE);</p>
      <p> 2805 fdc_out(op); /* issue the read or write command */</p>
      <p> 2806 fdc_out( (fp-&gt;fl_head « 2) | fp-&gt;fl_drive);</p>
      <p> 2807 fdc_out(fp-&gt;fl_cylinder); /# tell controller which cylinder */</p>
      <p> 2808 fdc_out(fp-&gt;fl_head); /♦ tell controller which head */</p>
      <p> 2809 fdc_out(fp-&gt;fl_sector); /* tell controller which sector */</p>
      <p> 2810 fdc_out( (int) len[SECT0R_SIZE/DIVIS0R]); /* sector size */</p>
      <p> 2811 fdc_out(NR_SECT0RS); /# tell controller how big a track is */</p>
      <p> 2812 fdc_out(GAP); /* tell controller how big sector gap is */</p>
      <p> 2813 fdc_out(DTL); /* tell controller about data length */ 2814</p>
      <p> 2815 /* Block, waiting for disk interrupt. */</p>
      <p> 2816 if (need_reset) return(ERR_TRANSFER); /* if controller is sick, abort op */</p>
      <p> 2817 receive(HARDWARE, &amp;mess); 2818</p>
      <p> 2819 /# Get controller status and check for errors. */</p>
      <p> 2820 r = fdc_results(fp);</p>
      <p> 2821 if (r != OK) return(r);</p>
      <p> 2822 if ( (fp-&gt;fl_results[STl] &amp; BAD_SECT0R)  |[  (fp-&gt;fl_results[ST2] &amp; BAD_CYL) )</p>
      <p> 2823 fp-&gt;fl_calibration = UNCALIBRATED;</p>
      <p> 2824 if (fp-&gt;fl_results[STl] &amp; WRITE_PR0TECT) {</p>
      <p> 2825 printf("Diskette in drive  %d  is write protected.\n", fp-&gt;fl_drive);</p>
      <p> 2826 return(ERR_WR_PR0TECT);</p>
      <p> 2827 }</p>
      <p> 2828 if ((fp-&gt;fl_results[ST0] &amp; ST0_BITS)  != TRANS_ST0) return(ERR_TRANSFER);</p>
      <p> 2829 if (fp-&gt;fl_results[STl]  | fp-&gt;fl_results[ST2]) return(ERR_TRAN5FER); 2830</p>
      <p> 2831 /* Compare actual numbers of sectors transferred with expected number. */</p>
      <p> 2832 s =   (fp-&gt;fl_results[ST_CYL] - fp-&gt;f Lcylinder) # NR_HEADS * NR_SECT0RS;</p>
      <p> 2833 s += (fp-&gt;fl_results[ST_HEAD] - fp-&gt;fl_head) # NR_SECTORS;</p>
      <p> 2834 s += (fp-&gt;fl_results[ST_SEC] - fp-&gt;fLsector);</p>
      <p> 2835 if (s * SECT0R_SIZE != fp-&gt;fl_count) return(ERR_TRAN5FER);</p>
      <p> 2836 return(OK);</p>
      <p> 2837 }</p>
      <p> 2840 /*= = === = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ===: = = = = = = = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   == *</p>
      <p> 2841 * fdc_results *</p>
      <p> 2843 PRIVATE int fdc_results(fp) * /</p>
      <p> 2844 register struct floppy *fp;  /*  pointer to the drive struct */</p>
      <p> 2845 {</p>
      <p> 2846 /* Extract results from the controller after an operation. */ 2847</p>
      <p> 2848 int i,  j, status; 2849</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/floppy.c</p>
      <p> 491</p>
      <p> 2850 /* Loop, extracting bytes from FDC until it says it has no more. */</p>
      <p> 2851 for (i = 0; i &lt; MAX_RE5ULTS; i++) {</p>
      <p> 2852 port_in(FDC_STATUS, istatus);</p>
      <p> 2853 if ( (status i MASTER) == 0) return(ERR_STATUS);</p>
      <p> 2854 port_in(FDC_STATUS, istatus);     /# read it again */</p>
      <p> 2855 if ( (status &amp; DIRECTION) == 0) return(ERR_STATUS);</p>
      <p> 2856 port_in(FDC_DATA, istatus);</p>
      <p> 2857 fp-&gt;fl_results[i] = status &amp; BYTE;</p>
      <p> 2858 for (j = 0; j &lt; 5; j++) ; /♦ delay loop */</p>
      <p> 2859 port_in(FDC_5TATU5, istatus);</p>
      <p> 2860 if ( (status i CTL_BUSY) == 0) return(OK);</p>
      <p> 2861 } 2862</p>
      <p> 2863 /* FDC is giving back too many results. */</p>
      <p> 2864 need_reset = TRUE; /* controller chip must be reset */</p>
      <p> 2865 return(ERR_STATUS);</p>
      <p> 2866 }</p>
      <p> 2870 * fdc_out</p>
      <p> 2872 PRIVATE fdc_out(val)</p>
      <p> 2873 int val; /# write this byte to floppy disk controller</p>
      <p> 2874 {</p>
      <p> 2875 /# Output a byte to the controller.    This is not entirely trivial, since you</p>
      <p> 2876 * can only write to it when it is listening, and it decides when to listen.</p>
      <p> 2877 * If the controller refuses to listen, the FDC chip is qiven a hard reset.</p>
      <p> 2878 */ 2879</p>
      <p> 2880 int retries, r; 2881</p>
      <p> 2882 if (need_reset) return; /* if controller is not listening, return */</p>
      <p> 2883 retries = MAX_FDC_RETRY; 2884</p>
      <p> 2885 /* It may take several tries to get the FDC to accept a command. */</p>
      <p> 2886 while (retries— &gt; 0) {</p>
      <p> 2887 port_in(FDC_STATUS, 4r);</p>
      <p> 2888 r i= (MASTER | DIRECTION); /* just look at bits 2 and 3 #/</p>
      <p> 2889 if ( r  != CTI—ACCEPTING) continue; /* FDC is not listening */</p>
      <p> 2890 port_out(FDC_DATA, val);</p>
      <p> 2891 return;</p>
      <p> 2892 } 2893</p>
      <p> 2894 /# Controller is not listening.   Hit it over the head with a hammer. */</p>
      <p> 2895 need_reset =: TRUE;</p>
      <p> 492 File: kernel/floppy.c MINIX SOURCE CODE</p>
      <p> 2901 *                                              recalibrate *</p>
      <p> 2903 PRIVATE int recalibrate(fp)</p>
      <p> 2904 register struct floppy *fpj /* pointer tot he drive struct */</p>
      <p> 2905 {</p>
      <p> 2906 /# The floppy disk controller has no way of determining its absolute arm</p>
      <p> 2907 * position (cylinder).    Instead, it steps the arm a cylinder at a time and</p>
      <p> 2908 * keeps track of where it thinks it is (in software).    However, after a</p>
      <p> 2909 # SEEK, the hardware reads information from the diskette telling where the</p>
      <p> 2910 * arm actually is.   If the arm is in the wrong place, a recalibration is done,</p>
      <p> 2911 # which forces the arm to cylinder 0.   This way the controller can get back</p>
      <p> 2912 * into sync with reality.</p>
      <p> 2913 */ 2914</p>
      <p> 2915 int rj 2916</p>
      <p> 2917 /♦ Issue the RECALIBRATE command and wait for the interrupt. */</p>
      <p> 2918 start_motor(fp); /* can't recalibrate with motor off */</p>
      <p> 2919 fdc_out(FDC_RECALIBRATE); /* tell drive to recalibrate itself */</p>
      <p> 2920 fdc_out(fp-&gt;fl_drive); /* specify drive #/</p>
      <p> 2921 if (need_reset) return(ERR_SEEK); /* don't wait if controller is sick */</p>
      <p> 2922 receive(HARDWARE, &amp;mess); /* wait for interrupt message */ 2923</p>
      <p> 2924 /* Determine if the recalibration succeeded. */</p>
      <p> 2925 fdc_out(FDC_SENSE); /* issue SENSE command to see where we are */</p>
      <p> 2926 r = fdc_results(fp); /* get results of the SENSE command */</p>
      <p> 2927 fp-&gt;fl_curcyl = -1; /* force a SEEK next time #/</p>
      <p> 2928 if (r != OK || /* controller would not respond */</p>
      <p> 2929 (fp-&gt;fl_results[ST0]&amp;ST0_BITS) !=SEEK_ST0 || fp-&gt;fl_results[ST_PCN] !=0){</p>
      <p> 2930 /* Recalibration failed.   FDC must be reset. */</p>
      <p> 2931 need_reset = TRUE;</p>
      <p> 2932 fp-&gt;fl_calibration = UNCALIBRATED;</p>
      <p> 2933 return(ERR_RECALIBRATE);</p>
      <p> 2934 } else {</p>
      <p> 2935 /# Recalibration succeeded. */</p>
      <p> 2936 fp-&gt;fl_calibration = CALIBRATED;</p>
      <p> 2937 return(OK);</p>
      <p> 2938 }</p>
      <p> 2939 }</p>
      <p> 2942 /*===========================================================================*</p>
      <p> 2943 * reset *</p>
      <p> 2944 *== === = = = = = === = === === = = === === ===== === = === = = = = ==== = = = = = = =====r = = === = = = = === = ==*/</p>
      <p> 2945 PRIVATE resetO</p>
      <p> 2946 {</p>
      <p> 2947 /* Issue a reset to the controller.    This is done after any catastrophe,</p>
      <p> 2948 * like the controller refusing to respond.</p>
      <p> 2949 */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/floppy.c</p>
      <p> 493</p>
      <p> 2950</p>
      <p> 2951 int i, r,. status;</p>
      <p> 2952 register struct floppy *fp; 2953</p>
      <p> 2954 /* Disable interrupts and strobe reset bit low.  */</p>
      <p> 2955 need_reset = FALSE;</p>
      <p> 2956 lockO;</p>
      <p> 2957 motor_status = 0;</p>
      <p> 2958 motor_goal = 0;</p>
      <p> 2959 port_out(D0R, 0); /* strobe reset bit low */</p>
      <p> 2960 port_out(D0R, ENABLE_INT);       /* strobe it high again */</p>
      <p> 2961 unlockO; /* interrupts allowed again  */</p>
      <p> 2962 receive(HARDWARE, imess); /* collect the RESET interrupt */ 2963</p>
      <p> 2964 /* Interrupt from the reset has been received.   Continue resetting. */</p>
      <p> 2965 fp = &amp;floppy[0]; /* use floppy[0] for scratch */</p>
      <p> 2966 fp-&gt;fl_results[0] = 0; /* this byte will be checked shortly */</p>
      <p> 2967 fdc_out(FDC_SENSE); /* did it work? #/</p>
      <p> 2968 r = fdc_results(fp); /* get results */ 296? if (r != OK) panicC'FDC won't reset", r);</p>
      <p> 2970 status = fp-&gt;fl_results[0] 4 BYTE;</p>
      <p> 2971 if (status != CHANGE)</p>
      <p> 2972 panicC'FDC did not become ready after reset", fp-&gt;fl_results[0]); 2973</p>
      <p> 2974 /* Reset succeeded.    Tell FDC drive parameters. #/</p>
      <p> 2975 fdc_out(FDC_SPECIFY); /* specify some timing parameters */</p>
      <p> 2976 fdc_out(SPECl); /* step-rate and head-unload-time */</p>
      <p> 2977 fdc_out(SPEC2); /* head-load-time and non-dma */ 2978</p>
      <p> 2979 for (i = 0; i &lt; NR_DRIVES; i++) floppyfi].fl_calibration = UNCALIBRATED;</p>
      <p> 2980 }</p>
      <p> 2983 /*===========================================================================*</p>
      <p> 2984 * clock_mess *</p>
      <p> 2985 *===========================================================================*/</p>
      <p> 2986 PRIVATE clock_mess(ticks, func)</p>
      <p> 2987 int ticks; /» how many clock ticks to wait */</p>
      <p> 2988 int (*func)(); /* function to call upon time out */</p>
      <p> 2989 {</p>
      <p> 2990  I*  Send the clock task a message. */ 2991</p>
      <p> 2992 mess.m_type = SET_ALARM;</p>
      <p> 2993 mes=.CL0CK_PR0C_NR = FLOPPY;</p>
      <p> 2994 mess.DELTA_TICKS = ticks;</p>
      <p> 2995 mess.FUNC_T0_CALL = func;</p>
      <p> 2996 sendrec(CL0CK, &amp;mess);</p>
      <p> File: kernel/floppy.c MINIX SOURCE CODE</p>
      <p> 3000 /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = - =  =  = = = = = = = = = = = =  =  = = = = = = = = = = = = ^ = = = = = = = = = = = = = = = =:*</p>
      <p> 3001 * sencLmess *</p>
      <p> 3002 *===========================================================================*/</p>
      <p> 3003 PRIVATE send_mess()</p>
      <p> 3004 {</p>
      <p> 3005 /* This routine is called when the clock task has timed out on motor startup.*/ 3006</p>
      <p> 3007 mess.m_type = M0T0R_RUNNING;</p>
      <p> 3008 send(FL0PPY, &amp;ntess);</p>
      <p> 3009 }</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/clock.c</p>
      <p> 495</p>
      <p> 3050</p>
      <p> 3051</p>
      <p> 3052</p>
      <p> 3053</p>
      <p> 3054</p>
      <p> 3055</p>
      <p> 3056</p>
      <p> 3057</p>
      <p> 3058</p>
      <p> 3059</p>
      <p> 3060</p>
      <p> 3061</p>
      <p> 3062</p>
      <p> 3063</p>
      <p> 3064</p>
      <p> 3065</p>
      <p> 3066</p>
      <p> 3067</p>
      <p> 3068</p>
      <p> 3069</p>
      <p> 3070</p>
      <p> 3071</p>
      <p> 3072</p>
      <p> 3073</p>
      <p> 3074</p>
      <p> 3075</p>
      <p> 3076</p>
      <p> 3077</p>
      <p> 3078</p>
      <p> 3079</p>
      <p> 3080</p>
      <p> 3081</p>
      <p> 3082</p>
      <p> 3083</p>
      <p> 3084</p>
      <p> 3085</p>
      <p> 3086</p>
      <p> 3087</p>
      <p> 3088</p>
      <p> 3089</p>
      <p> 3090</p>
      <p> 3091</p>
      <p> 3092</p>
      <p> 3093</p>
      <p> 3094</p>
      <p> 3095</p>
      <p> 3096</p>
      <p> 3097</p>
      <p> 3098</p>
      <p> 3099</p>
      <p> /* This file contains the code and data for the clock task.    The clock task</p>
      <p> * has a single entry point, clock_task().   It accepts four message types: *</p>
      <p> * CL0CK_TICK:   a clock interrupt has occurred</p>
      <p> * GET_TIME:      a process wants the real time</p>
      <p> * SET_TIME:      a process wants to set the real time</p>
      <p> * SET_ALARM: a process wants to be alerted after a specified interval *</p>
      <p> * The input message is format m6.   The parameters are as follows:</p>
      <p> When an alarm goes off, if the caller is a user process, a SIGALRM signal is sent to it.   If it is a task, a function specified by the caller will be invoked.   This function may, for example, send a message, but only if it is certain that the task will be blocked when the timer goes off.</p>
      <p> */</p>
      <p> ^include #include ^include //include ^include //include //include ^include //include ^include</p>
      <p> "../h/const.h" "../h/type.h" "../h/callnr.h" "../h/com.h" "../h/error.h" ". ./h/signal.h" "const.h" "type.h" "glo.h" "proc.h"</p>
      <p> /* Constant definitions. */</p>
      <p> //define MILLISEC 100      /* how often to call the scheduler (msec) */</p>
      <p> //define SCHED_RATE (MILLISEC*HZ/1000)     /* number of ticks per schedule */</p>
      <p> /* Clock parameters. */ ^define TIMER0 0x40 //define TIMER_M0DE 0x43 //define IBM_FREQ 11931821 ^define SQUAR£_WAVE 0x36</p>
      <p> /* Clock task variables. */ PRIVATE real_time boot_time;</p>
      <p> /* port address for timer channel 0 */ /* port address for timer channel 3 */ /* IBM clock frequency for setting timer /* mode for generating square wave #/</p>
      <p> /* time in seconds of system boot */</p>
      <p> 496 File: kernel/clock.c MINIX SOURCE CODE</p>
      <p> 3100 PRIVATE real_time next_alarm;     /* probable time of next alarm */</p>
      <p> 3101 PRIVATE int sched_ticks = SCHED_RATE;     /* counter: when 0, call scheduler */</p>
      <p> 3102 PRIVATE struct proc *prev_ptr;   /* last user process run by clock task */</p>
      <p> 3103 PRIVATE message mc; /# message buffer for both input and output #/</p>
      <p> 3104 PRIVATE int (*watch_dog[NR_TASKS+l])(); /* watch_dog functions to call */ 3105</p>
      <p> 3106 /*===========================================================================*</p>
      <p> 3107 * clock_task *</p>
      <p> 3108 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = := = = = = =: = = = = = = = = = = = = = = = = = = = = = =: = = = = *</p>
      <p> 3109 PUBLIC clock_task()</p>
      <p> 3110 {</p>
      <p> 3111 /* Main program of clock task.   It determines which of the 4 possible</p>
      <p> 3112 * calls this is by looking at 'mc.m_type'.     Then it dispatches.</p>
      <p> 3113 */ 3114</p>
      <p> 3115 int opcode; 3116</p>
      <p> 3117 init_clock();                            /* initialize clock tables ♦/ 3118</p>
      <p> 3119 /* Main loop of the clock task.    Get work, process it, sometimes reply. */</p>
      <p> 3120 while (TRUE) {</p>
      <p> 3121 receive(ANY, &amp;mc); /* go get a message */</p>
      <p> 3122 opcode = mc.m_type; /* extract the function code */ 3123</p>
      <p> 3124 switch (opcode) {</p>
      <p> 3125 case SET_ALARM:   do_setalarm(&amp;mc); break;</p>
      <p> 3126 case GET_TIME:     do_get_time(); break;</p>
      <p> 3127 case SET_TIME:     do_set_time(&amp;mc); break;</p>
      <p> 3128 case CL0CK_TICK: do_clocktick(); break;</p>
      <p> 3129 default: panicC'clock task got bad message", mc.m_type);</p>
      <p> 3130 } 3131</p>
      <p> 3132 /* Send reply, except for clock tick. #/</p>
      <p> 3133 mc.m_type = OK;</p>
      <p> 3134 if (opcode != CL0CK_TICK) send(mc.m_source, &amp;mc);</p>
      <p> 3135 }</p>
      <p> 3136 }</p>
      <p> 3139 /* = = = = = = = = = = = = = = =: = = = = r = = = = = = = = = = = = = = = =: = =: = = = = = == = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = = *</p>
      <p> 3140 # do_setalarm *</p>
      <p> 3141 *==============================================================</p>
      <p> 3142 PRIVATE do_setalarm(m_ptr)</p>
      <p> 3143 message #m_ptr; /* pointer to request message */</p>
      <p> 3144 {</p>
      <p> 3145 /# A process wants an alarm signal or a task wants a given watch_dog function</p>
      <p> 3146 * called after a specified interval.    Record the request and check to see</p>
      <p> 3147 * it is the very next alarm needed.</p>
      <p> 3148 */ 3149</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/clock.c</p>
      <p> 497</p>
      <p> 3150 register struct proc *rp;</p>
      <p> 3151 int procnr; /* which process wants the alarm */</p>
      <p> 3152 long delta_ticks; /* in how many clock ticks does he want it? */</p>
      <p> 3153 int (#function)(); /* function to call (tasks only) */ 3154</p>
      <p> 3155 /* Extract the parameters from the message. */</p>
      <p> 3156 proc_nr = m_ptr-&gt;CL0CK_PR0C_NR; /* process to interrupt later */</p>
      <p> 3157 delta_ticks = m_ptr-&gt;DELTA_TICKS; /* how many ticks to wait */</p>
      <p> 3158 function = m_ptr-&gt;FUNC_TO_CALL; /* function to call (tasks only) */</p>
      <p> 3159 rp = proc_addr(proc_nr);</p>
      <p> 3160 mc.SECONDS_LEFT = (rp-&gt;p_alarm == 0L ? 0 : (rp-&gt;p_alarm - realtime)/HZ );</p>
      <p> 3161 rp-&gt;p_alarm = (delta_ticks == 0L ? 0L : realtime + delta_ticks);</p>
      <p> 3162 if (proc_nr &lt; 0) watch_dog[-proc_nr] = function; 3163</p>
      <p> 3164 /* Which alarm is next? */</p>
      <p> 3165 next_alarm = MAX_P_L0NG;</p>
      <p> 3166 for (rp = &amp;proc[0]; rp &lt; &amp;proc[NR_TASKS+NR_PROCS]; rp++)</p>
      <p> 3167 if(rp-&gt;p_alarm != 0 45 rp-&gt;p_alarm &lt; next_alarm)next_alarm=rp-&gt;p_alarm; 3168</p>
      <p> 3169 }</p>
      <p> 3172 /* = : = :: = = =:== = :=:: = == = ==::: = = = = = == = = :: = = = = = = = =: = = = = = = = :: = = = = = = = = = = :" = : = = = ::=(</p>
      <p> 3173 * do_get_time *</p>
      <p> 3174 *=============================================r=============================*/</p>
      <p> 3175 PRIVATE do_get_time()</p>
      <p> 3176 {</p>
      <p> 3177 /* Get and return the current clock time in ticks. */ 3178</p>
      <p> 3179 mc.m_type = REAI TIME; /# set message type for reply */</p>
      <p> 3180 mc.NEW_TIME = boot_time + realtime/HZ; /* current real time */</p>
      <p> 3181 }</p>
      <p> 3184 /*===========================================================================*</p>
      <p> 3185 * do_set_time *</p>
      <p> 3186 * = = = = = = = = = = = = = = = =: = = = = = = = = = = = = = = = = = = = r = = = = = = = r = = = = = = = = = =: = : = = = = = r = = = = = = = = = = = = = ♦/</p>
      <p> 3187 PRIVATE do_set_time(m_ptr)</p>
      <p> 3188 message *m_ptr; /* pointer to request message */</p>
      <p> 3189 {</p>
      <p> 3190 /* Set the real time clock.    Only the superuser can use this call. */ 3191</p>
      <p> 3192 boot_time = m_ptr-&gt;NEW_TIME - realtime/HZ;</p>
      <p> 3193 }</p>
      <p> 3196 /*===:=====:=======r=================r===:=====:=========:===================*</p>
      <p> 3197 * do_clocktick *</p>
      <p> 3198 * = = = = = = = = =: = = = = = = = = = = = = = = = = : = = = = = = = = = = = = = ; = = = = = = = = = = = = = = = = = = = = = = = == = = = = = = = = = = */</p>
      <p> 3199 PRIVATE do_clocktick()</p>
      <p> 498 File: kernel/clock.c MINIX SOURCE CODE</p>
      <p> 3200 {</p>
      <p> 3201 /* This routine is called on every clock tick. */ 3202</p>
      <p> 3203 register struct proc *rp;</p>
      <p> 3204 register int t, proc_nr; 3205</p>
      <p> 3206 /* To guard against race conditions, first copy 'lost_ticks' to a local</p>
      <p> 3207 * variable, add this to 'realtime', and then subtract it from 'lost_ticks'.</p>
      <p> 3208 */</p>
      <p> 3209 t = lost_ticks; /* 'lost_ticks' counts missed interrupts */</p>
      <p> 3210 realtime += t + 1; /* update the time of day */</p>
      <p> 3211 lost_ticks -= t; /* these interrupts are no longer missed */ 3212</p>
      <p> 3213 if (next_alarm &lt;= realtime) {</p>
      <p> 3214 /* An alarm may have gone off, but proc may have exited, so check. */</p>
      <p> 3215 next_alarm = MAX_P_L0NG; /* start computing next alarm */</p>
      <p> 3216 for (rp = 4proc[0]; rp &lt; &amp;proc[NR_TASK5+NR_PR0CS]; rp++) {</p>
      <p> 3217 if (rp-&gt;p_alarm != (real_time) 0) {</p>
      <p> 3218 /* See if this alarm time has been reached. */</p>
      <p> 3219 if (rp-&gt;p_alarm &lt;= realtime) {</p>
      <p> 3220 /* A timer has gone off.    If it is a user proc</p>
      <p> 3221 * send it a signal.    If it is a task, call thi</p>
      <p> 3222 * function previously specified by the task.</p>
      <p> 3223 */</p>
      <p> 3224 proc_nr = rp - proc - NR_TASKS;</p>
      <p> 3225 if (proc_nr &gt;= 0)</p>
      <p> 3226 cause_sig(proc_nr, SIGALRM);</p>
      <p> 3227 else</p>
      <p> 3228 (*watch_dog[-proc_nrJ)();</p>
      <p> 3229 rp-&gt;p_alarm = 0;</p>
      <p> 3230 } 3231</p>
      <p> 3232 /* Work on determining which alarm is next. */</p>
      <p> 3233 if (rp-&gt;p_alarm != 0 &amp;&amp; rp-&gt;p_alarm &lt; next_alarm)</p>
      <p> 3234 next_alarm = rp-&gt;p_alarm;</p>
      <p> 3235 }</p>
      <p> 3236 }</p>
      <p> 3237 } 3238</p>
      <p> 3239 accounting(); /* keep track of who is using the cpu */</p>
      <p> 3240</p>
      <p> 3241 /* If a user process has been running too long, pick another one. */</p>
      <p> 3242 if (--sched_ticks == 0) {</p>
      <p> 3243 if (bill_ptr == prev_ptr) schedO; /* process has run too long */</p>
      <p> 3244 sched_ticks = 5CHED_RATE; /* reset guantum */</p>
      <p> 3245 prev_ptr = bill_ptr; /* new previous process */</p>
      <p> 3246 } 3247</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/clock.c</p>
      <p> 499</p>
      <p> 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265</p>
      <p> accounting</p>
      <p> 'bill_ptr' is always If the CPU was in</p>
      <p> PRIVATE accountingO {</p>
      <p> /* Update user and system accounting times.    The variable</p>
      <p> * kept pointing to the process to charge for CPU usage.</p>
      <p> * user code prior to this clock tick, charge the tick as user time, otherwise</p>
      <p> * charge it as system time. */</p>
      <p> if (prev_proc &gt;= LOWJJSER)</p>
      <p> bill_ptr-&gt;user_time++;   /# charge CPU time */</p>
      <p> else</p>
      <p> bill_ptr-&gt;sys_time++;     /* charge system time ♦/</p>
      <p> 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285</p>
      <p> tfifdef i8088</p>
      <p> /*========================z==================================================*</p>
      <p> ♦ init_clock *</p>
      <p> t::" = :::::::::::ii::r=::::::::::ii:":::r:::::::::i::::::;:::::::::::: = ::::»/</p>
      <p> PRIVATE init_clock() {</p>
      <p> /* Initialize channel 2 of the 8253A timer to e.g. 60 Hz. */</p>
      <p> unsigned int count, low_byte, high_byte;</p>
      <p> count = (unsigned) (IBM_FREQ/HZ); low_byte = count 4 BYTE; high_byte = (count » 8) 4 BYTE; port_out(TIMER-MODE, SQUARE_WAVE); port_out(TIMERO, low_byte); port_out(TIMERO, high_byte);</p>
      <p> }</p>
      <p> #endif</p>
      <p> /* /* /* /* /* /♦</p>
      <p> value to load into the timer */ compute low-order byte */ compute high-order byte */ set timer to run continuously */ load timer low byte */ load timer high byte #/</p>
      <p> File: kernel/tty.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349</p>
      <p> /* This file contains the terminal driver, both for the IBM console and regular</p>
      <p> * ASCII terminals.   It is split into two sections, a device-independent part</p>
      <p> * and a device-dependent part.   The device-independent part accepts</p>
      <p> *  characters to be printed from programs and queues them in a standard way</p>
      <p> * for device-dependent output.    It also accepts input and queues it for</p>
      <p> * programs. This file contains 2 main entry points: tty_task() and keyboard().</p>
      <p> * When a key is struck on a terminal, an interrupt to an assembly language</p>
      <p> * routine is generated.    This routine saves the machine state and registers</p>
      <p> * and calls keyboardO, which enters the character in an internal table, and</p>
      <p> * then sends a message to the terminal task.    The main program of the terminal</p>
      <p> * task is tty_task(). It accepts not only messages about typed input, but</p>
      <p> * also requests to read and write from terminals, etc. #</p>
      <p> *  The device-dependent part interfaces with the IBM console and ASCII</p>
      <p> * terminals.    The IBM keyboard is unusual in that keystrokes yield key numbers</p>
      <p> * rather than ASCII codes, and furthermore, an interrupt is generated when a</p>
      <p> * key is depressed and again when it is released.    The IBM display is memory</p>
      <p> * mapped, so outputting characters such as line feed, backspace and bell are</p>
      <p> * tricky. *</p>
      <p> *  The valid messages and their parameters are: *</p>
      <p> * TTY_CHAR_INT: a character has been typed on a terminal (input interrupt)</p>
      <p> * TTY_0_D0NE:     a character has been output (output completed interrupt)</p>
      <p> * TTY_READ:        a process wants to read from a terminal</p>
      <p> * TTY_WRITE:       a process wants to write on a terminal</p>
      <p> * TTY_I0CTL:       a process wants to change a terminal's parameters</p>
      <p> * CANCEL: terminate a previous incomplete system call immediately</p>
      <p> */</p>
      <p> ^include ^include ^include ^include ^include</p>
      <p> ./h/const.h" ./h/type.h" ./h/callnr.h" ../h/com.h" ,./h/error.h"</p>
      <p> File: kernel/tty.c</p>
      <p> MINIX SOURCE CODE</p>
      <p> 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449</p>
      <p> int tty_column; int tty_row; char tty_busyj char tty_escaped; char tty_inhibited; char tty_makebreak; char tty_waiting;</p>
      <p> /* current column number (0-origin) */ /* current row (0 at bottom of screen) */ /# 1 when output in progress, else 0 #/ /* 1 when 'V just seen, else 0 */</p>
      <p> /# 1 when CTRL-S just seen (stops output) */ /* /*</p>
      <p> 1 for terminals that interrupt twice/key #/ 1 when output process waiting for reply */</p>
      <p> /* User settable characters: erase, kill, interrupt, quit, x-on; x-off. */</p>
      <p> char tty_erase;</p>
      <p> char tty_kill;</p>
      <p> char tty_intr;</p>
      <p> char tty_quit;</p>
      <p> char tty_xon;</p>
      <p> char tty_xoff;</p>
      <p> char tty_eof;</p>
      <p> /*  Information about char tty_incaller; char tty_inproc; char *tty_in_vir; int tty_inleft; char tty_otcaller; char tty_outproc; char »tty_out_vir; phys_bytes tty_phys; int tty_outleft; int tty_cum;</p>
      <p> /* Miscellaneous. */ int tty_ioport; } tty_struct[NR_TTYS];</p>
      <p> /* Values for the fields. */</p>
      <p> /* char /* char /* char /* char char /* char /* char</p>
      <p> /</p>
      <p> used used used used used used used</p>
      <p> to erase 1 char to erase a line to send SIGINT for core dump to start output to stop output to stop output</p>
      <p> (init ~H) */</p>
      <p> (init 0) */</p>
      <p> (init DEL) */</p>
      <p> (init CTRL-N) */</p>
      <p> (init CTRL-Q)*/</p>
      <p> (init CTRL-S) */</p>
      <p> (init CTRL-D) */</p>
      <p> incomplete 1/0 requests is stored here. */</p>
      <p> /# process that made the call (usually FS)  */ /* process that wants to read from tty */ /* virtual address where data is to go */ /* how many chars are still needed */ /* process that made the call (usually FS) */ /* process that wants to write to tty */ /* virtual address where data comes from */ /* physical address where data comes from */ /* §  chars yet to be copied to tty_outqueue */ /*  §  chars copied to tty_outqueue so far */</p>
      <p> /* 1/0 port number for this terminal */</p>
      <p> ^define</p>
      <p> */ */</p>
      <p> no CRTL-S has been typed to stop the tty ♦/ CTRL-S has been typed to stop the tty */ the tty is not printing */ the tty is printing */</p>
      <p> regular terminals interrupt once per char */ IBM console interrupts two times per char */ no output process is hanging */ an output process is waiting for a reply */</p>
      <p> PRIVATE char tty_driver_buf[2*MAX_0VERRUN+2]; /* driver collects chars here */ PRIVATE char tty_copy_buf[2*MAX_0VERRUN];    /* copy buf used to avoid races */ PRIVATE char tty_buf[TTY_BUF_SIZE];        /# scratch buffer to/from user space */ PRIVATE int shiftl, shift2, capslock, numlock;    /* keep track of shift keys */ PRIVATE int control, alt; /* keep track of key statii */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 503</p>
      <p> 3450 PRIVATE int Olivetti; /* flag set for Olivetti M24 keyboard */</p>
      <p> 3451 PUBLIC scan_code; /* scan code for ' = ' saved by bootstrap */ 3452</p>
      <p> 3453 /* Scan codes to ASCII for unshifted keys */</p>
      <p> 3454 PRIVATE char unsh[] = {</p>
      <p> 3455 0,033,'1' ,'2'       ,'4' ,'5' ,'6' , '7','8\'9','0' ,'-','=','\b','\t' ,</p>
      <p> 3456 'q','w','e','r','t','y','u','i', ' o' ,' p' ,'[',']' ,015,0202 ,' a'    s' ,</p>
      <p> 3457 'd' , T ,'g' ,'h' ,' j'  ,'k'  ,'1' ,' ;' , 047 ,0140,0200,0134,' z','x','c','v' ,</p>
      <p> 3458 'b','n','m',',','.','/',0201,'*',        0203,' ',0204,0241,0242,0243,0244,0245,</p>
      <p> 3459 0246,0247,0250,0251,0252,0205,0210,0267, 0270,0271,0211,0264,0265,0266,0214</p>
      <p> 3460 ,0261,   0262,0263,'0',0177</p>
      <p> 3461 }; 3462</p>
      <p> 3463 /* Scan codes to ASCII for shifted keys */</p>
      <p> 3464 PRIVATE char sh[] = {</p>
      <p> 3465 0,033,'!','@' ,'§','$','%' , '4','*','(',')','_','+','\b','\f,</p>
      <p> 3466 'Q','W','E','R','T','Y','U','I', '0','P','{','}',015,0202 ,'A','S',</p>
      <p> 3467 'D' ,'F' ,'G' ,'H' / J' ,'K' ,'L' ,' ;' , 042,'"', 0200,' | ' ,' Z' ,' X' ,' C' ,' V ,</p>
      <p> 3468 'B','N','M\'&lt;','&gt;','?',0201,'*',       0203,' ',0204,0221,0222,0223,0224,0225,</p>
      <p> 3469 0226,0227,0230,0231,0232,0204,0213/7' ,    '8' , '9' ,0211,'4' ,'5' ,'6' ,0214,' 1' ,</p>
      <p> 3470 '2','3','0',177</p>
      <p> 3471 }; 3472</p>
      <p> 3473</p>
      <p> 3474 /* Scan codes to ASCII for Olivetti M24 for unshifted keys. */</p>
      <p> 3475 PRIVATE char unm24[] = {</p>
      <p> 3476 0,033,'1','2','3','4','5' , '6' , ' 7' , ' 8* , ' 9 \'0' ,' - ' , ' ~ ' , '\b' ,'\t' ,</p>
      <p> 3477 'q','w','e','r*,'t','y','u','i', 'o','p','@','[','\r',0202,'a','s' ,</p>
      <p> 3478 'd','f','g','h','j','k','l',';', ':',']*,0200,'\\','z','x','c&gt; ,'v',</p>
      <p> 3479 'b','n','m',',','.','/',0201,'*',        0203,' ',0204,0241,0242,0243,0244,0245,</p>
      <p> 3480 0246,0247,0250,0251,0252,023,0210,'7', '8','9',0211,'4','5','6',0214,'1',</p>
      <p> 3481 '2','3','0','.','  ',014,0212, '\r' ,     '\b','\n','\f,013,032,0213,' ','/',</p>
      <p> 3482 0253,0254,0255,0256,0257,0215,0216,0217</p>
      <p> 3483 }; 3484</p>
      <p> 3485 /* Scan codes to ASCII for Olivetti M24 for shifted keys. */</p>
      <p> 3486 PRIVATE char m24[] = {</p>
      <p> 3487 0,033 ,'!',"",'#',' $','%','&amp;' , 047 ,'(',')','_',' = ',' ~' ,' \b' ,' \t' ,</p>
      <p> 3488 'Q','W','E','R'  ,'T','Y','U','I', '0','P',0140,'{','\r',0202,'A' ,'S' ,</p>
      <p> 3489 'D','F','G','H','J','K','L',' + \ '*' ,'}' ,0200,' |','Z','X','C','V',</p>
      <p> 3490 'B','N*,'M','&lt;','&gt;','?',0201,'*', 0203,' ',0204,0221,0222,0223,0224,0225,</p>
      <p> 3491 0226,0227,0230,0231,0232,0270,023,036, 013,037,0211,'\b',036,'\f,0214,04,</p>
      <p> 3492 '\n',037,0207,0177,0271,014,0272,'\r', '\b','\n','\f,036,032,0273,0274,'/',</p>
      <p> 3493 0233,0234,0235,0236,0237,0275,0276,0277</p>
      <p> 3494 }; 3495</p>
      <p> 3496</p>
      <p> 3497 /♦ ::: :: :::: : :: :: ::: : : :: :: : : " ::: : :: : :::: : : ::::: ::::: : :::::::::: : : : ::::==::   =   : :: t</p>
      <p> 3498 * tty_task *</p>
      <p> 504 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 3500 PUBLIC tty_task()</p>
      <p> 3501 {</p>
      <p> 3502 /* Main routine of the terminal task. */ 3503</p>
      <p> 3504 message tty_mess; /* buffer for all incoming messages */</p>
      <p> 3505 register struct tty_struct *tp; 3506</p>
      <p> 3507 tty_init(); /* initialize */</p>
      <p> 3508 while (TRUE) {</p>
      <p> 3509 receive(ANY, &amp;tty_mess);</p>
      <p> 3510 tp = &amp;tty_struct[tty_mess.TTY_LINE];</p>
      <p> 3511 switch(tty_mess.m_type) {</p>
      <p> 3512 case TTY_CHAR_INT:    do_charint(&amp;tty_mess); break;</p>
      <p> 3513 case TTY_READ: do_read(tp, &amp;tty_mess); break;</p>
      <p> 3514 case TTY_WRITE: do_write(tp, &amp;tty_mess); break;</p>
      <p> 3515 case TTY_I0CTL: do_ioctl(tp, &amp;tty_mess); break;</p>
      <p> 3516 case CANCEL     : do_cancel(tp, &amp;tty_mess); break;</p>
      <p> 3517 case TTY_0_D0NE:       /* reserved for future use (RS-232 terminals)*/</p>
      <p> 3518 default: tty_reply(TASK_REPLY, tty_mess.m_source,</p>
      <p> 3519 tty_mess.PR0C_NR, EINVAL, 0L, 0L);</p>
      <p> 3520 }</p>
      <p> 3521 }</p>
      <p> 3522 }</p>
      <p> 3525 /*===========================================================================*</p>
      <p> 3526 * do_charint *</p>
      <p> 3527 * ======= =: = -=r==================r===========================================*/</p>
      <p> 3528 PRIVATE do_charint(m_ptr)</p>
      <p> 3529 message #m_ptr; /* message containing pointer to char(s) */</p>
      <p> 3530 {</p>
      <p> 3531 /* A character has been typed.   If a character is typed and the tty task is</p>
      <p> 3532 * not able to service it immediately, the character is accumulated within</p>
      <p> 3533 ♦ the tty driver.    Thus multiple chars may be accumulated.    A single message</p>
      <p> 3534 * to the tty task may have to process several characters.</p>
      <p> 3535 */ 3536</p>
      <p> 3537 int m, n, count, replyee, caller;</p>
      <p> 3538 char *ptr, #copy_ptr, ch;</p>
      <p> 3539 struct tty_struct *tp; 3540</p>
      <p> 3541 lock(); /* prevent races by disabling interrupts */</p>
      <p> 3542 ptr = m_ptr-&gt;ADDRESS; /* pointer to accumulated char array */</p>
      <p> 3543 copy_ptr = tty_copy_buf; /* ptr to shadow array where chars copied */</p>
      <p> 3544 n = *ptr; /* how many chars have been accumulated */</p>
      <p> 3545 count = n; /* save the character count */</p>
      <p> 3546 n = n + n; /* each char occupies 2 bytes */</p>
      <p> 3547 ptr += 2; /* skip count field at start of array »/</p>
      <p> 3548 while (n— &gt; 0)</p>
      <p> 3549 *copy_ptr++ = *ptr++;     /* copy the array to safety */</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 505</p>
      <p> 3550 ptr = m_ptr-&gt;ADDRESS;</p>
      <p> 3551 *ptr =0; /♦ accumulation count set to 0 */</p>
      <p> 3552 unlockO; /# re-enable interrupts */ 3553</p>
      <p> 3554 /* Loop on the accumulated characters, processing each in turn. */</p>
      <p> 3555 copy_ptr = tty_copy_buf;</p>
      <p> 3556 while (count-- &gt; 0) {</p>
      <p> 3557 ch = *copy_ptr++; /* get the character typed */</p>
      <p> 3558 n = *copy_ptr++; /* get the line number it came in on */</p>
      <p> 3559 in_char(n, ch); /♦ queue the char and echo it */ 3560</p>
      <p> 3561 /* See if a previously blocked reader can now be satisfied. */</p>
      <p> 3562 tp = &amp;tty_struct[n];       /* pointer to struct for this character */</p>
      <p> 3563 if (tp-&gt;tty_inleft &gt; 0 ) { /* does anybody want input? */</p>
      <p> 3564 m = tp-&gt;tty_mode &amp; (CBREAK | RAW);</p>
      <p> 3565 if (tp-&gt;tty_lfct &gt; 0 ||  (m != 0 &amp;&amp; tp-&gt;tty_incount &gt; 0)) {</p>
      <p> 3566 m = rd_chars(tp); 3567</p>
      <p> 3568 /* Tell hanging reader that chars have arrived. */</p>
      <p> 3569 replyee = (int) tp-&gt;tty_incaller;</p>
      <p> 3570 caller = (int) tp-&gt;tty_inproc;</p>
      <p> 3571 tty_reply(REVIVE, replyee, caller, m, 0L, 0L);</p>
      <p> 3572 }</p>
      <p> 3573 }</p>
      <p> 3574 }</p>
      <p> 3575 }</p>
      <p> 3578 /*= = = === = = = = = = = === = = = = = = = = = = = === = = = = = = = = = = = = = = = = = = = = = = = =  =   =   =   =   =   =   =   =   =   =   =   i   =   =   =   =   =   =   =   =   :=</p>
      <p> 3579 * in_char</p>
      <p> 3580 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = :r = = =  =  =  =   =   =   =   =   =   =   :=</p>
      <p> 3581 PRIVATE in_char(line, ch)</p>
      <p> 3582 int line; /* line number on which char arrived */</p>
      <p> 3583 char ch; /* scan code for character that arrived */</p>
      <p> 3584 {</p>
      <p> 3585 /* A character has just been typed in.   Process, save, and echo it. */ 3586</p>
      <p> 3587 register struct tty_struct *tp;</p>
      <p> 3588 int mode, sig;</p>
      <p> 3589 char make_break();</p>
      <p> 3590 tp = &amp;tty_struct[line]; /# set 'tp' to point to proper struct */</p>
      <p> 3591 /* Function keys are temporarily being used for debug dumps. */</p>
      <p> 3592 if (ch &gt;= Fl &amp;&amp; ch &lt;= F10) {   /* Check for function keys Fl, F2,  ... F10 */</p>
      <p> 3593 func_key(ch); /* process function key */</p>
      <p> 3594 return;</p>
      <p> 3595 }</p>
      <p> 3596 if (tp-&gt;tty_incount &gt;= TTY_IN_BYTES) return;    /♦ no room, discard char */</p>
      <p> 3597 mode = tp-&gt;tty_mode &amp; (RAW | CBREAK);</p>
      <p> 3598 if (tp-&gt;tty_makebreak)</p>
      <p> 3599 ch = make_break(ch);       /* console give 2 ints/ch */</p>
      <p> 506 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 3600 else</p>
      <p> 3601 if (mode != RAW) ch &amp;= 0177;       /# 7-bit chars except in raw mode */</p>
      <p> 3602 if (ch == 0) return; 3603</p>
      <p> 3604 /# Processing for COOKED and CBREAK mode contains special checks. */</p>
      <p> 3605 if (mode == COOKED || mode == CBREAK) {</p>
      <p> 3606 /* Handle erase, kill and escape processing. */</p>
      <p> 3607 if (mode == COOKED) {</p>
      <p> 3608 /» First erase processing (rub out of last character). */</p>
      <p> 3609 if (ch == tp-&gt;tty_erase &amp;&amp; tp-&gt;tty_escaped = = N0T_E5CAPED) {</p>
      <p> 3610 chuck(tp); /* remove last char entered #/</p>
      <p> 3611 echo(tp, '\b'); /* remove it from the screen */</p>
      <p> 3612 echo(tp, ' ');</p>
      <p> 3613 echo(tp, '\b');</p>
      <p> 3614 return;</p>
      <p> 3615 } 3616</p>
      <p> 3617 /* Now do kill processing (remove current line). */</p>
      <p> 3618 if (ch == tp-&gt;tty_kill &amp;&amp; tp-&gt;tty_escaped == N0T_ESCAPED) {</p>
      <p> 3619 while( chuck(tp) =r OK) /* keep looping */ ;</p>
      <p> 3620 echo(tp, tp-&gt;tty_kill);</p>
      <p> 3621 echo (tp, '\n');</p>
      <p> 3622 return;</p>
      <p> 3623 } 3624</p>
      <p> 3625 /* Handle EOT and the escape symbol (backslash). */</p>
      <p> 3626 if (tp-&gt;tty_escaped == NOT_ESCAPED) {</p>
      <p> 3627 /* Normal case: previous char was not backslash. */</p>
      <p> 3628 if (ch ==  '\\') {</p>
      <p> 3629 /» An escaped symbol has just been typed. */</p>
      <p> 3630 tp-&gt;tty_escaped = ESCAPED;</p>
      <p> 3631 echo(tp, ch);</p>
      <p> 3632 return; /* do not store the 'V */</p>
      <p> 3633 }</p>
      <p> 3634 /* CTRL-D means end-of-file, unless it is escaped. It</p>
      <p> 3635 * is stored in the text as MARKER, and counts as a</p>
      <p> 3636 * line feed in terms of knowing whether a full line</p>
      <p> 3637 * has been typed already.</p>
      <p> 3638 */</p>
      <p> 3639 if (ch == tp-&gt;tty_eof) ch = MARKER;</p>
      <p> 3640 } else {</p>
      <p> 3641 /* Previous character was backslash. */</p>
      <p> 3642 tp-&gt;tty_escaped = N0T_ESCAPED;    /* turn escaping off */</p>
      <p> 3643 if (ch != tp-&gt;tty_erase &amp;&amp; ch != tp-&gt;tty_kill &amp;&amp;</p>
      <p> 3644 ch != tp-&gt;tty_eof) {</p>
      <p> 3645 /* Store the escape previously skipped over */</p>
      <p> 3646 #tp-&gt;tty_inhead++ = 'W;</p>
      <p> 3647 tp-&gt;tty_incount++;</p>
      <p> 3648 if (tp-&gt;tty_inhead ==</p>
      <p> 3649 &amp;tp-&gt;tty_inqueue[TTY_IN_BYTES])</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 507</p>
      <p> 3650 tp-&gt;tty_inhead = tp-&gt;tty_inqueue;</p>
      <p> 3651 }</p>
      <p> 3652 }</p>
      <p> 3653 }</p>
      <p> 3654  /*  Both COOKED and C8REAK modes come here; first map CR to LF. */</p>
      <p> 3655 if (ch == *\r' &amp;&amp; (tp-&gt;tty_mode &amp; CRMOD)) ch = '\n'; 3656</p>
      <p> 3657 /* Check for interrupt and quit characters. */</p>
      <p> 3658 if (ch — tp-&gt;tty_intr || ch == tp-&gt;tty_quit) {</p>
      <p> 3659 sig  -  (ch == tp-&gt;tty_intr ? SIGINT : SIGQUIT);</p>
      <p> 3660 tp-&gt;tty_inhibited = RUNNING;       /* do implied CRTL-Q */</p>
      <p> 3661 finish(tp, EINTR); /* send reply */</p>
      <p> 3662 echo(tp, '\n')j</p>
      <p> 3663 cause_sig(LOW_USER + 1 + line, sig);</p>
      <p> 3664 return;</p>
      <p> 3665 } 3666</p>
      <p> 3667 /* Check for and process CTRL-S (terminal stop). */</p>
      <p> 3668 if (ch == tp-&gt;tty_xoff) {</p>
      <p> 3669 tp-&gt;tty_inhibited = STOPPED;</p>
      <p> 3670 return;</p>
      <p> 3671 } 3672</p>
      <p> 3673 A Check for and process CTRL-Q (terminal start). #/</p>
      <p> 3674 if (ch == tp-&gt;tty_xon) {</p>
      <p> 3675 tp-&gt;tty_inhibited = RUNNING;</p>
      <p> 3676 (*tp-&gt;tty_devstart)(tp); /» resume output */</p>
      <p> 3677 return;</p>
      <p> 3678 }</p>
      <p> 3679 } 3680</p>
      <p> 3681 /* All 3 modes come here. */</p>
      <p> 3682 if (ch == '\n'  || ch == MARKER) tp-&gt;tty_lfct++; /* count line feeds ♦/</p>
      <p> 3683 *tp-&gt;tty_inhead++ = ch; /* save the character in the input queue */</p>
      <p> 3684 if (tp-&gt;tty_inhead == &amp;tp-&gt;tty_inqueue[TTY_IN_BYTES])</p>
      <p> 3685 tp-&gt;tty_inhead = tp-&gt;tty_inqueue;  I*  handle wraparound */</p>
      <p> 3686 tp-&gt;tty_incount++;</p>
      <p> 3687 echo(tp, ch);</p>
      <p> 3688 }</p>
      <p> 3691 #ifdef i8088</p>
      <p> 3692 /*= === = = = = = = === = === = = = = = = = = = = = = = = = = = = === = = = = = = = = = =  =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =   =:; :*</p>
      <p> 3693 * make_break *</p>
      <p> 3694 *=========================r== = ========== ======= == ========= ======= ========:: #/</p>
      <p> 3695 PRIVATE char make_break(ch)</p>
      <p> 3696 char ch; /* scan code of key just struck or released */</p>
      <p> 3697 {</p>
      <p> 3698 /* This routine can handle keyboards that interrupt only on key depression,</p>
      <p> 3699 * as well as keyboards that interrupt on key depression and key release.</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 509</p>
      <p> 3750 /* Echo a character on the terminal. #/ 3751</p>
      <p> 3752 if ( (tp-&gt;tty_mode &amp; ECHO) == 0) return; /* if no echoing, don't echo */</p>
      <p> 3753 if (c != MARKER) out_char(tp, c);</p>
      <p> 3754 flush(tp); /* force character out onto the screen */</p>
      <p> 3755 }</p>
      <p> 3758 /*= = = = = = = = = = = = = = = = = = = = = = = = r = r = = = = = = = =: = = = :  =   =  = = =  =  r  =   =   =   =   =   =  =  =  - =  =   =   =   =   =  z = = = = = = = = = = = ^ = *</p>
      <p> 3759 * chuck *</p>
      <p> 3761 PRIVATE int chuck(tp)</p>
      <p> 3762 register struct tty_struct #tp; /# from which tty should chars be removed */</p>
      <p> 3763 {</p>
      <p> 3764 /* Delete one character from the input queue.    Used for erase and kill. */ 3765</p>
      <p> 3766 char *prev; 3767</p>
      <p> 3768 /* If input queue is empty, don't delete anything. */</p>
      <p> 3769 if (tp-&gt;tty_incount == 0) return(-l); 3770</p>
      <p> 3771 /* Don't delete '\n' or '\r\ */</p>
      <p> 3772 prev = (tp-&gt;tty_inhead  \-  tp-&gt;tty_inqueue ? tp-&gt;tty_inhead - 1 :</p>
      <p> 3773 &amp;tp-&gt;tty_inqueue[TTY_IN_BYTES-l]);</p>
      <p> 3774 if (*prev == '\n'  || *prev == '\r') return(-l);</p>
      <p> 3775 tp-&gt;tty_inhead = prev;</p>
      <p> 3776 tp-&gt;tty_incount—;</p>
      <p> 3777 return(OK); /# char erasure was possible */</p>
      <p> 3778 }</p>
      <p> 3782 * do_read *</p>
      <p> 3783 *= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =  =  = = = = =  =   =  = = =  =   ::   =   =   =   =   =   =  =  =   =   =   == */</p>
      <p> 3784 PRIVATE do_read(tp, m_ptr)</p>
      <p> 3785 register struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 3786 message #m_ptr; /* pointer to message sent to the task */</p>
      <p> 3787 {</p>
      <p> 3788 /* A process wants to read from a terminal. */ 3789</p>
      <p> 3790 int code, caller; 3791</p>
      <p> 3792 if (tp-&gt;tty_inleft &gt; 0) { /* if someone else is hanging, give up */</p>
      <p> 3793 tty_reply(TASK_REPLY,m_ptr-&gt;m_source,m_ptr-&gt;PROC_NR, E_TRY_AGAIN,0L,0L);</p>
      <p> 3794 return;</p>
      <p> 3795 } 3796</p>
      <p> 3797 /* Copy information from the message to the tty struct. */</p>
      <p> 3798 tp-&gt;tty_incaller = m_ptr-&gt;m_source;</p>
      <p> 3799 tp-&gt;tty_inproc = m_ptr-&gt;PR0C_NR;</p>
      <p> 510 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 3800 tp-&gt;tty_in_vir = m_ptr-&gt;ADDRESS;</p>
      <p> 3801 tp-&gt;tty_inleft = m_ptr-&gt;C0UNT; 3802</p>
      <p> 3803 /* Try to get chars.    This call either gets enough, or gets nothing. */</p>
      <p> 3804 code = rd_chars(tp);</p>
      <p> 3805 caller = (int) tp-&gt;tty_inproc;</p>
      <p> 3806 tty_reply(TASK_REPLY, m_ptr-&gt;m_saurce, caller, code, 0L, 0L);</p>
      <p> 3807 }</p>
      <p> 3810 /*============================================:r====r==================:======*</p>
      <p> 3811 * rd_chars *</p>
      <p> 3813 PRIVATE rd_chars(tp)</p>
      <p> 3814 register struct tty_struct *tp; /* pointer to terminal to read from */</p>
      <p> 3815 {</p>
      <p> 3816 /* A process wants to read from a terminal.   First check if enough data is</p>
      <p> 3817 * available. If so, pass it to the user.   If not, send FS a message telling</p>
      <p> 3818 * it to suspend the user.   When enough data arrives later, the tty driver</p>
      <p> 3819 * copies it to the user space directly and notifies FS with a message.</p>
      <p> 3820 */ 3821</p>
      <p> 3822 int cooked, ct, user^ct, buf_ct, cum, enough, eot_seen;</p>
      <p> 3823 vir_bytes in_vir, left;</p>
      <p> 3824 phys_bytes user_phys, tty_phys;</p>
      <p> 3825 char ch, *tty_ptr;</p>
      <p> 3826 struct proc *rp;</p>
      <p> 3827 extern phys_bytes umapO; 3828</p>
      <p> 3329 cooked = ( (tp-&gt;tty_mode &amp; (RAW | CBREAK)) ? 0:1);    /* 1 iff COOKED mode */</p>
      <p> 3830 if (tp-&gt;tty_incount == 0 ||  (cooked &amp;&amp; tp-&gt;tty_lfct == 0)) return(SUSPEND);</p>
      <p> 3831 rp = proc_addr(tp-&gt;tty_inproc);</p>
      <p> 3832 in_vir = (vir_bytes) tp-&gt; tty_in_vir;</p>
      <p> 3833 left = (vir_bytes) tp-&gt;tty_inleft;</p>
      <p> 3834 if ( (user_phys = umap(rp, D, in_vir, left)) == 0) return(E_BAD_ADDR);</p>
      <p> 3835 tty_phys = umap(proc_addr(TTY), D, (vir_bytes) tty_buf, TTY_BUF_SIZE);</p>
      <p> 3836 cum = 0;</p>
      <p> 3837 enough = 0;</p>
      <p> 3838 eot_seen = 0; 3839</p>
      <p> 3840 /* The outer loop iterates on buffers, one buffer load per iteration. */</p>
      <p> 3841 while (tp-&gt;tty_inleft &gt; 0) {</p>
      <p> 3842 buf_ct = MIN(tp-&gt;tty_inleft, tp-&gt;tty_incount);</p>
      <p> 3843 buf_ct = MIN(buf_ct, TTY_BUF_SIZE);</p>
      <p> 3844 ct = 0;</p>
      <p> 3845 tty_ptr = tty_buf; 3846</p>
      <p> 3847 /* The inner loop fills one buffer. */</p>
      <p> 3848 while(buf_ct-- &gt; 0) {</p>
      <p> 3849 ch = #tp-&gt;tty_intail++;</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 511</p>
      <p> 3850 if (tp-&gt;tty_intail == &amp;tp-&gt;tty_inqueue[TTY_IN_BYTES])</p>
      <p> 3851 tp-&gt;tty_intail = tp-&gt;tty_inqueue;</p>
      <p> 3852 *tty_ptr++  =  ch;</p>
      <p> 3853 ct+ +i</p>
      <p> 3854 if (ch == '\n'  || ch = = MARKER) {</p>
      <p> 3855 tp-&gt;tty_lfct—;</p>
      <p> 3856 if (cooked &amp;&amp; ch      MARKER) eot_seen++;</p>
      <p> 3857 enough++; /* exit loop */</p>
      <p> 3858 if (cooked) break; /* only provide 1 line */</p>
      <p> 3859 }</p>
      <p> 3860 } 3861</p>
      <p> 3862 /♦ Copy one buffer to user space.    Be careful about CTRL-D.    In cooked</p>
      <p> 3863 # mode it is not transmitted to user programs, and is not counted as</p>
      <p> 3864 * a character as far as the count goes, but it does occupy space in</p>
      <p> 3865 * the driver's tables and must be counted there.</p>
      <p> 3866 */</p>
      <p> 3867 user_ct = (eot_seen ? ct - 1 : ct);        /* bytes to copy to user */</p>
      <p> 3868 phys_copy(tty_phys, user_phys, (phys_bytes) user_ct);</p>
      <p> 3869 user_pnys += user_ct;</p>
      <p> 3870 cum += user_ct;</p>
      <p> 3871 tp-&gt;tty_inleft ct;</p>
      <p> 3872 tp-&gt;tty_incount -= ct;</p>
      <p> 3873 if (tp-&gt;tty_incount == 0 || enough) break;</p>
      <p> 3874 } 3875</p>
      <p> 3876 tp-&gt;tty_inleft = 0;</p>
      <p> 3877 return(cum);</p>
      <p> 3878 }</p>
      <p> 3881 /» = = :: =  : " : :: =  :  =  :  = =  ::::::::::: : =;=::::::::::;:::::: . ::::: . ::=   . = .  =  </p>
      <p> 3882 * finish *</p>
      <p> 3884 PRIVATE finish(tp, code)  *'</p>
      <p> 3885 register struct tty_struct #tp; /* pointer to tty struct */</p>
      <p> 3886 int code; /* reply code */</p>
      <p> 3887 {</p>
      <p> 3888 /* A command has terminated (possibly due to DEL).    Tell caller */ 3889</p>
      <p> 3890 int replyee, caller; 3891</p>
      <p> 3892 tp-&gt;tty_rwords = 0;</p>
      <p> 3893 tp-&gt;tty_outleft = 0;</p>
      <p> 3894 if (tp-&gt;tty_waiting == N0T_WAITING) return;</p>
      <p> 3895 replyee = (int) tp-&gt;tty_otcaller;</p>
      <p> 3896 caller = (int) tp-&gt;tty_outproc;</p>
      <p> 3897 tty_reply(TASK_REPLY, replyee, caller, code, 0L, 0L);</p>
      <p> 3898 tp-&gt;tty_waiting = N0T_WAITING;</p>
      <p> 512 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 3903 * do_write  *</p>
      <p> 3905 PRIVATE do_write(tp, m_ptr)</p>
      <p> 3906 register struct tty_struct *tp; /* pointer to tty struct */</p>
      <p> 3907 message *m_ptr; /* pointer to message sent to the task */</p>
      <p> 3908 {</p>
      <p> 3909 /+ A process wants to write on a terminal. */ 3910</p>
      <p> 3911 vir_bytes out_vir, out_left;</p>
      <p> 3912 struct proc #rp;</p>
      <p> 3913 extern phys_bytes umapO; 3914</p>
      <p> 3915 /* Copy message parameters to the tty structure. */</p>
      <p> 3916 tp-&gt;tty_otcaller = m_ptr-&gt;m_source;</p>
      <p> 3917 tp-&gt;tty_outproc = m_ptr-&gt;PR0C_NR;</p>
      <p> 3918 tp-&gt;tty_out_vir = m_ptr-&gt;ADDRESS;</p>
      <p> 3919 tp-&gt;tty_outleft = m_ptr-&gt;C0UNT;</p>
      <p> 3920 tp-&gt;tty_waiting = WAITING;</p>
      <p> 3921 tp-&gt;tty_cum = 0; 3922</p>
      <p> 3923 /* Compute the physical address where the data is in user space. */</p>
      <p> 3924 rp = proc_addr(tp-&gt;tty_outproc);</p>
      <p> 3925 out_vir = (vir_bytes) tp-&gt;tty_out_vir;</p>
      <p> 3926 out_left = (vir_bytes) tp-&gt;tty_outleft;</p>
      <p> 3927 if ( (tp-&gt;tty_phys = umap(rp, D, out_vir, out_left)) == 0) {</p>
      <p> 3928 /* Buffer address provided by user is outside its address space. */</p>
      <p> 3929 tp-&gt;tty_cum = E_BAD_ADDR;</p>
      <p> 3930 tp-&gt;tty_outleft = 0;</p>
      <p> 3931 } 3932</p>
      <p> 3933 /* Copy characters from the user process to the terminal. */</p>
      <p> 3934 (*tp-&gt;tty_devstart)(tp); /* copy data to queue and start 1/0 */</p>
      <p> 3935 }</p>
      <p> 3939 * do_ioctl *</p>
      <p> 3941 PRIVATE do_ioctl(tp, m_ptr)</p>
      <p> 3942 register struct tty_struct *tp; /* pointer to tty_struct */</p>
      <p> 3943 message *m_ptr; /* pointer to message sent to task ♦/</p>
      <p> 3944 {</p>
      <p> 3945 /* Perform I0CTL on this terminal. */ 3946</p>
      <p> 3947 long flags, erki, erase, kill, intr, quit, xon, xoff, eof;</p>
      <p> 3948 int r; 3949</p>
      <p> MINIX SOURCE CODE</p>
      <p> File: kernel/tty.c</p>
      <p> 513</p>
      <p> 3950 r = OK;</p>
      <p> 3951 flags = 0;</p>
      <p> 3952 erki = 0;</p>
      <p> 3953 switch(m_ptr-&gt;TTY_REQUEST) {</p>
      <p> 3954 case TIOCSETP:</p>
      <p> 3955 /* Set erase, kill, and flags. */</p>
      <p> 3956 tp-&gt;tty_erase = (char) ((m_ptr-&gt;TTY_SPEK » 8) &amp; BYTE); /* erase */</p>
      <p> 3957 tp-&gt;tty_kill   = (char) ((m_ptr-&gt;TTY_5PEK » 0) &amp; BYTE); /* kill */</p>
      <p> 3958 tp-&gt;tty_mode   = (int) m_ptr-&gt;TTY_FLAGS; /* mode word */</p>
      <p> 3959 break; 3960</p>
      <p> 3961 case TI0CSETC:</p>
      <p> 3962 /* Set intr, quit, xon, xoff, eof (brk not used). */</p>
      <p> 3963 tp-&gt;tty_intr = (char) ((m_ptr-&gt;TTY_SPEK » 24) &amp; BYTE); /* interrupt</p>
      <p> 3964 tp-&gt;tty_quit = (char) ((m_ptr-&gt;TTY_SPEK » 16) &amp; BYTE); /* quit */</p>
      <p> 3965 tp-&gt;tty_xon   = (char) ((m_ptr-&gt;TTY_SPEK »   8) &amp; BYTE); /* CTRL-S */</p>
      <p> 3966 tp-&gt;tty_xoff = (char) ((m_ptr-&gt;TTY_SPEK »   0) 4 BYTE); /* CTRL-Q */</p>
      <p> 3967 tp-&gt;tty_eof   = (char) ((m_ptr-&gt;TTY_FLAGS » 8) &amp; BYTE); /* CTRL-D */</p>
      <p> 3968 break; 3969</p>
      <p> 3970 case TIOCGETP:</p>
      <p> 3971 /* Get erase, kill, and flags. */</p>
      <p> 3972 erase = ((long) tp-&gt;tty_erase) &amp; BYTE;</p>
      <p> 3973 kill   = ((long) tp-&gt;tty_kill) &amp; BYTE;</p>
      <p> 3974 erki   = (erase &lt;&lt; 8) | kill;</p>
      <p> 3975 flags = (long) tp-&gt;tty_mode;</p>
      <p> 3976 break; 3977</p>
      <p> 3978 case TIOCGETC:</p>
      <p> 3979 /* Get intr, quit, xon, xoff, eof. */</p>
      <p> 3980 intr   = ((long) tp-&gt;tty_intr) &amp; BYTE;</p>
      <p> 3981 quit   = ((long) tp-&gt;tty_quit) &amp; BYTE;</p>
      <p> 3982 xon     = ((long) tp-&gt;tty_xon)   &amp; BYTE;</p>
      <p> 3983 xoff   = ((long) tp-&gt;tty_xoff) &amp; BYTE;</p>
      <p> 3984 eof     = ((long) tp-&gt;tty_eof)   &amp; BYTE;</p>
      <p> 3985 erki   = (intr « 24) |  (quit « 16)  |  (xon « 8)  | (xoff « 0);</p>
      <p> 3986 flags = (eof «8);</p>
      <p> 3987 break; 3988</p>
      <p> 3989 default:</p>
      <p> 3990 r = EINVAL;</p>
      <p> 3991 } 3992</p>
      <p> 3993 /* Send the reply. */</p>
      <p> 3994 tty_reply(TASK_REPLY, m_ptr-&gt;m_source, m_ptr-&gt;PROC_NR, r, flags, erki);</p>
      <p> 514 File: kernel/tty.c MINIX SOURCE CODE</p>
      <p> 4001 * do_cancel *</p>
      <p> 4002 = = = = = = : = = = = = = = = = =     = = = = = = = = = = = = = = = = =  = = = = = =  = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</p>
      <p> 4003 PRIVATE do_cancel(tp, m_ptr)</p>
      <p> 4004 register struct tty_struct *tp; /* pointer to tty_struct »/</p>
      <p> 4005 message *m_ptr; /♦ pointer to message sent to task */</p>
      <p> 4006 {</p>
      <p> 4007 /* A signal has been sent to a process that is hanging trying to read or write.</p>
      <p> 4008 * The pending read or write must be finished off immediately.</p>
      <p> 4009 */ 4010</p>
      <p> 4011 /* First check to see if the process is indeed hanging.    If it is not, don't</p>
      <p> 4012 * reply (to avoid race conditions). 401? #/</p>
      <p> 4014 if (tp-&gt;tty_inleft == 0 &amp;&amp; tp-&gt;tty_outleft == 0) return; 4015</p>
      <p> 4016 /« Kill off input and output. */</p>
    </div>
  </body>
</html>
